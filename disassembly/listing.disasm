Disassembly Listing for cs66b
Generated From:
F:/2017/cs66-b/cs66b.X/dist/default/debug/cs66b.X.debug.elf
2017-11-19 17:25:30

---  F:/2017/cs66-b/cs66b.X/src/soc/ticker.c  -----------------------------------------------------------
1:                 #include <stdint.h>
2:                 #include "ticker.h"
3:                 #include "../app/event.h"
4:                 uint32_t  tickerMs=0x00ul;
5:                 uint32_t  tickerSec=0x00ul;
6:                 uint32_t  tickerMsPer10Ms=0x00ul;
7:                 
8:                 void  TMR1_CallBack(void)
9:                 {
003164  FA0000     LNK #0x0
10:                	tickerMs++;
003166  804370     MOV tickerMs, W0
003168  804381     MOV 0x870, W1
00316A  400061     ADD W0, #0x1, W0
00316C  4880E0     ADDC W1, #0x0, W1
00316E  884370     MOV W0, tickerMs
003170  884381     MOV W1, 0x870
11:                }
003172  FA8000     ULNK
003174  060000     RETURN
12:                
13:                void ticker_ms_set(uint32_t tick)
14:                {
003176  FA0004     LNK #0x4
003178  BE8F00     MOV.D W0, [W14]
15:                	tickerMs=tick;
00317A  BE011E     MOV.D [W14], W2
00317C  884372     MOV W2, tickerMs
00317E  884383     MOV W3, 0x870
16:                }
003180  FA8000     ULNK
003182  060000     RETURN
17:                
18:                uint32_t ticker_ms_get(void)
19:                {
003184  FA0000     LNK #0x0
20:                	return tickerMs;
003186  804370     MOV tickerMs, W0
003188  804381     MOV 0x870, W1
21:                }
00318A  FA8000     ULNK
00318C  060000     RETURN
22:                
23:                void ticker_ms_delay(uint16_t ms)
24:                {
00318E  FA000A     LNK #0xA
003190  980740     MOV W0, [W14+8]
25:                	uint32_t t32=0,tm=0;
003192  B80060     MUL.UU W0, #0, W0
003194  BE8F00     MOV.D W0, [W14]
003196  B80060     MUL.UU W0, #0, W0
003198  980720     MOV W0, [W14+4]
00319A  980731     MOV W1, [W14+6]
26:                	t32=ticker_ms_get();
00319C  07FFF3     RCALL ticker_ms_get
00319E  BE8F00     MOV.D W0, [W14]
27:                	if(t32 & 0x80000000){
0031A0  BE001E     MOV.D [W14], W0
0031A2  500FE0     SUB W0, #0x0, [W15]
0031A4  588FE0     SUBB W1, #0x0, [W15]
0031A6  3D0004     BRA GE, 0x31B0
28:                		ticker_ms_set(0);
0031A8  B80060     MUL.UU W0, #0, W0
0031AA  07FFE5     RCALL ticker_ms_set
29:                		t32=0;
0031AC  B80060     MUL.UU W0, #0, W0
0031AE  BE8F00     MOV.D W0, [W14]
30:                	}
31:                	t32+=(uint32_t)ms;
0031B0  90004E     MOV [W14+8], W0
0031B2  EB0080     CLR W1
0031B4  400F1E     ADD W0, [W14], [W14]
0031B6  48975E     ADDC W1, [++W14], [W14--]
32:                	while(tm<t32){
0031B8  370003     BRA 0x31C0
0031C0  90002E     MOV [W14+4], W0
0031C2  9000BE     MOV [W14+6], W1
0031C4  500FBE     SUB W0, [W14++], [W15]
0031C6  588FAE     SUBB W1, [W14--], [W15]
0031C8  39FFF8     BRA NC, 0x31BA
33:                		tm=ticker_ms_get();
0031BA  07FFE4     RCALL ticker_ms_get
0031BC  980720     MOV W0, [W14+4]
0031BE  980731     MOV W1, [W14+6]
34:                	}
35:                }
0031CA  FA8000     ULNK
0031CC  060000     RETURN
36:                //
37:                void TMR2_CallBack(void)
38:                {
0031CE  FA0000     LNK #0x0
39:                    tickerMsPer10Ms++;
0031D0  8043B0     MOV tickerMsPer10Ms, W0
0031D2  8043C1     MOV 0x878, W1
0031D4  400061     ADD W0, #0x1, W0
0031D6  4880E0     ADDC W1, #0x0, W1
0031D8  8843B0     MOV W0, tickerMsPer10Ms
0031DA  8843C1     MOV W1, 0x878
40:                    event |=  flg_TICKER_10MS_PER;
0031DC  8043D0     MOV event, W0
0031DE  A01000     BSET W0, #1
0031E0  8843D0     MOV W0, event
41:                }
0031E2  FA8000     ULNK
0031E4  060000     RETURN
42:                
43:                uint32_t ticker_10ms_per_get(void)
44:                {
0031E6  FA0000     LNK #0x0
45:                    return tickerMsPer10Ms;
0031E8  8043B0     MOV tickerMsPer10Ms, W0
0031EA  8043C1     MOV 0x878, W1
46:                }
0031EC  FA8000     ULNK
0031EE  060000     RETURN
47:                
48:                void ticker_10ms_per_set(uint32_t tick)
49:                {
0031F0  FA0004     LNK #0x4
0031F2  BE8F00     MOV.D W0, [W14]
50:                    tickerMsPer10Ms=tick;
0031F4  BE011E     MOV.D [W14], W2
0031F6  8843B2     MOV W2, tickerMsPer10Ms
0031F8  8843C3     MOV W3, 0x878
51:                }
0031FA  FA8000     ULNK
0031FC  060000     RETURN
52:                
53:                
---  F:/2017/cs66-b/cs66b.X/src/soc/flash.c  ------------------------------------------------------------
1:                 #include "flash.h"
2:                 #include "../global/globle.h"
3:                 uint16_t flashOffsetAddr;
4:                 uint8_t flashByteTemp;
5:                 void m_flash_read(uint32_t addr,uint8_t* d,uint16_t len)
6:                 {
000000  040200     GOTO __resetPRI, __reset
7:                     //uint8_t t8;
8:                 	uint16_t i;
9:                     //uint16_t offsetAddr;
10:                    TBLPAG=(uint8_t)((addr>>16)&0x7f);
00000A  000360     NOP
11:                    flashOffsetAddr=(uint16_t)(addr & 0xffff);
00001A  0030B2     NOP
12:                    asm("mov _flashOffsetAddr,w4");
00001E  000360     NOP
13:                    for(i=0;i<len;){
000020  000360     NOP
000074  000360     NOP
14:                        asm("TBLRDL.B [W4],W3");
000026  000360     NOP
15:                        asm("mov w3,_flashByteTemp");
000028  000360     NOP
16:                        if(i<len)d[i]=flashByteTemp;        
00002A  000360     NOP
00002C  000360     NOP
17:                        i++;
00003C  000360     NOP
18:                		
19:                		asm("inc w4,w4");
00003E  000360     NOP
20:                        asm("TBLRDL.B [W4],W3");
000040  000360     NOP
21:                        asm("mov w3,_flashByteTemp");
000042  000360     NOP
22:                        if(i<len)d[i]=flashByteTemp; 	
000044  000360     NOP
23:                		i++;
000056  000360     NOP
24:                
25:                		asm("dec w4,w4");
000058  000360     NOP
26:                        asm("TBLRDH.B [W4],W3");
00005A  000360     NOP
27:                        asm("mov w3,_flashByteTemp");
00005C  000360     NOP
28:                        if(i<len)d[i]=flashByteTemp; 	
00005E  000360     NOP
29:                		i++;
000070  000360     NOP
30:                		
31:                		asm("inc2 w4,w4");
000072  000360     NOP
32:                    }
33:                }
00007C  000360     NOP
00007E  000360     NOP
34:                
35:                void m_flash_erase(uint32_t addr,uint16_t len)
36:                {
000080  000360     NOP
000082  000360     NOP
37:                    TBLPAG=(uint8_t)((addr>>16)&0x7f);
000086  000360     NOP
38:                    flashOffsetAddr=(uint16_t)(addr & 0xffff);
000094  000360     NOP
39:                	__builtin_tblwtl(flashOffsetAddr, 0x0000); // Set base address of er
000098  000360     NOP
40:                	NVMCON = 0x4042; // Initialize NVMCON
00009E  000360     NOP
0000A0  000360     NOP
41:                	asm("DISI #5"); // Block all interrupts w
0000A2  000360     NOP
42:                	__builtin_write_NVM(); // check function to perf
0000A4  000360     NOP
0000A6  000360     NOP
43:                	__nop();
0000B2  000360     NOP
44:                	__nop();	
0000B4  000360     NOP
45:                	asm("btsc	NVMCON, #15");
0000B6  000360     NOP
46:                	__nop();
0000B8  000360     NOP
47:                	__nop();
0000BA  000360     NOP
48:                }
0000BC  000360     NOP
49:                
50:                void m_flash_write(uint32_t addr,uint8_t* d,uint16_t len)
51:                {
0000C0  000360     NOP
0000C2  000360     NOP
0000C4  000360     NOP
52:                	uint16_t i=0;
0000CA  000360     NOP
0000CC  000360     NOP
53:                	
54:                    TBLPAG=(uint8_t)((addr>>16)&0x7f);
0000CE  000360     NOP
55:                    flashOffsetAddr=(uint16_t)(addr & 0xffff);
0000DE  000360     NOP
0000E0  000360     NOP
56:                	
57:                	asm("mov _flashOffsetAddr,w4");
0000E2  000360     NOP
58:                	
59:                	for(i=0;i<len;){
0000E4  000360     NOP
000158  000360     NOP
60:                        NVMCON = 0x4003;
0000EA  000360     NOP
61:                		flashByteTemp=0xff;
0000EE  000360     NOP
0000F0  000360     NOP
62:                		if(i<len)flashByteTemp=d[i];
0000F2  000360     NOP
63:                		asm("mov _flashByteTemp,w3");
64:                		asm("TBLWTL.B w3, [W4]");
000104  000360     NOP
65:                		i++;
000106  000360     NOP
66:                		
67:                		asm("inc w4,w4");
000108  000360     NOP
68:                		flashByteTemp=0xff;
00010A  000360     NOP
69:                		if(i<len)flashByteTemp=d[i];
00010E  000360     NOP
000110  000360     NOP
70:                		asm("mov _flashByteTemp,w3");		
00011E  000360     NOP
71:                		asm("TBLWTL.B w3, [W4]");
000120  000360     NOP
72:                		i++;
000122  000360     NOP
73:                		
74:                		asm("dec w4,w4");
000124  000360     NOP
75:                		flashByteTemp=0xff;
000126  000360     NOP
76:                		if(i<len)flashByteTemp=d[i];
00012A  000360     NOP
77:                		asm("mov _flashByteTemp,w3");		
00013A  000360     NOP
78:                		asm("TBLWTH.B w3, [W4]");		
00013C  000360     NOP
79:                		i++;
00013E  000360     NOP
80:                		
81:                		asm("inc2 w4,w4");
000140  000360     NOP
82:                		
83:                		
84:                		asm("DISI #5");
000142  000360     NOP
85:                		__builtin_write_NVM();
000144  000360     NOP
86:                		__nop();
000152  000360     NOP
87:                		__nop();		
000154  000360     NOP
88:                		asm("btsc	NVMCON, #15");
000156  000360     NOP
89:                	}
90:                	__nop();
000160  000360     NOP
91:                	__nop();
000162  000360     NOP
92:                }
000164  000360     NOP
---  F:/2017/cs66-b/cs66b.X/src/soc/delay.c  ------------------------------------------------------------
1:                 #include "delay.h"
2:                 
3:                 void delay_us(uint16_t us)
4:                 {
003326  FA0002     LNK #0x2
003328  780F00     MOV W0, [W14]
5:                 	if(us>2000)us=2000;
00332A  207D00     MOV #0x7D0, W0
00332C  78009E     MOV [W14], W1
00332E  508F80     SUB W1, W0, [W15]
003330  360009     BRA LEU, 0x3344
003332  207D00     MOV #0x7D0, W0
003334  780F00     MOV W0, [W14]
6:                 	while(us){
003336  370006     BRA 0x3344
003344  78001E     MOV [W14], W0
003346  E00000     CP0 W0
003348  3AFFF7     BRA NZ, 0x3338
7:                 		us--;
003338  E90F1E     DEC [W14], [W14]
8:                 		asm("NOP");
00333A  000000     NOP
9:                 		asm("NOP");
00333C  000000     NOP
10:                		asm("NOP");
00333E  000000     NOP
11:                		asm("NOP");
003340  000000     NOP
12:                		asm("NOP");
003342  000000     NOP
13:                	}
14:                }
00334A  FA8000     ULNK
00334C  060000     RETURN
15:                void delay_ms(uint16_t ms)
16:                {
00334E  FA0002     LNK #0x2
003350  780F00     MOV W0, [W14]
17:                	if(ms>30000)ms=30000;
003352  275300     MOV #0x7530, W0
003354  78009E     MOV [W14], W1
003356  508F80     SUB W1, W0, [W15]
003358  360006     BRA LEU, 0x3366
00335A  275300     MOV #0x7530, W0
00335C  780F00     MOV W0, [W14]
18:                	while(ms){
00335E  370003     BRA 0x3366
003366  78001E     MOV [W14], W0
003368  E00000     CP0 W0
00336A  3AFFFA     BRA NZ, 0x3360
19:                		ms--;
003360  E90F1E     DEC [W14], [W14]
20:                		delay_us(1000);
003362  203E80     MOV #0x3E8, W0
003364  07FFE0     RCALL delay_us
21:                	}
22:                }
00336C  FA8000     ULNK
00336E  060000     RETURN
---  F:/2017/cs66-b/cs66b.X/src/driver/lcd.c  -----------------------------------------------------------
1:                 #include "drivers.h"
2:                 #include "lcd_code_table.h"
3:                 #include "lcd_code_table_ex.h"
4:                 #include "lcd.h"
5:                 
6:                 extern volatile bool blackEn;
7:                 //uint8_t* pLcdReg=(uint8_t*)(&LCDDATA0); 
8:                 uint16_t pLCD[LCD_PIXEL_REGISTER_SIZE];
9:                 
10:                const uint8_t  LCDDigitalIndexTable[]="0123456789abcdefghijklmnopqrstuvwxyz.-: GH";
11:                const uint8_t LCDDigitalTable[]=
12:                {
13:                    LCD_CODE_0,LCD_CODE_1,LCD_CODE_2,LCD_CODE_3,
14:                    LCD_CODE_4,LCD_CODE_5,LCD_CODE_6,LCD_CODE_7,
15:                    LCD_CODE_8,LCD_CODE_9,LCD_CODE_A,LCD_CODE_B,
16:                    LCD_CODE_C,LCD_CODE_D,LCD_CODE_E,LCD_CODE_F,
17:                    LCD_CODE_G,LCD_CODE_H,LCD_CODE_I,LCD_CODE_J,
18:                    LCD_CODE_K,LCD_CODE_L,LCD_CODE_M,LCD_CODE_N,
19:                    LCD_CODE_O,LCD_CODE_P,LCD_CODE_Q,LCD_CODE_R,
20:                    LCD_CODE_S,LCD_CODE_T,LCD_CODE_U,LCD_CODE_V,
21:                    LCD_CODE_W,LCD_CODE_X,LCD_CODE_Y,LCD_CODE_Z,
22:                    LCD_CODE_DOT,LCD_CODE__,LCD_CODE_DDOT,0x00,
23:                	LCD_CODE_G_U,LCD_CODE_H_U,
24:                };
25:                const uint8_t LCDDigitalTableIndexEx[]="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
26:                const uint16_t LCDDigitalTableEx[]=
27:                {
28:                    LCD_CODE_0_EX,LCD_CODE_1_EX,LCD_CODE_2_EX,LCD_CODE_3_EX,
29:                    LCD_CODE_4_EX,LCD_CODE_5_EX,LCD_CODE_6_EX,LCD_CODE_7_EX,
30:                    LCD_CODE_8_EX,LCD_CODE_9_EX,LCD_CODE_a_EX,LCD_CODE_b_EX,
31:                    LCD_CODE_c_EX,LCD_CODE_d_EX,LCD_CODE_e_EX,LCD_CODE_f_EX,
32:                    LCD_CODE_g_EX,LCD_CODE_h_EX,LCD_CODE_i_EX,LCD_CODE_j_EX,
33:                    LCD_CODE_k_EX,LCD_CODE_l_EX,LCD_CODE_m_EX,LCD_CODE_n_EX,
34:                    LCD_CODE_o_EX,LCD_CODE_p_EX,LCD_CODE_q_EX,LCD_CODE_r_EX,
35:                    LCD_CODE_s_EX,LCD_CODE_t_EX,LCD_CODE_u_EX,LCD_CODE_v_EX,
36:                    LCD_CODE_w_EX,LCD_CODE_x_EX,LCD_CODE_y_EX,LCD_CODE_z_EX,
37:                	LCD_CODE_A_EX,LCD_CODE_B_EX,
38:                    LCD_CODE_C_EX,LCD_CODE_D_EX,LCD_CODE_E_EX,LCD_CODE_F_EX,
39:                    LCD_CODE_G_EX,LCD_CODE_H_EX,LCD_CODE_I_EX,LCD_CODE_J_EX,
40:                    LCD_CODE_K_EX,LCD_CODE_L_EX,LCD_CODE_M_EX,LCD_CODE_N_EX,
41:                    LCD_CODE_O_EX,LCD_CODE_P_EX,LCD_CODE_Q_EX,LCD_CODE_R_EX,
42:                    LCD_CODE_S_EX,LCD_CODE_T_EX,LCD_CODE_U_EX,LCD_CODE_V_EX,
43:                    LCD_CODE_W_EX,LCD_CODE_X_EX,LCD_CODE_Y_EX,LCD_CODE_Z_EX,	
44:                };
45:                void lcd_set_com_seg(uint8_t com,uint8_t seg,uint16_t show)
46:                {
0004FC  FA0008     LNK #0x8
0004FE  984740     MOV.B W0, [W14+4]
000500  984751     MOV.B W1, [W14+5]
000502  980732     MOV W2, [W14+6]
47:                	uint16_t offset;
48:                	uint16_t	bits;
49:                	if(com>7)return;
000504  90404E     MOV.B [W14+4], W0
000506  504FE7     SUB.B W0, #0x7, [W15]
000508  3E0034     BRA GTU, 0x572
000572  000000     NOP
000574  370001     BRA 0x578
50:                	if(seg>63)return;
00050A  9040DE     MOV.B [W14+5], W1
00050C  B3C3F0     MOV.B #0x3F, W0
00050E  50CF80     SUB.B W1, W0, [W15]
000510  3E0032     BRA GTU, 0x576
000576  000000     NOP
51:                	offset=com*4 + seg/16;
000512  90404E     MOV.B [W14+4], W0
000514  FB8000     ZE W0, W0
000516  DD00C2     SL W0, #2, W1
000518  90405E     MOV.B [W14+5], W0
00051A  FB8000     ZE W0, W0
00051C  DE0044     LSR W0, #4, W0
00051E  784000     MOV.B W0, W0
000520  FB8000     ZE W0, W0
000522  408000     ADD W1, W0, W0
000524  780F00     MOV W0, [W14]
52:                	bits=seg%16;
000526  90405E     MOV.B [W14+5], W0
000528  FB8000     ZE W0, W0
00052A  60006F     AND W0, #0xF, W0
00052C  980710     MOV W0, [W14+2]
53:                	if(show){
00052E  90003E     MOV [W14+6], W0
000530  E00000     CP0 W0
000532  32000F     BRA Z, 0x552
54:                		pLCD[offset] |= (1<<bits);
000534  78001E     MOV [W14], W0
000536  400080     ADD W0, W0, W1
000538  209200     MOV #0x920, W0
00053A  408000     ADD W1, W0, W0
00053C  780090     MOV [W0], W1
00053E  90001E     MOV [W14+2], W0
000540  200012     MOV #0x1, W2
000542  DD1000     SL W2, W0, W0
000544  700081     IOR W0, W1, W1
000546  78001E     MOV [W14], W0
000548  400100     ADD W0, W0, W2
00054A  209200     MOV #0x920, W0
00054C  410000     ADD W2, W0, W0
00054E  780801     MOV W1, [W0]
000550  370013     BRA 0x578
55:                	}else{
56:                		pLCD[offset] &= ~(1<<bits);
000552  78001E     MOV [W14], W0
000554  400080     ADD W0, W0, W1
000556  209200     MOV #0x920, W0
000558  408000     ADD W1, W0, W0
00055A  780090     MOV [W0], W1
00055C  90001E     MOV [W14+2], W0
00055E  200012     MOV #0x1, W2
000560  DD1000     SL W2, W0, W0
000562  EA8000     COM W0, W0
000564  608080     AND W1, W0, W1
000566  78001E     MOV [W14], W0
000568  400100     ADD W0, W0, W2
00056A  209200     MOV #0x920, W0
00056C  410000     ADD W2, W0, W0
00056E  780801     MOV W1, [W0]
000570  370003     BRA 0x578
57:                	}
58:                }
000578  FA8000     ULNK
00057A  060000     RETURN
59:                void lcd_disp_level_bar(uint8_t bar,uint8_t show)
60:                {
00057C  FA0004     LNK #0x4
00057E  984720     MOV.B W0, [W14+2]
000580  984731     MOV.B W1, [W14+3]
61:                	//0-49 swap 
62:                	uint8_t __bar;
63:                	if(bar>49)return;
000582  9040AE     MOV.B [W14+2], W1
000584  B3C310     MOV.B #0x31, W0
000586  50CF80     SUB.B W1, W0, [W15]
000588  3E019C     BRA GTU, 0x8C2
0008C2  000000     NOP
64:                	__bar=49-bar;
00058A  B3C311     MOV.B #0x31, W1
00058C  90402E     MOV.B [W14+2], W0
00058E  50CF00     SUB.B W1, W0, [W14]
65:                	switch(__bar){
000590  FB801E     ZE [W14], W0
000592  DE80CF     ASR W0, #15, W1
000594  200312     MOV #0x31, W2
000596  200003     MOV #0x0, W3
000598  500F82     SUB W0, W2, [W15]
00059A  588F83     SUBB W1, W3, [W15]
00059C  3E0193     BRA GTU, 0x8C4
00059E  016000     BRA W0
0005A0  370031     BRA 0x604
0005A2  370037     BRA 0x612
0005A4  37003D     BRA 0x620
0005A6  370043     BRA 0x62E
0005A8  370049     BRA 0x63C
0005AA  37004F     BRA 0x64A
0005AC  370055     BRA 0x658
0005AE  37005B     BRA 0x666
0005B0  370061     BRA 0x674
0005B2  370067     BRA 0x682
0005B4  37006D     BRA 0x690
0005B6  370073     BRA 0x69E
0005B8  370079     BRA 0x6AC
0005BA  37007F     BRA 0x6BA
0005BC  370085     BRA 0x6C8
0005BE  37008B     BRA 0x6D6
0005C0  370091     BRA 0x6E4
0005C2  370097     BRA 0x6F2
0005C4  37009D     BRA 0x700
0005C6  3700A3     BRA 0x70E
0005C8  3700A9     BRA 0x71C
0005CA  3700AF     BRA 0x72A
0005CC  3700B5     BRA 0x738
0005CE  3700BB     BRA 0x746
0005D0  3700C1     BRA 0x754
0005D2  3700C7     BRA 0x762
0005D4  3700CD     BRA 0x770
0005D6  3700D3     BRA 0x77E
0005D8  3700D9     BRA 0x78C
0005DA  3700DF     BRA 0x79A
0005DC  3700E5     BRA 0x7A8
0005DE  3700EB     BRA 0x7B6
0005E0  3700F1     BRA 0x7C4
0005E2  3700F7     BRA 0x7D2
0005E4  3700FD     BRA 0x7E0
0005E6  370103     BRA 0x7EE
0005E8  370109     BRA 0x7FC
0005EA  37010F     BRA 0x80A
0005EC  370115     BRA 0x818
0005EE  37011B     BRA 0x826
0005F0  370121     BRA 0x834
0005F2  370127     BRA 0x842
0005F4  37012D     BRA 0x850
0005F6  370133     BRA 0x85E
0005F8  370139     BRA 0x86C
0005FA  37013F     BRA 0x87A
0005FC  370145     BRA 0x888
0005FE  37014B     BRA 0x896
000600  370151     BRA 0x8A4
000602  370157     BRA 0x8B2
66:                		case 0:		lcd_set_com_seg(7,63,show);	break;
000604  90403E     MOV.B [W14+3], W0
000606  FB8000     ZE W0, W0
000608  780100     MOV W0, W2
00060A  B3C3F1     MOV.B #0x3F, W1
00060C  B3C070     MOV.B #0x7, W0
00060E  07FF76     RCALL lcd_set_com_seg
000610  370159     BRA 0x8C4
67:                		case 1:		lcd_set_com_seg(6,63,show);	break;
000612  90403E     MOV.B [W14+3], W0
000614  FB8000     ZE W0, W0
000616  780100     MOV W0, W2
000618  B3C3F1     MOV.B #0x3F, W1
00061A  B3C060     MOV.B #0x6, W0
00061C  07FF6F     RCALL lcd_set_com_seg
00061E  370152     BRA 0x8C4
68:                		case 2:		lcd_set_com_seg(5,63,show);	break;
000620  90403E     MOV.B [W14+3], W0
000622  FB8000     ZE W0, W0
000624  780100     MOV W0, W2
000626  B3C3F1     MOV.B #0x3F, W1
000628  B3C050     MOV.B #0x5, W0
00062A  07FF68     RCALL lcd_set_com_seg
00062C  37014B     BRA 0x8C4
69:                		case 3:		lcd_set_com_seg(0,63,show);	break;
00062E  90403E     MOV.B [W14+3], W0
000630  FB8000     ZE W0, W0
000632  780100     MOV W0, W2
000634  B3C3F1     MOV.B #0x3F, W1
000636  EB4000     CLR.B W0
000638  07FF61     RCALL lcd_set_com_seg
00063A  370144     BRA 0x8C4
70:                		
71:                		case 4:		lcd_set_com_seg(1,63,show);	break;
00063C  90403E     MOV.B [W14+3], W0
00063E  FB8000     ZE W0, W0
000640  780100     MOV W0, W2
000642  B3C3F1     MOV.B #0x3F, W1
000644  B3C010     MOV.B #0x1, W0
000646  07FF5A     RCALL lcd_set_com_seg
000648  37013D     BRA 0x8C4
72:                		case 5:		lcd_set_com_seg(2,63,show);	break;
00064A  90403E     MOV.B [W14+3], W0
00064C  FB8000     ZE W0, W0
00064E  780100     MOV W0, W2
000650  B3C3F1     MOV.B #0x3F, W1
000652  B3C020     MOV.B #0x2, W0
000654  07FF53     RCALL lcd_set_com_seg
000656  370136     BRA 0x8C4
73:                		case 6:		lcd_set_com_seg(3,63,show);	break;
000658  90403E     MOV.B [W14+3], W0
00065A  FB8000     ZE W0, W0
00065C  780100     MOV W0, W2
00065E  B3C3F1     MOV.B #0x3F, W1
000660  B3C030     MOV.B #0x3, W0
000662  07FF4C     RCALL lcd_set_com_seg
000664  37012F     BRA 0x8C4
74:                		case 7:		lcd_set_com_seg(4,63,show);	break;
000666  90403E     MOV.B [W14+3], W0
000668  FB8000     ZE W0, W0
00066A  780100     MOV W0, W2
00066C  B3C3F1     MOV.B #0x3F, W1
00066E  B3C040     MOV.B #0x4, W0
000670  07FF45     RCALL lcd_set_com_seg
000672  370128     BRA 0x8C4
75:                		
76:                		case 8:		lcd_set_com_seg(4,62,show);	break;
000674  90403E     MOV.B [W14+3], W0
000676  FB8000     ZE W0, W0
000678  780100     MOV W0, W2
00067A  B3C3E1     MOV.B #0x3E, W1
00067C  B3C040     MOV.B #0x4, W0
00067E  07FF3E     RCALL lcd_set_com_seg
000680  370121     BRA 0x8C4
77:                		case 9:		lcd_set_com_seg(3,62,show);	break;		
000682  90403E     MOV.B [W14+3], W0
000684  FB8000     ZE W0, W0
000686  780100     MOV W0, W2
000688  B3C3E1     MOV.B #0x3E, W1
00068A  B3C030     MOV.B #0x3, W0
00068C  07FF37     RCALL lcd_set_com_seg
00068E  37011A     BRA 0x8C4
78:                		case 10:	lcd_set_com_seg(2,62,show);	break;
000690  90403E     MOV.B [W14+3], W0
000692  FB8000     ZE W0, W0
000694  780100     MOV W0, W2
000696  B3C3E1     MOV.B #0x3E, W1
000698  B3C020     MOV.B #0x2, W0
00069A  07FF30     RCALL lcd_set_com_seg
00069C  370113     BRA 0x8C4
79:                		case 11:	lcd_set_com_seg(1,62,show);	break;
00069E  90403E     MOV.B [W14+3], W0
0006A0  FB8000     ZE W0, W0
0006A2  780100     MOV W0, W2
0006A4  B3C3E1     MOV.B #0x3E, W1
0006A6  B3C010     MOV.B #0x1, W0
0006A8  07FF29     RCALL lcd_set_com_seg
0006AA  37010C     BRA 0x8C4
80:                		
81:                		case 12:	lcd_set_com_seg(0,62,show);	break;
0006AC  90403E     MOV.B [W14+3], W0
0006AE  FB8000     ZE W0, W0
0006B0  780100     MOV W0, W2
0006B2  B3C3E1     MOV.B #0x3E, W1
0006B4  EB4000     CLR.B W0
0006B6  07FF22     RCALL lcd_set_com_seg
0006B8  370105     BRA 0x8C4
82:                		case 13:	lcd_set_com_seg(5,62,show);	break;
0006BA  90403E     MOV.B [W14+3], W0
0006BC  FB8000     ZE W0, W0
0006BE  780100     MOV W0, W2
0006C0  B3C3E1     MOV.B #0x3E, W1
0006C2  B3C050     MOV.B #0x5, W0
0006C4  07FF1B     RCALL lcd_set_com_seg
0006C6  3700FE     BRA 0x8C4
83:                		case 14:	lcd_set_com_seg(6,62,show);	break;
0006C8  90403E     MOV.B [W14+3], W0
0006CA  FB8000     ZE W0, W0
0006CC  780100     MOV W0, W2
0006CE  B3C3E1     MOV.B #0x3E, W1
0006D0  B3C060     MOV.B #0x6, W0
0006D2  07FF14     RCALL lcd_set_com_seg
0006D4  3700F7     BRA 0x8C4
84:                		case 15:	lcd_set_com_seg(7,62,show);	break;
0006D6  90403E     MOV.B [W14+3], W0
0006D8  FB8000     ZE W0, W0
0006DA  780100     MOV W0, W2
0006DC  B3C3E1     MOV.B #0x3E, W1
0006DE  B3C070     MOV.B #0x7, W0
0006E0  07FF0D     RCALL lcd_set_com_seg
0006E2  3700F0     BRA 0x8C4
85:                		
86:                		case 16:	lcd_set_com_seg(7,61,show);	break;
0006E4  90403E     MOV.B [W14+3], W0
0006E6  FB8000     ZE W0, W0
0006E8  780100     MOV W0, W2
0006EA  B3C3D1     MOV.B #0x3D, W1
0006EC  B3C070     MOV.B #0x7, W0
0006EE  07FF06     RCALL lcd_set_com_seg
0006F0  3700E9     BRA 0x8C4
87:                		case 17:	lcd_set_com_seg(6,61,show);	break;
0006F2  90403E     MOV.B [W14+3], W0
0006F4  FB8000     ZE W0, W0
0006F6  780100     MOV W0, W2
0006F8  B3C3D1     MOV.B #0x3D, W1
0006FA  B3C060     MOV.B #0x6, W0
0006FC  07FEFF     RCALL lcd_set_com_seg
0006FE  3700E2     BRA 0x8C4
88:                		case 18:	lcd_set_com_seg(5,61,show);	break;
000700  90403E     MOV.B [W14+3], W0
000702  FB8000     ZE W0, W0
000704  780100     MOV W0, W2
000706  B3C3D1     MOV.B #0x3D, W1
000708  B3C050     MOV.B #0x5, W0
00070A  07FEF8     RCALL lcd_set_com_seg
00070C  3700DB     BRA 0x8C4
89:                		case 19:	lcd_set_com_seg(0,61,show);	break;
00070E  90403E     MOV.B [W14+3], W0
000710  FB8000     ZE W0, W0
000712  780100     MOV W0, W2
000714  B3C3D1     MOV.B #0x3D, W1
000716  EB4000     CLR.B W0
000718  07FEF1     RCALL lcd_set_com_seg
00071A  3700D4     BRA 0x8C4
90:                		
91:                		case 20:	lcd_set_com_seg(1,61,show);	break;
00071C  90403E     MOV.B [W14+3], W0
00071E  FB8000     ZE W0, W0
000720  780100     MOV W0, W2
000722  B3C3D1     MOV.B #0x3D, W1
000724  B3C010     MOV.B #0x1, W0
000726  07FEEA     RCALL lcd_set_com_seg
000728  3700CD     BRA 0x8C4
92:                		case 21:	lcd_set_com_seg(2,61,show);	break;
00072A  90403E     MOV.B [W14+3], W0
00072C  FB8000     ZE W0, W0
00072E  780100     MOV W0, W2
000730  B3C3D1     MOV.B #0x3D, W1
000732  B3C020     MOV.B #0x2, W0
000734  07FEE3     RCALL lcd_set_com_seg
000736  3700C6     BRA 0x8C4
93:                		case 22:	lcd_set_com_seg(3,61,show);	break;
000738  90403E     MOV.B [W14+3], W0
00073A  FB8000     ZE W0, W0
00073C  780100     MOV W0, W2
00073E  B3C3D1     MOV.B #0x3D, W1
000740  B3C030     MOV.B #0x3, W0
000742  07FEDC     RCALL lcd_set_com_seg
000744  3700BF     BRA 0x8C4
94:                		case 23:	lcd_set_com_seg(4,61,show);	break;
000746  90403E     MOV.B [W14+3], W0
000748  FB8000     ZE W0, W0
00074A  780100     MOV W0, W2
00074C  B3C3D1     MOV.B #0x3D, W1
00074E  B3C040     MOV.B #0x4, W0
000750  07FED5     RCALL lcd_set_com_seg
000752  3700B8     BRA 0x8C4
95:                		
96:                		case 24:	lcd_set_com_seg(4,60,show);	break;
000754  90403E     MOV.B [W14+3], W0
000756  FB8000     ZE W0, W0
000758  780100     MOV W0, W2
00075A  B3C3C1     MOV.B #0x3C, W1
00075C  B3C040     MOV.B #0x4, W0
00075E  07FECE     RCALL lcd_set_com_seg
000760  3700B1     BRA 0x8C4
97:                		case 25:	lcd_set_com_seg(3,60,show);	break;
000762  90403E     MOV.B [W14+3], W0
000764  FB8000     ZE W0, W0
000766  780100     MOV W0, W2
000768  B3C3C1     MOV.B #0x3C, W1
00076A  B3C030     MOV.B #0x3, W0
00076C  07FEC7     RCALL lcd_set_com_seg
00076E  3700AA     BRA 0x8C4
98:                		case 26:	lcd_set_com_seg(2,60,show);	break;
000770  90403E     MOV.B [W14+3], W0
000772  FB8000     ZE W0, W0
000774  780100     MOV W0, W2
000776  B3C3C1     MOV.B #0x3C, W1
000778  B3C020     MOV.B #0x2, W0
00077A  07FEC0     RCALL lcd_set_com_seg
00077C  3700A3     BRA 0x8C4
99:                		case 27:	lcd_set_com_seg(1,60,show);	break;
00077E  90403E     MOV.B [W14+3], W0
000780  FB8000     ZE W0, W0
000782  780100     MOV W0, W2
000784  B3C3C1     MOV.B #0x3C, W1
000786  B3C010     MOV.B #0x1, W0
000788  07FEB9     RCALL lcd_set_com_seg
00078A  37009C     BRA 0x8C4
100:               		
101:               		case 28:	lcd_set_com_seg(0,60,show);	break;
00078C  90403E     MOV.B [W14+3], W0
00078E  FB8000     ZE W0, W0
000790  780100     MOV W0, W2
000792  B3C3C1     MOV.B #0x3C, W1
000794  EB4000     CLR.B W0
000796  07FEB2     RCALL lcd_set_com_seg
000798  370095     BRA 0x8C4
102:               		case 29:	lcd_set_com_seg(5,60,show);	break;		
00079A  90403E     MOV.B [W14+3], W0
00079C  FB8000     ZE W0, W0
00079E  780100     MOV W0, W2
0007A0  B3C3C1     MOV.B #0x3C, W1
0007A2  B3C050     MOV.B #0x5, W0
0007A4  07FEAB     RCALL lcd_set_com_seg
0007A6  37008E     BRA 0x8C4
103:               		case 30:	lcd_set_com_seg(6,60,show);	break;
0007A8  90403E     MOV.B [W14+3], W0
0007AA  FB8000     ZE W0, W0
0007AC  780100     MOV W0, W2
0007AE  B3C3C1     MOV.B #0x3C, W1
0007B0  B3C060     MOV.B #0x6, W0
0007B2  07FEA4     RCALL lcd_set_com_seg
0007B4  370087     BRA 0x8C4
104:               		case 31:	lcd_set_com_seg(7,60,show);	break;
0007B6  90403E     MOV.B [W14+3], W0
0007B8  FB8000     ZE W0, W0
0007BA  780100     MOV W0, W2
0007BC  B3C3C1     MOV.B #0x3C, W1
0007BE  B3C070     MOV.B #0x7, W0
0007C0  07FE9D     RCALL lcd_set_com_seg
0007C2  370080     BRA 0x8C4
105:               		
106:               		case 32:	lcd_set_com_seg(7,59,show);	break;
0007C4  90403E     MOV.B [W14+3], W0
0007C6  FB8000     ZE W0, W0
0007C8  780100     MOV W0, W2
0007CA  B3C3B1     MOV.B #0x3B, W1
0007CC  B3C070     MOV.B #0x7, W0
0007CE  07FE96     RCALL lcd_set_com_seg
0007D0  370079     BRA 0x8C4
107:               		case 33:	lcd_set_com_seg(6,59,show);	break;
0007D2  90403E     MOV.B [W14+3], W0
0007D4  FB8000     ZE W0, W0
0007D6  780100     MOV W0, W2
0007D8  B3C3B1     MOV.B #0x3B, W1
0007DA  B3C060     MOV.B #0x6, W0
0007DC  07FE8F     RCALL lcd_set_com_seg
0007DE  370072     BRA 0x8C4
108:               		case 34:	lcd_set_com_seg(5,59,show);	break;
0007E0  90403E     MOV.B [W14+3], W0
0007E2  FB8000     ZE W0, W0
0007E4  780100     MOV W0, W2
0007E6  B3C3B1     MOV.B #0x3B, W1
0007E8  B3C050     MOV.B #0x5, W0
0007EA  07FE88     RCALL lcd_set_com_seg
0007EC  37006B     BRA 0x8C4
109:               		case 35:	lcd_set_com_seg(0,59,show);	break;
0007EE  90403E     MOV.B [W14+3], W0
0007F0  FB8000     ZE W0, W0
0007F2  780100     MOV W0, W2
0007F4  B3C3B1     MOV.B #0x3B, W1
0007F6  EB4000     CLR.B W0
0007F8  07FE81     RCALL lcd_set_com_seg
0007FA  370064     BRA 0x8C4
110:               		
111:               		case 36:	lcd_set_com_seg(1,59,show);	break;
0007FC  90403E     MOV.B [W14+3], W0
0007FE  FB8000     ZE W0, W0
000800  780100     MOV W0, W2
000802  B3C3B1     MOV.B #0x3B, W1
000804  B3C010     MOV.B #0x1, W0
000806  07FE7A     RCALL lcd_set_com_seg
000808  37005D     BRA 0x8C4
112:               		case 37:	lcd_set_com_seg(2,59,show);	break;
00080A  90403E     MOV.B [W14+3], W0
00080C  FB8000     ZE W0, W0
00080E  780100     MOV W0, W2
000810  B3C3B1     MOV.B #0x3B, W1
000812  B3C020     MOV.B #0x2, W0
000814  07FE73     RCALL lcd_set_com_seg
000816  370056     BRA 0x8C4
113:               		case 38:	lcd_set_com_seg(3,59,show);	break;
000818  90403E     MOV.B [W14+3], W0
00081A  FB8000     ZE W0, W0
00081C  780100     MOV W0, W2
00081E  B3C3B1     MOV.B #0x3B, W1
000820  B3C030     MOV.B #0x3, W0
000822  07FE6C     RCALL lcd_set_com_seg
000824  37004F     BRA 0x8C4
114:               		case 39:	lcd_set_com_seg(4,59,show);	break;
000826  90403E     MOV.B [W14+3], W0
000828  FB8000     ZE W0, W0
00082A  780100     MOV W0, W2
00082C  B3C3B1     MOV.B #0x3B, W1
00082E  B3C040     MOV.B #0x4, W0
000830  07FE65     RCALL lcd_set_com_seg
000832  370048     BRA 0x8C4
115:               		
116:               		case 40:	lcd_set_com_seg(4,58,show);	break;
000834  90403E     MOV.B [W14+3], W0
000836  FB8000     ZE W0, W0
000838  780100     MOV W0, W2
00083A  B3C3A1     MOV.B #0x3A, W1
00083C  B3C040     MOV.B #0x4, W0
00083E  07FE5E     RCALL lcd_set_com_seg
000840  370041     BRA 0x8C4
117:               		case 41:	lcd_set_com_seg(3,58,show);	break;
000842  90403E     MOV.B [W14+3], W0
000844  FB8000     ZE W0, W0
000846  780100     MOV W0, W2
000848  B3C3A1     MOV.B #0x3A, W1
00084A  B3C030     MOV.B #0x3, W0
00084C  07FE57     RCALL lcd_set_com_seg
00084E  37003A     BRA 0x8C4
118:               		case 42:	lcd_set_com_seg(2,58,show);	break;
000850  90403E     MOV.B [W14+3], W0
000852  FB8000     ZE W0, W0
000854  780100     MOV W0, W2
000856  B3C3A1     MOV.B #0x3A, W1
000858  B3C020     MOV.B #0x2, W0
00085A  07FE50     RCALL lcd_set_com_seg
00085C  370033     BRA 0x8C4
119:               		case 43:	lcd_set_com_seg(1,58,show);	break;
00085E  90403E     MOV.B [W14+3], W0
000860  FB8000     ZE W0, W0
000862  780100     MOV W0, W2
000864  B3C3A1     MOV.B #0x3A, W1
000866  B3C010     MOV.B #0x1, W0
000868  07FE49     RCALL lcd_set_com_seg
00086A  37002C     BRA 0x8C4
120:               		
121:               		case 44:	lcd_set_com_seg(0,58,show);	break;
00086C  90403E     MOV.B [W14+3], W0
00086E  FB8000     ZE W0, W0
000870  780100     MOV W0, W2
000872  B3C3A1     MOV.B #0x3A, W1
000874  EB4000     CLR.B W0
000876  07FE42     RCALL lcd_set_com_seg
000878  370025     BRA 0x8C4
122:               		case 45:	lcd_set_com_seg(5,58,show);	break;
00087A  90403E     MOV.B [W14+3], W0
00087C  FB8000     ZE W0, W0
00087E  780100     MOV W0, W2
000880  B3C3A1     MOV.B #0x3A, W1
000882  B3C050     MOV.B #0x5, W0
000884  07FE3B     RCALL lcd_set_com_seg
000886  37001E     BRA 0x8C4
123:               		case 46:	lcd_set_com_seg(6,58,show);	break;
000888  90403E     MOV.B [W14+3], W0
00088A  FB8000     ZE W0, W0
00088C  780100     MOV W0, W2
00088E  B3C3A1     MOV.B #0x3A, W1
000890  B3C060     MOV.B #0x6, W0
000892  07FE34     RCALL lcd_set_com_seg
000894  370017     BRA 0x8C4
124:               		case 47:	lcd_set_com_seg(7,58,show);	break;
000896  90403E     MOV.B [W14+3], W0
000898  FB8000     ZE W0, W0
00089A  780100     MOV W0, W2
00089C  B3C3A1     MOV.B #0x3A, W1
00089E  B3C070     MOV.B #0x7, W0
0008A0  07FE2D     RCALL lcd_set_com_seg
0008A2  370010     BRA 0x8C4
125:               		
126:               		case 48:	lcd_set_com_seg(7,46,show);	break;
0008A4  90403E     MOV.B [W14+3], W0
0008A6  FB8000     ZE W0, W0
0008A8  780100     MOV W0, W2
0008AA  B3C2E1     MOV.B #0x2E, W1
0008AC  B3C070     MOV.B #0x7, W0
0008AE  07FE26     RCALL lcd_set_com_seg
0008B0  370009     BRA 0x8C4
127:               		case 49:	lcd_set_com_seg(6,46,show);	break;		
0008B2  90403E     MOV.B [W14+3], W0
0008B4  FB8000     ZE W0, W0
0008B6  780100     MOV W0, W2
0008B8  B3C2E1     MOV.B #0x2E, W1
0008BA  B3C060     MOV.B #0x6, W0
0008BC  07FE1F     RCALL lcd_set_com_seg
0008BE  000000     NOP
0008C0  370001     BRA 0x8C4
128:               	}
129:               }
0008C4  FA8000     ULNK
0008C6  060000     RETURN
130:               //@bierf scale:0~99
131:               void lcd_disp_level(uint8_t level)
132:               {
0008C8  FA0004     LNK #0x4
0008CA  984720     MOV.B W0, [W14+2]
133:               	uint8_t i;
134:               	if(level>=99)level=99;
0008CC  9040AE     MOV.B [W14+2], W1
0008CE  B3C620     MOV.B #0x62, W0
0008D0  50CF80     SUB.B W1, W0, [W15]
0008D2  360002     BRA LEU, 0x8D8
0008D4  B3C630     MOV.B #0x63, W0
0008D6  984720     MOV.B W0, [W14+2]
135:               	level/=2;
0008D8  90402E     MOV.B [W14+2], W0
0008DA  FB8000     ZE W0, W0
0008DC  D10000     LSR W0, W0
0008DE  984720     MOV.B W0, [W14+2]
136:               	for(i=0;i<level;i++){
0008E0  EB4000     CLR.B W0
0008E2  784F00     MOV.B W0, [W14]
0008E4  370004     BRA 0x8EE
0008EC  E84F1E     INC.B [W14], [W14]
0008EE  90402E     MOV.B [W14+2], W0
0008F0  78409E     MOV.B [W14], W1
0008F2  50CF80     SUB.B W1, W0, [W15]
0008F4  39FFF8     BRA NC, 0x8E6
137:               		lcd_disp_level_bar(i,1);
0008E6  B3C011     MOV.B #0x1, W1
0008E8  78401E     MOV.B [W14], W0
0008EA  07FE48     RCALL lcd_disp_level_bar
138:               	}
139:               	for(;i<50;i++){
0008F6  370004     BRA 0x900
0008FE  E84F1E     INC.B [W14], [W14]
000900  B3C310     MOV.B #0x31, W0
000902  78409E     MOV.B [W14], W1
000904  50CF80     SUB.B W1, W0, [W15]
000906  36FFF8     BRA LEU, 0x8F8
140:               		lcd_disp_level_bar(i,0);
0008F8  EB4080     CLR.B W1
0008FA  78401E     MOV.B [W14], W0
0008FC  07FE3F     RCALL lcd_disp_level_bar
141:               	}
142:               }
000908  FA8000     ULNK
00090A  060000     RETURN
143:               void lcd_disp_level_off(void)
144:               {
00090C  FA0002     LNK #0x2
145:               	uint8_t i;
146:               	for(i=0;i<50;i++){
00090E  EB4000     CLR.B W0
000910  784F00     MOV.B W0, [W14]
000912  370004     BRA 0x91C
00091A  E84F1E     INC.B [W14], [W14]
00091C  B3C310     MOV.B #0x31, W0
00091E  78409E     MOV.B [W14], W1
000920  50CF80     SUB.B W1, W0, [W15]
000922  36FFF8     BRA LEU, 0x914
147:               		lcd_disp_level_bar(i,0);
000914  EB4080     CLR.B W1
000916  78401E     MOV.B [W14], W0
000918  07FE31     RCALL lcd_disp_level_bar
148:               	}	
149:               }
000924  FA8000     ULNK
000926  060000     RETURN
150:               
151:               
152:               void lcd_disp_battary_bar(uint8_t bar,uint8_t show)
153:               {
000928  FA0002     LNK #0x2
00092A  784F00     MOV.B W0, [W14]
00092C  984711     MOV.B W1, [W14+1]
154:               	if(bar>=4)bar=4;
00092E  78401E     MOV.B [W14], W0
000930  504FE3     SUB.B W0, #0x3, [W15]
000932  360002     BRA LEU, 0x938
000934  B3C040     MOV.B #0x4, W0
000936  784F00     MOV.B W0, [W14]
155:               	switch(bar){
000938  FB801E     ZE [W14], W0
00093A  500FE1     SUB W0, #0x1, [W15]
00093C  32001F     BRA Z, 0x97C
00093E  500FE1     SUB W0, #0x1, [W15]
000940  3C0003     BRA GT, 0x948
000942  E00000     CP0 W0
000944  320006     BRA Z, 0x952
000946  370021     BRA 0x98A
000948  500FE2     SUB W0, #0x2, [W15]
00094A  320011     BRA Z, 0x96E
00094C  500FE3     SUB W0, #0x3, [W15]
00094E  320008     BRA Z, 0x960
000950  37001C     BRA 0x98A
156:               		case 0:	lcd_set_com_seg(3,50,show);	break;
000952  90401E     MOV.B [W14+1], W0
000954  FB8000     ZE W0, W0
000956  780100     MOV W0, W2
000958  B3C321     MOV.B #0x32, W1
00095A  B3C030     MOV.B #0x3, W0
00095C  07FDCF     RCALL lcd_set_com_seg
00095E  370015     BRA 0x98A
157:               		case 3:	lcd_set_com_seg(4,46,show);	break;
000960  90401E     MOV.B [W14+1], W0
000962  FB8000     ZE W0, W0
000964  780100     MOV W0, W2
000966  B3C2E1     MOV.B #0x2E, W1
000968  B3C040     MOV.B #0x4, W0
00096A  07FDC8     RCALL lcd_set_com_seg
00096C  37000E     BRA 0x98A
158:               		case 2:	lcd_set_com_seg(3,46,show);	break;
00096E  90401E     MOV.B [W14+1], W0
000970  FB8000     ZE W0, W0
000972  780100     MOV W0, W2
000974  B3C2E1     MOV.B #0x2E, W1
000976  B3C030     MOV.B #0x3, W0
000978  07FDC1     RCALL lcd_set_com_seg
00097A  370007     BRA 0x98A
159:               		case 1:	lcd_set_com_seg(4,50,show);	break;
00097C  90401E     MOV.B [W14+1], W0
00097E  FB8000     ZE W0, W0
000980  780100     MOV W0, W2
000982  B3C321     MOV.B #0x32, W1
000984  B3C040     MOV.B #0x4, W0
000986  07FDBA     RCALL lcd_set_com_seg
000988  000000     NOP
160:               	}
161:               }
00098A  FA8000     ULNK
00098C  060000     RETURN
162:               void lcd_disp_battary(uint8_t level)
163:               {
00098E  FA0004     LNK #0x4
000990  984720     MOV.B W0, [W14+2]
164:               	uint8_t i;
165:               	if(level>=100)level=100;
000992  9040AE     MOV.B [W14+2], W1
000994  B3C630     MOV.B #0x63, W0
000996  50CF80     SUB.B W1, W0, [W15]
000998  360002     BRA LEU, 0x99E
00099A  B3C640     MOV.B #0x64, W0
00099C  984720     MOV.B W0, [W14+2]
166:               	level/=25;
00099E  90402E     MOV.B [W14+2], W0
0009A0  FB8080     ZE W0, W1
0009A2  200190     MOV #0x19, W0
0009A4  780100     MOV W0, W2
0009A6  090011     REPEAT #0x11
0009A8  D88082     DIV.UW W1, W2
0009AA  984720     MOV.B W0, [W14+2]
167:               	if(level<1)level=1;
0009AC  90402E     MOV.B [W14+2], W0
0009AE  E00400     CP0.B W0
0009B0  3A0002     BRA NZ, 0x9B6
0009B2  B3C010     MOV.B #0x1, W0
0009B4  984720     MOV.B W0, [W14+2]
168:               	for(i=0;i<level;i++){
0009B6  EB4000     CLR.B W0
0009B8  784F00     MOV.B W0, [W14]
0009BA  370004     BRA 0x9C4
0009C2  E84F1E     INC.B [W14], [W14]
0009C4  90402E     MOV.B [W14+2], W0
0009C6  78409E     MOV.B [W14], W1
0009C8  50CF80     SUB.B W1, W0, [W15]
0009CA  39FFF8     BRA NC, 0x9BC
169:               		lcd_disp_battary_bar(i,1);
0009BC  B3C011     MOV.B #0x1, W1
0009BE  78401E     MOV.B [W14], W0
0009C0  07FFB3     RCALL lcd_disp_battary_bar
170:               	}
171:               	for(;i<4;i++){
0009CC  370004     BRA 0x9D6
0009D4  E84F1E     INC.B [W14], [W14]
0009D6  78401E     MOV.B [W14], W0
0009D8  504FE3     SUB.B W0, #0x3, [W15]
0009DA  36FFF9     BRA LEU, 0x9CE
172:               		lcd_disp_battary_bar(i,0);
0009CE  EB4080     CLR.B W1
0009D0  78401E     MOV.B [W14], W0
0009D2  07FFAA     RCALL lcd_disp_battary_bar
173:               	}
174:               }
0009DC  FA8000     ULNK
0009DE  060000     RETURN
175:               void lcd_disp_battary_off(void)
176:               {
0009E0  FA0002     LNK #0x2
177:               	uint8_t i;
178:               	for(i=0;i<4;i++){
0009E2  EB4000     CLR.B W0
0009E4  784F00     MOV.B W0, [W14]
0009E6  370004     BRA 0x9F0
0009EE  E84F1E     INC.B [W14], [W14]
0009F0  78401E     MOV.B [W14], W0
0009F2  504FE3     SUB.B W0, #0x3, [W15]
0009F4  36FFF9     BRA LEU, 0x9E8
179:               		lcd_disp_battary_bar(i,0);
0009E8  EB4080     CLR.B W1
0009EA  78401E     MOV.B [W14], W0
0009EC  07FF9D     RCALL lcd_disp_battary_bar
180:               	}
181:               }
0009F6  FA8000     ULNK
0009F8  060000     RETURN
182:               
183:               void lcd_disp_rf_bar(uint8_t bar,uint8_t show)
184:               {
0009FA  FA0002     LNK #0x2
0009FC  784F00     MOV.B W0, [W14]
0009FE  984711     MOV.B W1, [W14+1]
185:               	if(bar>=4)bar=4;
000A00  78401E     MOV.B [W14], W0
000A02  504FE3     SUB.B W0, #0x3, [W15]
000A04  360002     BRA LEU, 0xA0A
000A06  B3C040     MOV.B #0x4, W0
000A08  784F00     MOV.B W0, [W14]
186:               	switch(bar){
000A0A  FB801E     ZE [W14], W0
000A0C  500FE1     SUB W0, #0x1, [W15]
000A0E  320011     BRA Z, 0xA32
000A10  500FE1     SUB W0, #0x1, [W15]
000A12  3C0003     BRA GT, 0xA1A
000A14  E00000     CP0 W0
000A16  320006     BRA Z, 0xA24
000A18  370021     BRA 0xA5C
000A1A  500FE2     SUB W0, #0x2, [W15]
000A1C  320011     BRA Z, 0xA40
000A1E  500FE3     SUB W0, #0x3, [W15]
000A20  320016     BRA Z, 0xA4E
000A22  37001C     BRA 0xA5C
187:               		case 0:	lcd_set_com_seg(5,46,show);	break;
000A24  90401E     MOV.B [W14+1], W0
000A26  FB8000     ZE W0, W0
000A28  780100     MOV W0, W2
000A2A  B3C2E1     MOV.B #0x2E, W1
000A2C  B3C050     MOV.B #0x5, W0
000A2E  07FD66     RCALL lcd_set_com_seg
000A30  370015     BRA 0xA5C
188:               		case 1:	lcd_set_com_seg(0,46,show);	break;
000A32  90401E     MOV.B [W14+1], W0
000A34  FB8000     ZE W0, W0
000A36  780100     MOV W0, W2
000A38  B3C2E1     MOV.B #0x2E, W1
000A3A  EB4000     CLR.B W0
000A3C  07FD5F     RCALL lcd_set_com_seg
000A3E  37000E     BRA 0xA5C
189:               		case 2:	lcd_set_com_seg(1,46,show);	break;
000A40  90401E     MOV.B [W14+1], W0
000A42  FB8000     ZE W0, W0
000A44  780100     MOV W0, W2
000A46  B3C2E1     MOV.B #0x2E, W1
000A48  B3C010     MOV.B #0x1, W0
000A4A  07FD58     RCALL lcd_set_com_seg
000A4C  370007     BRA 0xA5C
190:               		case 3:	lcd_set_com_seg(0,47,show);	break;
000A4E  90401E     MOV.B [W14+1], W0
000A50  FB8000     ZE W0, W0
000A52  780100     MOV W0, W2
000A54  B3C2F1     MOV.B #0x2F, W1
000A56  EB4000     CLR.B W0
000A58  07FD51     RCALL lcd_set_com_seg
000A5A  000000     NOP
191:               	}	
192:               }
000A5C  FA8000     ULNK
000A5E  060000     RETURN
193:               void lcd_disp_rf(uint8_t rssi)
194:               {
000A60  FA0004     LNK #0x4
000A62  984720     MOV.B W0, [W14+2]
195:               	uint8_t i;
196:               	if(rssi>=100)rssi=100;
000A64  9040AE     MOV.B [W14+2], W1
000A66  B3C630     MOV.B #0x63, W0
000A68  50CF80     SUB.B W1, W0, [W15]
000A6A  360002     BRA LEU, 0xA70
000A6C  B3C640     MOV.B #0x64, W0
000A6E  984720     MOV.B W0, [W14+2]
197:               	rssi/=25;
000A70  90402E     MOV.B [W14+2], W0
000A72  FB8080     ZE W0, W1
000A74  200190     MOV #0x19, W0
000A76  780100     MOV W0, W2
000A78  090011     REPEAT #0x11
000A7A  D88082     DIV.UW W1, W2
000A7C  984720     MOV.B W0, [W14+2]
198:               	if(rssi<1)rssi=1;
000A7E  90402E     MOV.B [W14+2], W0
000A80  E00400     CP0.B W0
000A82  3A0002     BRA NZ, 0xA88
000A84  B3C010     MOV.B #0x1, W0
000A86  984720     MOV.B W0, [W14+2]
199:               	for(i=0;i<rssi;i++){
000A88  EB4000     CLR.B W0
000A8A  784F00     MOV.B W0, [W14]
000A8C  370004     BRA 0xA96
000A94  E84F1E     INC.B [W14], [W14]
000A96  90402E     MOV.B [W14+2], W0
000A98  78409E     MOV.B [W14], W1
000A9A  50CF80     SUB.B W1, W0, [W15]
000A9C  39FFF8     BRA NC, 0xA8E
200:               		lcd_disp_rf_bar(i,1);
000A8E  B3C011     MOV.B #0x1, W1
000A90  78401E     MOV.B [W14], W0
000A92  07FFB3     RCALL lcd_disp_rf_bar
201:               	}
202:               	for(;i<4;i++){
000A9E  370004     BRA 0xAA8
000AA6  E84F1E     INC.B [W14], [W14]
000AA8  78401E     MOV.B [W14], W0
000AAA  504FE3     SUB.B W0, #0x3, [W15]
000AAC  36FFF9     BRA LEU, 0xAA0
203:               		lcd_disp_rf_bar(i,0);
000AA0  EB4080     CLR.B W1
000AA2  78401E     MOV.B [W14], W0
000AA4  07FFAA     RCALL lcd_disp_rf_bar
204:               	}
205:               }
000AAE  FA8000     ULNK
000AB0  060000     RETURN
206:               void lcd_disp_rf_off(void)
207:               {
000AB2  FA0002     LNK #0x2
208:               	uint8_t i;
209:               	for(i=0;i<4;i++){
000AB4  EB4000     CLR.B W0
000AB6  784F00     MOV.B W0, [W14]
000AB8  370004     BRA 0xAC2
000AC0  E84F1E     INC.B [W14], [W14]
000AC2  78401E     MOV.B [W14], W0
000AC4  504FE3     SUB.B W0, #0x3, [W15]
000AC6  36FFF9     BRA LEU, 0xABA
210:               		lcd_disp_rf_bar(i,0);
000ABA  EB4080     CLR.B W1
000ABC  78401E     MOV.B [W14], W0
000ABE  07FF9D     RCALL lcd_disp_rf_bar
211:               	}
212:               }
000AC8  FA8000     ULNK
000ACA  060000     RETURN
213:               
214:               void lcd_disp_light_bar(uint8_t bar,uint8_t show)
215:               {
000ACC  FA0002     LNK #0x2
000ACE  784F00     MOV.B W0, [W14]
000AD0  984711     MOV.B W1, [W14+1]
216:               	if(bar>=1)bar=1;
000AD2  78401E     MOV.B [W14], W0
000AD4  E00400     CP0.B W0
000AD6  320002     BRA Z, 0xADC
000AD8  B3C010     MOV.B #0x1, W0
000ADA  784F00     MOV.B W0, [W14]
217:               	switch(bar){
000ADC  FB801E     ZE [W14], W0
000ADE  E00000     CP0 W0
000AE0  320009     BRA Z, 0xAF4
000AE2  500FE1     SUB W0, #0x1, [W15]
000AE4  3A000E     BRA NZ, 0xB02
218:               		case 1:	lcd_set_com_seg(2,46,show);	break;
000AE6  90401E     MOV.B [W14+1], W0
000AE8  FB8000     ZE W0, W0
000AEA  780100     MOV W0, W2
000AEC  B3C2E1     MOV.B #0x2E, W1
000AEE  B3C020     MOV.B #0x2, W0
000AF0  07FD05     RCALL lcd_set_com_seg
000AF2  370007     BRA 0xB02
219:               		case 0:	lcd_set_com_seg(2,50,show);	break;
000AF4  90401E     MOV.B [W14+1], W0
000AF6  FB8000     ZE W0, W0
000AF8  780100     MOV W0, W2
000AFA  B3C321     MOV.B #0x32, W1
000AFC  B3C020     MOV.B #0x2, W0
000AFE  07FCFE     RCALL lcd_set_com_seg
000B00  000000     NOP
220:               	}	
221:               }
000B02  FA8000     ULNK
000B04  060000     RETURN
222:               void lcd_disp_light(uint8_t light)
223:               {
000B06  FA0002     LNK #0x2
000B08  784F00     MOV.B W0, [W14]
224:               	if(light>=100)light=100;
000B0A  B3C630     MOV.B #0x63, W0
000B0C  78409E     MOV.B [W14], W1
000B0E  50CF80     SUB.B W1, W0, [W15]
000B10  360002     BRA LEU, 0xB16
000B12  B3C640     MOV.B #0x64, W0
000B14  784F00     MOV.B W0, [W14]
225:               	light/=50;
000B16  FB809E     ZE [W14], W1
000B18  200320     MOV #0x32, W0
000B1A  780100     MOV W0, W2
000B1C  090011     REPEAT #0x11
000B1E  D88082     DIV.UW W1, W2
000B20  784F00     MOV.B W0, [W14]
226:               	if(light<1)light=1;
000B22  78401E     MOV.B [W14], W0
000B24  E00400     CP0.B W0
000B26  3A0002     BRA NZ, 0xB2C
000B28  B3C010     MOV.B #0x1, W0
000B2A  784F00     MOV.B W0, [W14]
227:               	if(2==light){
000B2C  78401E     MOV.B [W14], W0
000B2E  504FE2     SUB.B W0, #0x2, [W15]
000B30  3A0007     BRA NZ, 0xB40
228:               		lcd_disp_light_bar(0,1);
000B32  B3C011     MOV.B #0x1, W1
000B34  EB4000     CLR.B W0
000B36  07FFCA     RCALL lcd_disp_light_bar
229:               		lcd_disp_light_bar(1,1);
000B38  B3C011     MOV.B #0x1, W1
000B3A  B3C010     MOV.B #0x1, W0
000B3C  07FFC7     RCALL lcd_disp_light_bar
000B3E  370003     BRA 0xB46
230:               	}else{
231:               		lcd_disp_light_bar(0,1);
000B40  B3C011     MOV.B #0x1, W1
000B42  EB4000     CLR.B W0
000B44  07FFC3     RCALL lcd_disp_light_bar
232:               	}
233:               }
000B46  FA8000     ULNK
000B48  060000     RETURN
234:               void lcd_disp_light_off(void)
235:               {
000B4A  FA0000     LNK #0x0
236:               	lcd_disp_light_bar(0,0);
000B4C  EB4080     CLR.B W1
000B4E  EB4000     CLR.B W0
000B50  07FFBD     RCALL lcd_disp_light_bar
237:               	lcd_disp_light_bar(1,0);
000B52  EB4080     CLR.B W1
000B54  B3C010     MOV.B #0x1, W0
000B56  07FFBA     RCALL lcd_disp_light_bar
238:               }
000B58  FA8000     ULNK
000B5A  060000     RETURN
239:               
240:               //show dig.
241:               void lcd_disp_chr_loc_0(uint8_t code)
242:               {
000B5C  FA0002     LNK #0x2
000B5E  784F00     MOV.B W0, [W14]
243:               	lcd_set_com_seg(7,41,code&LCD_DSEG_A);
000B60  FB801E     ZE [W14], W0
000B62  600061     AND W0, #0x1, W0
000B64  780100     MOV W0, W2
000B66  B3C291     MOV.B #0x29, W1
000B68  B3C070     MOV.B #0x7, W0
000B6A  07FCC8     RCALL lcd_set_com_seg
244:               	lcd_set_com_seg(6,41,code&LCD_DSEG_B);
000B6C  FB801E     ZE [W14], W0
000B6E  600062     AND W0, #0x2, W0
000B70  780100     MOV W0, W2
000B72  B3C291     MOV.B #0x29, W1
000B74  B3C060     MOV.B #0x6, W0
000B76  07FCC2     RCALL lcd_set_com_seg
245:                   lcd_set_com_seg(5,41,code&LCD_DSEG_C);
000B78  FB801E     ZE [W14], W0
000B7A  600064     AND W0, #0x4, W0
000B7C  780100     MOV W0, W2
000B7E  B3C291     MOV.B #0x29, W1
000B80  B3C050     MOV.B #0x5, W0
000B82  07FCBC     RCALL lcd_set_com_seg
246:                   lcd_set_com_seg(0,41,code&LCD_DSEG_D);
000B84  FB801E     ZE [W14], W0
000B86  600068     AND W0, #0x8, W0
000B88  780100     MOV W0, W2
000B8A  B3C291     MOV.B #0x29, W1
000B8C  EB4000     CLR.B W0
000B8E  07FCB6     RCALL lcd_set_com_seg
247:                   
248:                   lcd_set_com_seg(7,47,code&LCD_DSEG_F);
000B90  FB809E     ZE [W14], W1
000B92  200200     MOV #0x20, W0
000B94  608000     AND W1, W0, W0
000B96  780100     MOV W0, W2
000B98  B3C2F1     MOV.B #0x2F, W1
000B9A  B3C070     MOV.B #0x7, W0
000B9C  07FCAF     RCALL lcd_set_com_seg
249:                   lcd_set_com_seg(6,47,code&LCD_DSEG_G);
000B9E  FB809E     ZE [W14], W1
000BA0  200400     MOV #0x40, W0
000BA2  608000     AND W1, W0, W0
000BA4  780100     MOV W0, W2
000BA6  B3C2F1     MOV.B #0x2F, W1
000BA8  B3C060     MOV.B #0x6, W0
000BAA  07FCA8     RCALL lcd_set_com_seg
250:                   lcd_set_com_seg(5,47,code&LCD_DSEG_E);
000BAC  FB801E     ZE [W14], W0
000BAE  600070     AND W0, #0x10, W0
000BB0  780100     MOV W0, W2
000BB2  B3C2F1     MOV.B #0x2F, W1
000BB4  B3C050     MOV.B #0x5, W0
000BB6  07FCA2     RCALL lcd_set_com_seg
251:                   //lcd_disp_com_seg(3,00,code&LCD_DSEG_DP);
252:               }
000BB8  FA8000     ULNK
000BBA  060000     RETURN
253:               void lcd_disp_dp_loc_0(bool dp)
254:               {
000BBC  FA0002     LNK #0x2
000BBE  784F00     MOV.B W0, [W14]
255:               	if(dp)
000BC0  78401E     MOV.B [W14], W0
000BC2  E00400     CP0.B W0
000BC4  320005     BRA Z, 0xBD0
256:               		lcd_set_com_seg(0,40,LCD_DSEG_DP);
000BC6  200802     MOV #0x80, W2
000BC8  B3C281     MOV.B #0x28, W1
000BCA  EB4000     CLR.B W0
000BCC  07FC97     RCALL lcd_set_com_seg
000BCE  370004     BRA 0xBD8
257:               	else 
258:               		lcd_set_com_seg(0,40,0);
000BD0  EB0100     CLR W2
000BD2  B3C281     MOV.B #0x28, W1
000BD4  EB4000     CLR.B W0
000BD6  07FC92     RCALL lcd_set_com_seg
259:               }
000BD8  FA8000     ULNK
000BDA  060000     RETURN
260:               
261:               void lcd_disp_chr_loc_1(uint8_t code)
262:               {
000BDC  FA0002     LNK #0x2
000BDE  784F00     MOV.B W0, [W14]
263:               	lcd_set_com_seg(7,12,code&LCD_DSEG_A);
000BE0  FB801E     ZE [W14], W0
000BE2  600061     AND W0, #0x1, W0
000BE4  780100     MOV W0, W2
000BE6  B3C0C1     MOV.B #0xC, W1
000BE8  B3C070     MOV.B #0x7, W0
000BEA  07FC88     RCALL lcd_set_com_seg
264:               	lcd_set_com_seg(6,12,code&LCD_DSEG_B);
000BEC  FB801E     ZE [W14], W0
000BEE  600062     AND W0, #0x2, W0
000BF0  780100     MOV W0, W2
000BF2  B3C0C1     MOV.B #0xC, W1
000BF4  B3C060     MOV.B #0x6, W0
000BF6  07FC82     RCALL lcd_set_com_seg
265:                   lcd_set_com_seg(5,12,code&LCD_DSEG_C);
000BF8  FB801E     ZE [W14], W0
000BFA  600064     AND W0, #0x4, W0
000BFC  780100     MOV W0, W2
000BFE  B3C0C1     MOV.B #0xC, W1
000C00  B3C050     MOV.B #0x5, W0
000C02  07FC7C     RCALL lcd_set_com_seg
266:                   lcd_set_com_seg(0,12,code&LCD_DSEG_D);
000C04  FB801E     ZE [W14], W0
000C06  600068     AND W0, #0x8, W0
000C08  780100     MOV W0, W2
000C0A  B3C0C1     MOV.B #0xC, W1
000C0C  EB4000     CLR.B W0
000C0E  07FC76     RCALL lcd_set_com_seg
267:                   
268:                   lcd_set_com_seg(7,40,code&LCD_DSEG_F);
000C10  FB809E     ZE [W14], W1
000C12  200200     MOV #0x20, W0
000C14  608000     AND W1, W0, W0
000C16  780100     MOV W0, W2
000C18  B3C281     MOV.B #0x28, W1
000C1A  B3C070     MOV.B #0x7, W0
000C1C  07FC6F     RCALL lcd_set_com_seg
269:                   lcd_set_com_seg(6,40,code&LCD_DSEG_G);
000C1E  FB809E     ZE [W14], W1
000C20  200400     MOV #0x40, W0
000C22  608000     AND W1, W0, W0
000C24  780100     MOV W0, W2
000C26  B3C281     MOV.B #0x28, W1
000C28  B3C060     MOV.B #0x6, W0
000C2A  07FC68     RCALL lcd_set_com_seg
270:                   lcd_set_com_seg(5,40,code&LCD_DSEG_E);
000C2C  FB801E     ZE [W14], W0
000C2E  600070     AND W0, #0x10, W0
000C30  780100     MOV W0, W2
000C32  B3C281     MOV.B #0x28, W1
000C34  B3C050     MOV.B #0x5, W0
000C36  07FC62     RCALL lcd_set_com_seg
271:               }
000C38  FA8000     ULNK
000C3A  060000     RETURN
272:               void lcd_disp_dp_loc_1(bool dp)
273:               {
000C3C  FA0002     LNK #0x2
000C3E  784F00     MOV.B W0, [W14]
274:               	if(dp)
000C40  78401E     MOV.B [W14], W0
000C42  E00400     CP0.B W0
000C44  320005     BRA Z, 0xC50
275:               		lcd_set_com_seg(0,11,LCD_DSEG_DP);
000C46  200802     MOV #0x80, W2
000C48  B3C0B1     MOV.B #0xB, W1
000C4A  EB4000     CLR.B W0
000C4C  07FC57     RCALL lcd_set_com_seg
000C4E  370004     BRA 0xC58
276:               	else 
277:               		lcd_set_com_seg(0,11,0);
000C50  EB0100     CLR W2
000C52  B3C0B1     MOV.B #0xB, W1
000C54  EB4000     CLR.B W0
000C56  07FC52     RCALL lcd_set_com_seg
278:               }
000C58  FA8000     ULNK
000C5A  060000     RETURN
279:               
280:               void lcd_disp_chr_loc_2(uint8_t code)
281:               {
000C5C  FA0002     LNK #0x2
000C5E  784F00     MOV.B W0, [W14]
282:               	lcd_set_com_seg(7,10,code&LCD_DSEG_A);
000C60  FB801E     ZE [W14], W0
000C62  600061     AND W0, #0x1, W0
000C64  780100     MOV W0, W2
000C66  B3C0A1     MOV.B #0xA, W1
000C68  B3C070     MOV.B #0x7, W0
000C6A  07FC48     RCALL lcd_set_com_seg
283:               	lcd_set_com_seg(6,10,code&LCD_DSEG_B);
000C6C  FB801E     ZE [W14], W0
000C6E  600062     AND W0, #0x2, W0
000C70  780100     MOV W0, W2
000C72  B3C0A1     MOV.B #0xA, W1
000C74  B3C060     MOV.B #0x6, W0
000C76  07FC42     RCALL lcd_set_com_seg
284:                   lcd_set_com_seg(5,10,code&LCD_DSEG_C);
000C78  FB801E     ZE [W14], W0
000C7A  600064     AND W0, #0x4, W0
000C7C  780100     MOV W0, W2
000C7E  B3C0A1     MOV.B #0xA, W1
000C80  B3C050     MOV.B #0x5, W0
000C82  07FC3C     RCALL lcd_set_com_seg
285:                   lcd_set_com_seg(0,10,code&LCD_DSEG_D);
000C84  FB801E     ZE [W14], W0
000C86  600068     AND W0, #0x8, W0
000C88  780100     MOV W0, W2
000C8A  B3C0A1     MOV.B #0xA, W1
000C8C  EB4000     CLR.B W0
000C8E  07FC36     RCALL lcd_set_com_seg
286:                   
287:                   lcd_set_com_seg(7,11,code&LCD_DSEG_F);
000C90  FB809E     ZE [W14], W1
000C92  200200     MOV #0x20, W0
000C94  608000     AND W1, W0, W0
000C96  780100     MOV W0, W2
000C98  B3C0B1     MOV.B #0xB, W1
000C9A  B3C070     MOV.B #0x7, W0
000C9C  07FC2F     RCALL lcd_set_com_seg
288:                   lcd_set_com_seg(6,11,code&LCD_DSEG_G);
000C9E  FB809E     ZE [W14], W1
000CA0  200400     MOV #0x40, W0
000CA2  608000     AND W1, W0, W0
000CA4  780100     MOV W0, W2
000CA6  B3C0B1     MOV.B #0xB, W1
000CA8  B3C060     MOV.B #0x6, W0
000CAA  07FC28     RCALL lcd_set_com_seg
289:                   lcd_set_com_seg(5,11,code&LCD_DSEG_E);
000CAC  FB801E     ZE [W14], W0
000CAE  600070     AND W0, #0x10, W0
000CB0  780100     MOV W0, W2
000CB2  B3C0B1     MOV.B #0xB, W1
000CB4  B3C050     MOV.B #0x5, W0
000CB6  07FC22     RCALL lcd_set_com_seg
290:               }
000CB8  FA8000     ULNK
000CBA  060000     RETURN
291:               void lcd_disp_dp_loc_2(bool dp)
292:               {
000CBC  FA0002     LNK #0x2
000CBE  784F00     MOV.B W0, [W14]
293:               	if(dp)
000CC0  78401E     MOV.B [W14], W0
000CC2  E00400     CP0.B W0
000CC4  320005     BRA Z, 0xCD0
294:               		lcd_set_com_seg(0,39,LCD_DSEG_DP);
000CC6  200802     MOV #0x80, W2
000CC8  B3C271     MOV.B #0x27, W1
000CCA  EB4000     CLR.B W0
000CCC  07FC17     RCALL lcd_set_com_seg
000CCE  370004     BRA 0xCD8
295:               	else 
296:               		lcd_set_com_seg(0,39,0);
000CD0  EB0100     CLR W2
000CD2  B3C271     MOV.B #0x27, W1
000CD4  EB4000     CLR.B W0
000CD6  07FC12     RCALL lcd_set_com_seg
297:               }
000CD8  FA8000     ULNK
000CDA  060000     RETURN
298:               
299:               void lcd_disp_chr_loc_3(uint8_t code)
300:               {
000CDC  FA0002     LNK #0x2
000CDE  784F00     MOV.B W0, [W14]
301:               	lcd_set_com_seg(7,38,code&LCD_DSEG_A);
000CE0  FB801E     ZE [W14], W0
000CE2  600061     AND W0, #0x1, W0
000CE4  780100     MOV W0, W2
000CE6  B3C261     MOV.B #0x26, W1
000CE8  B3C070     MOV.B #0x7, W0
000CEA  07FC08     RCALL lcd_set_com_seg
302:               	lcd_set_com_seg(6,38,code&LCD_DSEG_B);
000CEC  FB801E     ZE [W14], W0
000CEE  600062     AND W0, #0x2, W0
000CF0  780100     MOV W0, W2
000CF2  B3C261     MOV.B #0x26, W1
000CF4  B3C060     MOV.B #0x6, W0
000CF6  07FC02     RCALL lcd_set_com_seg
303:                   lcd_set_com_seg(5,38,code&LCD_DSEG_C);
000CF8  FB801E     ZE [W14], W0
000CFA  600064     AND W0, #0x4, W0
000CFC  780100     MOV W0, W2
000CFE  B3C261     MOV.B #0x26, W1
000D00  B3C050     MOV.B #0x5, W0
000D02  07FBFC     RCALL lcd_set_com_seg
304:                   lcd_set_com_seg(0,38,code&LCD_DSEG_D);
000D04  FB801E     ZE [W14], W0
000D06  600068     AND W0, #0x8, W0
000D08  780100     MOV W0, W2
000D0A  B3C261     MOV.B #0x26, W1
000D0C  EB4000     CLR.B W0
000D0E  07FBF6     RCALL lcd_set_com_seg
305:                   
306:                   lcd_set_com_seg(7,39,code&LCD_DSEG_F);
000D10  FB809E     ZE [W14], W1
000D12  200200     MOV #0x20, W0
000D14  608000     AND W1, W0, W0
000D16  780100     MOV W0, W2
000D18  B3C271     MOV.B #0x27, W1
000D1A  B3C070     MOV.B #0x7, W0
000D1C  07FBEF     RCALL lcd_set_com_seg
307:                   lcd_set_com_seg(6,39,code&LCD_DSEG_G);
000D1E  FB809E     ZE [W14], W1
000D20  200400     MOV #0x40, W0
000D22  608000     AND W1, W0, W0
000D24  780100     MOV W0, W2
000D26  B3C271     MOV.B #0x27, W1
000D28  B3C060     MOV.B #0x6, W0
000D2A  07FBE8     RCALL lcd_set_com_seg
308:                   lcd_set_com_seg(5,39,code&LCD_DSEG_E);
000D2C  FB801E     ZE [W14], W0
000D2E  600070     AND W0, #0x10, W0
000D30  780100     MOV W0, W2
000D32  B3C271     MOV.B #0x27, W1
000D34  B3C050     MOV.B #0x5, W0
000D36  07FBE2     RCALL lcd_set_com_seg
309:               }
000D38  FA8000     ULNK
000D3A  060000     RETURN
310:               
311:               void lcd_disp_chr_loc_4(uint8_t code)
312:               {
000D3C  FA0002     LNK #0x2
000D3E  784F00     MOV.B W0, [W14]
313:               	lcd_set_com_seg(1,41,code&LCD_DSEG_A);
000D40  FB801E     ZE [W14], W0
000D42  600061     AND W0, #0x1, W0
000D44  780100     MOV W0, W2
000D46  B3C291     MOV.B #0x29, W1
000D48  B3C010     MOV.B #0x1, W0
000D4A  07FBD8     RCALL lcd_set_com_seg
314:               	lcd_set_com_seg(2,41,code&LCD_DSEG_B);
000D4C  FB801E     ZE [W14], W0
000D4E  600062     AND W0, #0x2, W0
000D50  780100     MOV W0, W2
000D52  B3C291     MOV.B #0x29, W1
000D54  B3C020     MOV.B #0x2, W0
000D56  07FBD2     RCALL lcd_set_com_seg
315:                   lcd_set_com_seg(3,41,code&LCD_DSEG_C);
000D58  FB801E     ZE [W14], W0
000D5A  600064     AND W0, #0x4, W0
000D5C  780100     MOV W0, W2
000D5E  B3C291     MOV.B #0x29, W1
000D60  B3C030     MOV.B #0x3, W0
000D62  07FBCC     RCALL lcd_set_com_seg
316:                   lcd_set_com_seg(4,41,code&LCD_DSEG_D);
000D64  FB801E     ZE [W14], W0
000D66  600068     AND W0, #0x8, W0
000D68  780100     MOV W0, W2
000D6A  B3C291     MOV.B #0x29, W1
000D6C  B3C040     MOV.B #0x4, W0
000D6E  07FBC6     RCALL lcd_set_com_seg
317:                   
318:                   lcd_set_com_seg(1,47,code&LCD_DSEG_F);
000D70  FB809E     ZE [W14], W1
000D72  200200     MOV #0x20, W0
000D74  608000     AND W1, W0, W0
000D76  780100     MOV W0, W2
000D78  B3C2F1     MOV.B #0x2F, W1
000D7A  B3C010     MOV.B #0x1, W0
000D7C  07FBBF     RCALL lcd_set_com_seg
319:                   lcd_set_com_seg(2,47,code&LCD_DSEG_G);
000D7E  FB809E     ZE [W14], W1
000D80  200400     MOV #0x40, W0
000D82  608000     AND W1, W0, W0
000D84  780100     MOV W0, W2
000D86  B3C2F1     MOV.B #0x2F, W1
000D88  B3C020     MOV.B #0x2, W0
000D8A  07FBB8     RCALL lcd_set_com_seg
320:                   lcd_set_com_seg(3,47,code&LCD_DSEG_E);
000D8C  FB801E     ZE [W14], W0
000D8E  600070     AND W0, #0x10, W0
000D90  780100     MOV W0, W2
000D92  B3C2F1     MOV.B #0x2F, W1
000D94  B3C030     MOV.B #0x3, W0
000D96  07FBB2     RCALL lcd_set_com_seg
321:               }
000D98  FA8000     ULNK
000D9A  060000     RETURN
322:               void lcd_disp_dp_loc_4(bool dp)
323:               {
000D9C  FA0002     LNK #0x2
000D9E  784F00     MOV.B W0, [W14]
324:               	if(dp)
000DA0  78401E     MOV.B [W14], W0
000DA2  E00400     CP0.B W0
000DA4  320005     BRA Z, 0xDB0
325:               		lcd_set_com_seg(4,40,LCD_DSEG_DP);
000DA6  200802     MOV #0x80, W2
000DA8  B3C281     MOV.B #0x28, W1
000DAA  B3C040     MOV.B #0x4, W0
000DAC  07FBA7     RCALL lcd_set_com_seg
000DAE  370004     BRA 0xDB8
326:               	else 
327:               		lcd_set_com_seg(4,40,0);
000DB0  EB0100     CLR W2
000DB2  B3C281     MOV.B #0x28, W1
000DB4  B3C040     MOV.B #0x4, W0
000DB6  07FBA2     RCALL lcd_set_com_seg
328:               }
000DB8  FA8000     ULNK
000DBA  060000     RETURN
329:               
330:               void lcd_disp_chr_loc_5(uint8_t code)
331:               {
000DBC  FA0002     LNK #0x2
000DBE  784F00     MOV.B W0, [W14]
332:               	lcd_set_com_seg(1,12,code&LCD_DSEG_A);
000DC0  FB801E     ZE [W14], W0
000DC2  600061     AND W0, #0x1, W0
000DC4  780100     MOV W0, W2
000DC6  B3C0C1     MOV.B #0xC, W1
000DC8  B3C010     MOV.B #0x1, W0
000DCA  07FB98     RCALL lcd_set_com_seg
333:               	lcd_set_com_seg(2,12,code&LCD_DSEG_B);
000DCC  FB801E     ZE [W14], W0
000DCE  600062     AND W0, #0x2, W0
000DD0  780100     MOV W0, W2
000DD2  B3C0C1     MOV.B #0xC, W1
000DD4  B3C020     MOV.B #0x2, W0
000DD6  07FB92     RCALL lcd_set_com_seg
334:                   lcd_set_com_seg(3,12,code&LCD_DSEG_C);
000DD8  FB801E     ZE [W14], W0
000DDA  600064     AND W0, #0x4, W0
000DDC  780100     MOV W0, W2
000DDE  B3C0C1     MOV.B #0xC, W1
000DE0  B3C030     MOV.B #0x3, W0
000DE2  07FB8C     RCALL lcd_set_com_seg
335:                   lcd_set_com_seg(4,12,code&LCD_DSEG_D);
000DE4  FB801E     ZE [W14], W0
000DE6  600068     AND W0, #0x8, W0
000DE8  780100     MOV W0, W2
000DEA  B3C0C1     MOV.B #0xC, W1
000DEC  B3C040     MOV.B #0x4, W0
000DEE  07FB86     RCALL lcd_set_com_seg
336:                   
337:                   lcd_set_com_seg(1,40,code&LCD_DSEG_F);
000DF0  FB809E     ZE [W14], W1
000DF2  200200     MOV #0x20, W0
000DF4  608000     AND W1, W0, W0
000DF6  780100     MOV W0, W2
000DF8  B3C281     MOV.B #0x28, W1
000DFA  B3C010     MOV.B #0x1, W0
000DFC  07FB7F     RCALL lcd_set_com_seg
338:                   lcd_set_com_seg(2,40,code&LCD_DSEG_G);
000DFE  FB809E     ZE [W14], W1
000E00  200400     MOV #0x40, W0
000E02  608000     AND W1, W0, W0
000E04  780100     MOV W0, W2
000E06  B3C281     MOV.B #0x28, W1
000E08  B3C020     MOV.B #0x2, W0
000E0A  07FB78     RCALL lcd_set_com_seg
339:                   lcd_set_com_seg(3,40,code&LCD_DSEG_E);
000E0C  FB801E     ZE [W14], W0
000E0E  600070     AND W0, #0x10, W0
000E10  780100     MOV W0, W2
000E12  B3C281     MOV.B #0x28, W1
000E14  B3C030     MOV.B #0x3, W0
000E16  07FB72     RCALL lcd_set_com_seg
340:               }
000E18  FA8000     ULNK
000E1A  060000     RETURN
341:               void lcd_disp_dp_loc_5(bool dp)
342:               {
000E1C  FA0002     LNK #0x2
000E1E  784F00     MOV.B W0, [W14]
343:               	if(dp)
000E20  78401E     MOV.B [W14], W0
000E22  E00400     CP0.B W0
000E24  320005     BRA Z, 0xE30
344:               		lcd_set_com_seg(4,11,LCD_DSEG_DP);
000E26  200802     MOV #0x80, W2
000E28  B3C0B1     MOV.B #0xB, W1
000E2A  B3C040     MOV.B #0x4, W0
000E2C  07FB67     RCALL lcd_set_com_seg
000E2E  370004     BRA 0xE38
345:               	else 
346:               		lcd_set_com_seg(4,11,0);
000E30  EB0100     CLR W2
000E32  B3C0B1     MOV.B #0xB, W1
000E34  B3C040     MOV.B #0x4, W0
000E36  07FB62     RCALL lcd_set_com_seg
347:               }
000E38  FA8000     ULNK
000E3A  060000     RETURN
348:               
349:               void lcd_disp_chr_loc_6(uint8_t code)
350:               {
000E3C  FA0002     LNK #0x2
000E3E  784F00     MOV.B W0, [W14]
351:               	lcd_set_com_seg(1,10,code&LCD_DSEG_A);
000E40  FB801E     ZE [W14], W0
000E42  600061     AND W0, #0x1, W0
000E44  780100     MOV W0, W2
000E46  B3C0A1     MOV.B #0xA, W1
000E48  B3C010     MOV.B #0x1, W0
000E4A  07FB58     RCALL lcd_set_com_seg
352:               	lcd_set_com_seg(2,10,code&LCD_DSEG_B);
000E4C  FB801E     ZE [W14], W0
000E4E  600062     AND W0, #0x2, W0
000E50  780100     MOV W0, W2
000E52  B3C0A1     MOV.B #0xA, W1
000E54  B3C020     MOV.B #0x2, W0
000E56  07FB52     RCALL lcd_set_com_seg
353:                   lcd_set_com_seg(3,10,code&LCD_DSEG_C);
000E58  FB801E     ZE [W14], W0
000E5A  600064     AND W0, #0x4, W0
000E5C  780100     MOV W0, W2
000E5E  B3C0A1     MOV.B #0xA, W1
000E60  B3C030     MOV.B #0x3, W0
000E62  07FB4C     RCALL lcd_set_com_seg
354:                   lcd_set_com_seg(4,10,code&LCD_DSEG_D);
000E64  FB801E     ZE [W14], W0
000E66  600068     AND W0, #0x8, W0
000E68  780100     MOV W0, W2
000E6A  B3C0A1     MOV.B #0xA, W1
000E6C  B3C040     MOV.B #0x4, W0
000E6E  07FB46     RCALL lcd_set_com_seg
355:                   
356:                   lcd_set_com_seg(1,11,code&LCD_DSEG_F);
000E70  FB809E     ZE [W14], W1
000E72  200200     MOV #0x20, W0
000E74  608000     AND W1, W0, W0
000E76  780100     MOV W0, W2
000E78  B3C0B1     MOV.B #0xB, W1
000E7A  B3C010     MOV.B #0x1, W0
000E7C  07FB3F     RCALL lcd_set_com_seg
357:                   lcd_set_com_seg(2,11,code&LCD_DSEG_G);
000E7E  FB809E     ZE [W14], W1
000E80  200400     MOV #0x40, W0
000E82  608000     AND W1, W0, W0
000E84  780100     MOV W0, W2
000E86  B3C0B1     MOV.B #0xB, W1
000E88  B3C020     MOV.B #0x2, W0
000E8A  07FB38     RCALL lcd_set_com_seg
358:                   lcd_set_com_seg(3,11,code&LCD_DSEG_E);
000E8C  FB801E     ZE [W14], W0
000E8E  600070     AND W0, #0x10, W0
000E90  780100     MOV W0, W2
000E92  B3C0B1     MOV.B #0xB, W1
000E94  B3C030     MOV.B #0x3, W0
000E96  07FB32     RCALL lcd_set_com_seg
359:               }
000E98  FA8000     ULNK
000E9A  060000     RETURN
360:               void lcd_disp_dp_loc_6(bool dp)
361:               {
000E9C  FA0002     LNK #0x2
000E9E  784F00     MOV.B W0, [W14]
362:               	if(dp)
000EA0  78401E     MOV.B [W14], W0
000EA2  E00400     CP0.B W0
000EA4  320005     BRA Z, 0xEB0
363:               		lcd_set_com_seg(4,39,LCD_DSEG_DP);
000EA6  200802     MOV #0x80, W2
000EA8  B3C271     MOV.B #0x27, W1
000EAA  B3C040     MOV.B #0x4, W0
000EAC  07FB27     RCALL lcd_set_com_seg
000EAE  370004     BRA 0xEB8
364:               	else 
365:               		lcd_set_com_seg(4,39,0);
000EB0  EB0100     CLR W2
000EB2  B3C271     MOV.B #0x27, W1
000EB4  B3C040     MOV.B #0x4, W0
000EB6  07FB22     RCALL lcd_set_com_seg
366:               }
000EB8  FA8000     ULNK
000EBA  060000     RETURN
367:               
368:               void lcd_disp_chr_loc_7(uint8_t code)
369:               {
000EBC  FA0002     LNK #0x2
000EBE  784F00     MOV.B W0, [W14]
370:               	lcd_set_com_seg(1,38,code&LCD_DSEG_A);
000EC0  FB801E     ZE [W14], W0
000EC2  600061     AND W0, #0x1, W0
000EC4  780100     MOV W0, W2
000EC6  B3C261     MOV.B #0x26, W1
000EC8  B3C010     MOV.B #0x1, W0
000ECA  07FB18     RCALL lcd_set_com_seg
371:               	lcd_set_com_seg(2,38,code&LCD_DSEG_B);
000ECC  FB801E     ZE [W14], W0
000ECE  600062     AND W0, #0x2, W0
000ED0  780100     MOV W0, W2
000ED2  B3C261     MOV.B #0x26, W1
000ED4  B3C020     MOV.B #0x2, W0
000ED6  07FB12     RCALL lcd_set_com_seg
372:                   lcd_set_com_seg(3,38,code&LCD_DSEG_C);
000ED8  FB801E     ZE [W14], W0
000EDA  600064     AND W0, #0x4, W0
000EDC  780100     MOV W0, W2
000EDE  B3C261     MOV.B #0x26, W1
000EE0  B3C030     MOV.B #0x3, W0
000EE2  07FB0C     RCALL lcd_set_com_seg
373:                   lcd_set_com_seg(4,38,code&LCD_DSEG_D);
000EE4  FB801E     ZE [W14], W0
000EE6  600068     AND W0, #0x8, W0
000EE8  780100     MOV W0, W2
000EEA  B3C261     MOV.B #0x26, W1
000EEC  B3C040     MOV.B #0x4, W0
000EEE  07FB06     RCALL lcd_set_com_seg
374:                   
375:                   lcd_set_com_seg(1,39,code&LCD_DSEG_F);
000EF0  FB809E     ZE [W14], W1
000EF2  200200     MOV #0x20, W0
000EF4  608000     AND W1, W0, W0
000EF6  780100     MOV W0, W2
000EF8  B3C271     MOV.B #0x27, W1
000EFA  B3C010     MOV.B #0x1, W0
000EFC  07FAFF     RCALL lcd_set_com_seg
376:                   lcd_set_com_seg(2,39,code&LCD_DSEG_G);
000EFE  FB809E     ZE [W14], W1
000F00  200400     MOV #0x40, W0
000F02  608000     AND W1, W0, W0
000F04  780100     MOV W0, W2
000F06  B3C271     MOV.B #0x27, W1
000F08  B3C020     MOV.B #0x2, W0
000F0A  07FAF8     RCALL lcd_set_com_seg
377:                   lcd_set_com_seg(3,39,code&LCD_DSEG_E);	
000F0C  FB801E     ZE [W14], W0
000F0E  600070     AND W0, #0x10, W0
000F10  780100     MOV W0, W2
000F12  B3C271     MOV.B #0x27, W1
000F14  B3C030     MOV.B #0x3, W0
000F16  07FAF2     RCALL lcd_set_com_seg
378:               }
000F18  FA8000     ULNK
000F1A  060000     RETURN
379:               
380:               /*
381:               void lcd_disp_dp_loc(bool dp,uint8_t loc)
382:               {
383:               	switch(loc){
384:               		case 0:	lcd_disp_dp_loc_0(dp);break;
385:               		case 1:	lcd_disp_dp_loc_1(dp);break;
386:               		case 2:	lcd_disp_dp_loc_2(dp);break;
387:               		case 4:	lcd_disp_dp_loc_4(dp);break;
388:               		case 5:	lcd_disp_dp_loc_5(dp);break;
389:               		case 6:	lcd_disp_dp_loc_6(dp);break;
390:               	}		
391:               }
392:               */
393:               //show unit
394:               void lcd_disp_logo(bool show)
395:               {
000F1C  FA0002     LNK #0x2
000F1E  784F00     MOV.B W0, [W14]
396:               
397:               }
000F20  FA8000     ULNK
000F22  060000     RETURN
398:               
399:               void lcd_disp_unit_t(bool show)
400:               {
000F24  FA0002     LNK #0x2
000F26  784F00     MOV.B W0, [W14]
401:               	lcd_set_com_seg(1,34,0);
000F28  EB0100     CLR W2
000F2A  B3C221     MOV.B #0x22, W1
000F2C  B3C010     MOV.B #0x1, W0
000F2E  07FAE6     RCALL lcd_set_com_seg
402:               	lcd_set_com_seg(1,35,0);
000F30  EB0100     CLR W2
000F32  B3C231     MOV.B #0x23, W1
000F34  B3C010     MOV.B #0x1, W0
000F36  07FAE2     RCALL lcd_set_com_seg
403:               	if(show)
000F38  78401E     MOV.B [W14], W0
000F3A  E00400     CP0.B W0
000F3C  320005     BRA Z, 0xF48
404:               		lcd_set_com_seg(1,49,1);
000F3E  200012     MOV #0x1, W2
000F40  B3C311     MOV.B #0x31, W1
000F42  B3C010     MOV.B #0x1, W0
000F44  07FADB     RCALL lcd_set_com_seg
000F46  370004     BRA 0xF50
405:               	else
406:               		lcd_set_com_seg(1,49,0);
000F48  EB0100     CLR W2
000F4A  B3C311     MOV.B #0x31, W1
000F4C  B3C010     MOV.B #0x1, W0
000F4E  07FAD6     RCALL lcd_set_com_seg
407:               }
000F50  FA8000     ULNK
000F52  060000     RETURN
408:               
409:               void lcd_disp_unit_1st_m(bool show)
410:               {
000F54  FA0002     LNK #0x2
000F56  784F00     MOV.B W0, [W14]
411:               	//t2=3;t3=m
412:               	lcd_set_com_seg(1,49,0);
000F58  EB0100     CLR W2
000F5A  B3C311     MOV.B #0x31, W1
000F5C  B3C010     MOV.B #0x1, W0
000F5E  07FACE     RCALL lcd_set_com_seg
413:               	lcd_set_com_seg(1,35,0);
000F60  EB0100     CLR W2
000F62  B3C231     MOV.B #0x23, W1
000F64  B3C010     MOV.B #0x1, W0
000F66  07FACA     RCALL lcd_set_com_seg
414:               	if(show){
000F68  78401E     MOV.B [W14], W0
000F6A  E00400     CP0.B W0
000F6C  320005     BRA Z, 0xF78
415:               		lcd_set_com_seg(1,34,1);
000F6E  200012     MOV #0x1, W2
000F70  B3C221     MOV.B #0x22, W1
000F72  B3C010     MOV.B #0x1, W0
000F74  07FAC3     RCALL lcd_set_com_seg
000F76  370004     BRA 0xF80
416:               	}else{
417:               		lcd_set_com_seg(1,34,0);
000F78  EB0100     CLR W2
000F7A  B3C221     MOV.B #0x22, W1
000F7C  B3C010     MOV.B #0x1, W0
000F7E  07FABE     RCALL lcd_set_com_seg
418:               	}
419:               }
000F80  FA8000     ULNK
000F82  060000     RETURN
420:               
421:               void lcd_disp_unit_1st_m3(bool show)
422:               {
000F84  FA0002     LNK #0x2
000F86  784F00     MOV.B W0, [W14]
423:               	//t2=3;t3=m
424:               	lcd_set_com_seg(1,49,0);
000F88  EB0100     CLR W2
000F8A  B3C311     MOV.B #0x31, W1
000F8C  B3C010     MOV.B #0x1, W0
000F8E  07FAB6     RCALL lcd_set_com_seg
425:               	if(show){
000F90  78401E     MOV.B [W14], W0
000F92  E00400     CP0.B W0
000F94  320009     BRA Z, 0xFA8
426:               		lcd_set_com_seg(1,34,1);
000F96  200012     MOV #0x1, W2
000F98  B3C221     MOV.B #0x22, W1
000F9A  B3C010     MOV.B #0x1, W0
000F9C  07FAAF     RCALL lcd_set_com_seg
427:               		lcd_set_com_seg(1,34,1);
000F9E  200012     MOV #0x1, W2
000FA0  B3C221     MOV.B #0x22, W1
000FA2  B3C010     MOV.B #0x1, W0
000FA4  07FAAB     RCALL lcd_set_com_seg
000FA6  370008     BRA 0xFB8
428:               	}else{
429:               		lcd_set_com_seg(1,35,0);
000FA8  EB0100     CLR W2
000FAA  B3C231     MOV.B #0x23, W1
000FAC  B3C010     MOV.B #0x1, W0
000FAE  07FAA6     RCALL lcd_set_com_seg
430:               		lcd_set_com_seg(1,35,0);
000FB0  EB0100     CLR W2
000FB2  B3C231     MOV.B #0x23, W1
000FB4  B3C010     MOV.B #0x1, W0
000FB6  07FAA2     RCALL lcd_set_com_seg
431:               	}
432:               }
000FB8  FA8000     ULNK
000FBA  060000     RETURN
433:               
434:               void lcd_disp_unit_temperature(bool show)
435:               {
000FBC  FA0002     LNK #0x2
000FBE  784F00     MOV.B W0, [W14]
436:               	lcd_set_com_seg(2,49,0);
000FC0  EB0100     CLR W2
000FC2  B3C311     MOV.B #0x31, W1
000FC4  B3C020     MOV.B #0x2, W0
000FC6  07FA9A     RCALL lcd_set_com_seg
437:               	lcd_set_com_seg(2,35,0);
000FC8  EB0100     CLR W2
000FCA  B3C231     MOV.B #0x23, W1
000FCC  B3C020     MOV.B #0x2, W0
000FCE  07FA96     RCALL lcd_set_com_seg
438:               	lcd_set_com_seg(3,35,0);
000FD0  EB0100     CLR W2
000FD2  B3C231     MOV.B #0x23, W1
000FD4  B3C030     MOV.B #0x3, W0
000FD6  07FA92     RCALL lcd_set_com_seg
439:               	if(show){
000FD8  78401E     MOV.B [W14], W0
000FDA  E00400     CP0.B W0
000FDC  320005     BRA Z, 0xFE8
440:               		lcd_set_com_seg(4,35,1);
000FDE  200012     MOV #0x1, W2
000FE0  B3C231     MOV.B #0x23, W1
000FE2  B3C040     MOV.B #0x4, W0
000FE4  07FA8B     RCALL lcd_set_com_seg
000FE6  370004     BRA 0xFF0
441:               	}else{
442:               		lcd_set_com_seg(4,35,0);
000FE8  EB0100     CLR W2
000FEA  B3C231     MOV.B #0x23, W1
000FEC  B3C040     MOV.B #0x4, W0
000FEE  07FA86     RCALL lcd_set_com_seg
443:               	}
444:               }
000FF0  FA8000     ULNK
000FF2  060000     RETURN
445:               
446:               void lcd_disp_unit_2nd_m(bool show)
447:               {
000FF4  FA0002     LNK #0x2
000FF6  784F00     MOV.B W0, [W14]
448:               	//t4=3;t5=m
449:               	lcd_set_com_seg(2,49,0);
000FF8  EB0100     CLR W2
000FFA  B3C311     MOV.B #0x31, W1
000FFC  B3C020     MOV.B #0x2, W0
000FFE  07FA7E     RCALL lcd_set_com_seg
450:               	lcd_set_com_seg(3,35,0);
001000  EB0100     CLR W2
001002  B3C231     MOV.B #0x23, W1
001004  B3C030     MOV.B #0x3, W0
001006  07FA7A     RCALL lcd_set_com_seg
451:               	lcd_set_com_seg(4,35,0);
001008  EB0100     CLR W2
00100A  B3C231     MOV.B #0x23, W1
00100C  B3C040     MOV.B #0x4, W0
00100E  07FA76     RCALL lcd_set_com_seg
452:               	if(show)
001010  78401E     MOV.B [W14], W0
001012  E00400     CP0.B W0
001014  320005     BRA Z, 0x1020
453:               		lcd_set_com_seg(2,34,1);
001016  200012     MOV #0x1, W2
001018  B3C221     MOV.B #0x22, W1
00101A  B3C020     MOV.B #0x2, W0
00101C  07FA6F     RCALL lcd_set_com_seg
00101E  370004     BRA 0x1028
454:               	else
455:               		lcd_set_com_seg(2,34,0);
001020  EB0100     CLR W2
001022  B3C221     MOV.B #0x22, W1
001024  B3C020     MOV.B #0x2, W0
001026  07FA6A     RCALL lcd_set_com_seg
456:               }
001028  FA8000     ULNK
00102A  060000     RETURN
457:               
458:               void lcd_disp_unit_2nd_m3(bool show)
459:               {
00102C  FA0002     LNK #0x2
00102E  784F00     MOV.B W0, [W14]
460:               	//t4=3;t5=m
461:               	lcd_set_com_seg(2,49,0);
001030  EB0100     CLR W2
001032  B3C311     MOV.B #0x31, W1
001034  B3C020     MOV.B #0x2, W0
001036  07FA62     RCALL lcd_set_com_seg
462:               	lcd_set_com_seg(4,35,0);
001038  EB0100     CLR W2
00103A  B3C231     MOV.B #0x23, W1
00103C  B3C040     MOV.B #0x4, W0
00103E  07FA5E     RCALL lcd_set_com_seg
463:               
464:               	
465:               	if(show){
001040  78401E     MOV.B [W14], W0
001042  E00400     CP0.B W0
001044  320009     BRA Z, 0x1058
466:               		lcd_set_com_seg(2,34,1);
001046  200012     MOV #0x1, W2
001048  B3C221     MOV.B #0x22, W1
00104A  B3C020     MOV.B #0x2, W0
00104C  07FA57     RCALL lcd_set_com_seg
467:               		lcd_set_com_seg(3,35,1);
00104E  200012     MOV #0x1, W2
001050  B3C231     MOV.B #0x23, W1
001052  B3C030     MOV.B #0x3, W0
001054  07FA53     RCALL lcd_set_com_seg
001056  370008     BRA 0x1068
468:               	}else{
469:               		lcd_set_com_seg(2,34,0);
001058  EB0100     CLR W2
00105A  B3C221     MOV.B #0x22, W1
00105C  B3C020     MOV.B #0x2, W0
00105E  07FA4E     RCALL lcd_set_com_seg
470:               		lcd_set_com_seg(3,35,0);
001060  EB0100     CLR W2
001062  B3C231     MOV.B #0x23, W1
001064  B3C030     MOV.B #0x3, W0
001066  07FA4A     RCALL lcd_set_com_seg
471:               	}
472:               }
001068  FA8000     ULNK
00106A  060000     RETURN
473:               
474:               void lcd_disp_unit_mpa(bool show)
475:               {
00106C  FA0002     LNK #0x2
00106E  784F00     MOV.B W0, [W14]
476:               	//mpa=t6
477:               	lcd_set_com_seg(2,34,0);
001070  EB0100     CLR W2
001072  B3C221     MOV.B #0x22, W1
001074  B3C020     MOV.B #0x2, W0
001076  07FA42     RCALL lcd_set_com_seg
478:               	lcd_set_com_seg(3,35,0);
001078  EB0100     CLR W2
00107A  B3C231     MOV.B #0x23, W1
00107C  B3C030     MOV.B #0x3, W0
00107E  07FA3E     RCALL lcd_set_com_seg
479:               	lcd_set_com_seg(4,35,0);
001080  EB0100     CLR W2
001082  B3C231     MOV.B #0x23, W1
001084  B3C040     MOV.B #0x4, W0
001086  07FA3A     RCALL lcd_set_com_seg
480:               	if(show){
001088  78401E     MOV.B [W14], W0
00108A  E00400     CP0.B W0
00108C  320005     BRA Z, 0x1098
481:               		lcd_set_com_seg(2,49,1);
00108E  200012     MOV #0x1, W2
001090  B3C311     MOV.B #0x31, W1
001092  B3C020     MOV.B #0x2, W0
001094  07FA33     RCALL lcd_set_com_seg
001096  370004     BRA 0x10A0
482:               	}else{
483:               		lcd_set_com_seg(2,49,0);
001098  EB0100     CLR W2
00109A  B3C311     MOV.B #0x31, W1
00109C  B3C020     MOV.B #0x2, W0
00109E  07FA2E     RCALL lcd_set_com_seg
484:               	}
485:               }
0010A0  FA8000     ULNK
0010A2  060000     RETURN
486:               //enn unit
487:               //add
488:               void lcd_disp_chr_loc_0_ex(uint16_t code)
489:               {
0010A4  FA0002     LNK #0x2
0010A6  780F00     MOV W0, [W14]
490:               	lcd_set_com_seg(7,49,code&SEG_A_EX);	
0010A8  78009E     MOV [W14], W1
0010AA  608061     AND W1, #0x1, W0
0010AC  780100     MOV W0, W2
0010AE  B3C311     MOV.B #0x31, W1
0010B0  B3C070     MOV.B #0x7, W0
0010B2  07FA24     RCALL lcd_set_com_seg
491:               	lcd_set_com_seg(7,35,code&SEG_B_EX);	
0010B4  78009E     MOV [W14], W1
0010B6  608062     AND W1, #0x2, W0
0010B8  780100     MOV W0, W2
0010BA  B3C231     MOV.B #0x23, W1
0010BC  B3C070     MOV.B #0x7, W0
0010BE  07FA1E     RCALL lcd_set_com_seg
492:               	lcd_set_com_seg(5,35,code&SEG_C_EX);	
0010C0  78009E     MOV [W14], W1
0010C2  608064     AND W1, #0x4, W0
0010C4  780100     MOV W0, W2
0010C6  B3C231     MOV.B #0x23, W1
0010C8  B3C050     MOV.B #0x5, W0
0010CA  07FA18     RCALL lcd_set_com_seg
493:               	lcd_set_com_seg(0,35,code&SEG_D_EX);	
0010CC  78009E     MOV [W14], W1
0010CE  608068     AND W1, #0x8, W0
0010D0  780100     MOV W0, W2
0010D2  B3C231     MOV.B #0x23, W1
0010D4  EB4000     CLR.B W0
0010D6  07FA12     RCALL lcd_set_com_seg
494:               	lcd_set_com_seg(0,49,code&SEG_E_EX);	
0010D8  78009E     MOV [W14], W1
0010DA  608070     AND W1, #0x10, W0
0010DC  780100     MOV W0, W2
0010DE  B3C311     MOV.B #0x31, W1
0010E0  EB4000     CLR.B W0
0010E2  07FA0C     RCALL lcd_set_com_seg
495:               	lcd_set_com_seg(6,49,code&SEG_F_EX);	
0010E4  200200     MOV #0x20, W0
0010E6  60001E     AND W0, [W14], W0
0010E8  780100     MOV W0, W2
0010EA  B3C311     MOV.B #0x31, W1
0010EC  B3C060     MOV.B #0x6, W0
0010EE  07FA06     RCALL lcd_set_com_seg
496:               	lcd_set_com_seg(5,49,code&SEG_G_EX);	
0010F0  200400     MOV #0x40, W0
0010F2  60001E     AND W0, [W14], W0
0010F4  780100     MOV W0, W2
0010F6  B3C311     MOV.B #0x31, W1
0010F8  B3C050     MOV.B #0x5, W0
0010FA  07FA00     RCALL lcd_set_com_seg
497:               	lcd_set_com_seg(6,35,code&SEG_H_EX);
0010FC  200800     MOV #0x80, W0
0010FE  60001E     AND W0, [W14], W0
001100  780100     MOV W0, W2
001102  B3C231     MOV.B #0x23, W1
001104  B3C060     MOV.B #0x6, W0
001106  07F9FA     RCALL lcd_set_com_seg
498:               	lcd_set_com_seg(6,34,code&SEG_I_EX);	
001108  201000     MOV #0x100, W0
00110A  60001E     AND W0, [W14], W0
00110C  780100     MOV W0, W2
00110E  B3C221     MOV.B #0x22, W1
001110  B3C060     MOV.B #0x6, W0
001112  07F9F4     RCALL lcd_set_com_seg
499:               	lcd_set_com_seg(7,34,code&SEG_J_EX);	
001114  202000     MOV #0x200, W0
001116  60001E     AND W0, [W14], W0
001118  780100     MOV W0, W2
00111A  B3C221     MOV.B #0x22, W1
00111C  B3C070     MOV.B #0x7, W0
00111E  07F9EE     RCALL lcd_set_com_seg
500:               	lcd_set_com_seg(5,34,code&SEG_K_EX);	
001120  204000     MOV #0x400, W0
001122  60001E     AND W0, [W14], W0
001124  780100     MOV W0, W2
001126  B3C221     MOV.B #0x22, W1
001128  B3C050     MOV.B #0x5, W0
00112A  07F9E8     RCALL lcd_set_com_seg
501:               	lcd_set_com_seg(0,34,code&SEG_L_EX);	
00112C  208000     MOV #0x800, W0
00112E  60001E     AND W0, [W14], W0
001130  780100     MOV W0, W2
001132  B3C221     MOV.B #0x22, W1
001134  EB4000     CLR.B W0
001136  07F9E2     RCALL lcd_set_com_seg
502:               }
001138  FA8000     ULNK
00113A  060000     RETURN
503:               void lcd_disp_chr_loc_1_ex(uint16_t code)
504:               {
00113C  FA0002     LNK #0x2
00113E  780F00     MOV W0, [W14]
505:               	lcd_set_com_seg(7,4,code&SEG_A_EX);	
001140  78009E     MOV [W14], W1
001142  608061     AND W1, #0x1, W0
001144  780100     MOV W0, W2
001146  B3C041     MOV.B #0x4, W1
001148  B3C070     MOV.B #0x7, W0
00114A  07F9D8     RCALL lcd_set_com_seg
506:               	lcd_set_com_seg(7,18,code&SEG_B_EX);	
00114C  78009E     MOV [W14], W1
00114E  608062     AND W1, #0x2, W0
001150  780100     MOV W0, W2
001152  B3C121     MOV.B #0x12, W1
001154  B3C070     MOV.B #0x7, W0
001156  07F9D2     RCALL lcd_set_com_seg
507:               	lcd_set_com_seg(5,18,code&SEG_C_EX);	
001158  78009E     MOV [W14], W1
00115A  608064     AND W1, #0x4, W0
00115C  780100     MOV W0, W2
00115E  B3C121     MOV.B #0x12, W1
001160  B3C050     MOV.B #0x5, W0
001162  07F9CC     RCALL lcd_set_com_seg
508:               	lcd_set_com_seg(0,18,code&SEG_D_EX);	
001164  78009E     MOV [W14], W1
001166  608068     AND W1, #0x8, W0
001168  780100     MOV W0, W2
00116A  B3C121     MOV.B #0x12, W1
00116C  EB4000     CLR.B W0
00116E  07F9C6     RCALL lcd_set_com_seg
509:               	lcd_set_com_seg(0,4,code&SEG_E_EX);	
001170  78009E     MOV [W14], W1
001172  608070     AND W1, #0x10, W0
001174  780100     MOV W0, W2
001176  B3C041     MOV.B #0x4, W1
001178  EB4000     CLR.B W0
00117A  07F9C0     RCALL lcd_set_com_seg
510:               	lcd_set_com_seg(6,4,code&SEG_F_EX);	
00117C  200200     MOV #0x20, W0
00117E  60001E     AND W0, [W14], W0
001180  780100     MOV W0, W2
001182  B3C041     MOV.B #0x4, W1
001184  B3C060     MOV.B #0x6, W0
001186  07F9BA     RCALL lcd_set_com_seg
511:               	lcd_set_com_seg(5,4,code&SEG_G_EX);	
001188  200400     MOV #0x40, W0
00118A  60001E     AND W0, [W14], W0
00118C  780100     MOV W0, W2
00118E  B3C041     MOV.B #0x4, W1
001190  B3C050     MOV.B #0x5, W0
001192  07F9B4     RCALL lcd_set_com_seg
512:               	lcd_set_com_seg(6,18,code&SEG_H_EX);
001194  200800     MOV #0x80, W0
001196  60001E     AND W0, [W14], W0
001198  780100     MOV W0, W2
00119A  B3C121     MOV.B #0x12, W1
00119C  B3C060     MOV.B #0x6, W0
00119E  07F9AE     RCALL lcd_set_com_seg
513:               	lcd_set_com_seg(6,55,code&SEG_I_EX);	
0011A0  201000     MOV #0x100, W0
0011A2  60001E     AND W0, [W14], W0
0011A4  780100     MOV W0, W2
0011A6  B3C371     MOV.B #0x37, W1
0011A8  B3C060     MOV.B #0x6, W0
0011AA  07F9A8     RCALL lcd_set_com_seg
514:               	lcd_set_com_seg(7,55,code&SEG_J_EX);	
0011AC  202000     MOV #0x200, W0
0011AE  60001E     AND W0, [W14], W0
0011B0  780100     MOV W0, W2
0011B2  B3C371     MOV.B #0x37, W1
0011B4  B3C070     MOV.B #0x7, W0
0011B6  07F9A2     RCALL lcd_set_com_seg
515:               	lcd_set_com_seg(5,55,code&SEG_K_EX);	
0011B8  204000     MOV #0x400, W0
0011BA  60001E     AND W0, [W14], W0
0011BC  780100     MOV W0, W2
0011BE  B3C371     MOV.B #0x37, W1
0011C0  B3C050     MOV.B #0x5, W0
0011C2  07F99C     RCALL lcd_set_com_seg
516:               	lcd_set_com_seg(0,55,code&SEG_L_EX);	
0011C4  208000     MOV #0x800, W0
0011C6  60001E     AND W0, [W14], W0
0011C8  780100     MOV W0, W2
0011CA  B3C371     MOV.B #0x37, W1
0011CC  EB4000     CLR.B W0
0011CE  07F996     RCALL lcd_set_com_seg
517:               }
0011D0  FA8000     ULNK
0011D2  060000     RETURN
518:               void lcd_disp_chr_loc_2_ex(uint16_t code)
519:               {
0011D4  FA0002     LNK #0x2
0011D6  780F00     MOV W0, [W14]
520:               	lcd_set_com_seg(7,19,code&SEG_A_EX);	
0011D8  78009E     MOV [W14], W1
0011DA  608061     AND W1, #0x1, W0
0011DC  780100     MOV W0, W2
0011DE  B3C131     MOV.B #0x13, W1
0011E0  B3C070     MOV.B #0x7, W0
0011E2  07F98C     RCALL lcd_set_com_seg
521:               	lcd_set_com_seg(7,9,code&SEG_B_EX);	
0011E4  78009E     MOV [W14], W1
0011E6  608062     AND W1, #0x2, W0
0011E8  780100     MOV W0, W2
0011EA  B3C091     MOV.B #0x9, W1
0011EC  B3C070     MOV.B #0x7, W0
0011EE  07F986     RCALL lcd_set_com_seg
522:               	lcd_set_com_seg(5,9,code&SEG_C_EX);	
0011F0  78009E     MOV [W14], W1
0011F2  608064     AND W1, #0x4, W0
0011F4  780100     MOV W0, W2
0011F6  B3C091     MOV.B #0x9, W1
0011F8  B3C050     MOV.B #0x5, W0
0011FA  07F980     RCALL lcd_set_com_seg
523:               	lcd_set_com_seg(0,9,code&SEG_D_EX);	
0011FC  78009E     MOV [W14], W1
0011FE  608068     AND W1, #0x8, W0
001200  780100     MOV W0, W2
001202  B3C091     MOV.B #0x9, W1
001204  EB4000     CLR.B W0
001206  07F97A     RCALL lcd_set_com_seg
524:               	lcd_set_com_seg(0,19,code&SEG_E_EX);	
001208  78009E     MOV [W14], W1
00120A  608070     AND W1, #0x10, W0
00120C  780100     MOV W0, W2
00120E  B3C131     MOV.B #0x13, W1
001210  EB4000     CLR.B W0
001212  07F974     RCALL lcd_set_com_seg
525:               	lcd_set_com_seg(6,19,code&SEG_F_EX);	
001214  200200     MOV #0x20, W0
001216  60001E     AND W0, [W14], W0
001218  780100     MOV W0, W2
00121A  B3C131     MOV.B #0x13, W1
00121C  B3C060     MOV.B #0x6, W0
00121E  07F96E     RCALL lcd_set_com_seg
526:               	lcd_set_com_seg(5,19,code&SEG_G_EX);	
001220  200400     MOV #0x40, W0
001222  60001E     AND W0, [W14], W0
001224  780100     MOV W0, W2
001226  B3C131     MOV.B #0x13, W1
001228  B3C050     MOV.B #0x5, W0
00122A  07F968     RCALL lcd_set_com_seg
527:               	lcd_set_com_seg(6,9,code&SEG_H_EX);
00122C  200800     MOV #0x80, W0
00122E  60001E     AND W0, [W14], W0
001230  780100     MOV W0, W2
001232  B3C091     MOV.B #0x9, W1
001234  B3C060     MOV.B #0x6, W0
001236  07F962     RCALL lcd_set_com_seg
528:               	lcd_set_com_seg(6,8,code&SEG_I_EX);	
001238  201000     MOV #0x100, W0
00123A  60001E     AND W0, [W14], W0
00123C  780100     MOV W0, W2
00123E  B3C081     MOV.B #0x8, W1
001240  B3C060     MOV.B #0x6, W0
001242  07F95C     RCALL lcd_set_com_seg
529:               	lcd_set_com_seg(7,8,code&SEG_J_EX);	
001244  202000     MOV #0x200, W0
001246  60001E     AND W0, [W14], W0
001248  780100     MOV W0, W2
00124A  B3C081     MOV.B #0x8, W1
00124C  B3C070     MOV.B #0x7, W0
00124E  07F956     RCALL lcd_set_com_seg
530:               	lcd_set_com_seg(5,8,code&SEG_K_EX);	
001250  204000     MOV #0x400, W0
001252  60001E     AND W0, [W14], W0
001254  780100     MOV W0, W2
001256  B3C081     MOV.B #0x8, W1
001258  B3C050     MOV.B #0x5, W0
00125A  07F950     RCALL lcd_set_com_seg
531:               	lcd_set_com_seg(0,8,code&SEG_L_EX);	
00125C  208000     MOV #0x800, W0
00125E  60001E     AND W0, [W14], W0
001260  780100     MOV W0, W2
001262  B3C081     MOV.B #0x8, W1
001264  EB4000     CLR.B W0
001266  07F94A     RCALL lcd_set_com_seg
532:               }
001268  FA8000     ULNK
00126A  060000     RETURN
533:               void lcd_disp_chr_loc_0_sm(uint8_t code)
534:               {
00126C  FA0002     LNK #0x2
00126E  784F00     MOV.B W0, [W14]
535:               	lcd_set_com_seg(1,55,code&LCD_DSEG_A);
001270  FB801E     ZE [W14], W0
001272  600061     AND W0, #0x1, W0
001274  780100     MOV W0, W2
001276  B3C371     MOV.B #0x37, W1
001278  B3C010     MOV.B #0x1, W0
00127A  07F940     RCALL lcd_set_com_seg
536:               	lcd_set_com_seg(2,55,code&LCD_DSEG_B);
00127C  FB801E     ZE [W14], W0
00127E  600062     AND W0, #0x2, W0
001280  780100     MOV W0, W2
001282  B3C371     MOV.B #0x37, W1
001284  B3C020     MOV.B #0x2, W0
001286  07F93A     RCALL lcd_set_com_seg
537:                   lcd_set_com_seg(3,55,code&LCD_DSEG_C);
001288  FB801E     ZE [W14], W0
00128A  600064     AND W0, #0x4, W0
00128C  780100     MOV W0, W2
00128E  B3C371     MOV.B #0x37, W1
001290  B3C030     MOV.B #0x3, W0
001292  07F934     RCALL lcd_set_com_seg
538:                   lcd_set_com_seg(4,55,code&LCD_DSEG_D);
001294  FB801E     ZE [W14], W0
001296  600068     AND W0, #0x8, W0
001298  780100     MOV W0, W2
00129A  B3C371     MOV.B #0x37, W1
00129C  B3C040     MOV.B #0x4, W0
00129E  07F92E     RCALL lcd_set_com_seg
539:                   
540:                   lcd_set_com_seg(1,4,code&LCD_DSEG_F);
0012A0  FB809E     ZE [W14], W1
0012A2  200200     MOV #0x20, W0
0012A4  608000     AND W1, W0, W0
0012A6  780100     MOV W0, W2
0012A8  B3C041     MOV.B #0x4, W1
0012AA  B3C010     MOV.B #0x1, W0
0012AC  07F927     RCALL lcd_set_com_seg
541:                   lcd_set_com_seg(2,4,code&LCD_DSEG_G);
0012AE  FB809E     ZE [W14], W1
0012B0  200400     MOV #0x40, W0
0012B2  608000     AND W1, W0, W0
0012B4  780100     MOV W0, W2
0012B6  B3C041     MOV.B #0x4, W1
0012B8  B3C020     MOV.B #0x2, W0
0012BA  07F920     RCALL lcd_set_com_seg
542:                   lcd_set_com_seg(3,4,code&LCD_DSEG_E);
0012BC  FB801E     ZE [W14], W0
0012BE  600070     AND W0, #0x10, W0
0012C0  780100     MOV W0, W2
0012C2  B3C041     MOV.B #0x4, W1
0012C4  B3C030     MOV.B #0x3, W0
0012C6  07F91A     RCALL lcd_set_com_seg
543:                   //lcd_disp_com_seg(3,00,code&LCD_DSEG_DP);
544:               }
0012C8  FA8000     ULNK
0012CA  060000     RETURN
545:               void lcd_disp_chr_loc_1_sm(uint8_t code)
546:               {
0012CC  FA0002     LNK #0x2
0012CE  784F00     MOV.B W0, [W14]
547:               	lcd_set_com_seg(1,19,code&LCD_DSEG_A);
0012D0  FB801E     ZE [W14], W0
0012D2  600061     AND W0, #0x1, W0
0012D4  780100     MOV W0, W2
0012D6  B3C131     MOV.B #0x13, W1
0012D8  B3C010     MOV.B #0x1, W0
0012DA  07F910     RCALL lcd_set_com_seg
548:               	lcd_set_com_seg(2,19,code&LCD_DSEG_B);
0012DC  FB801E     ZE [W14], W0
0012DE  600062     AND W0, #0x2, W0
0012E0  780100     MOV W0, W2
0012E2  B3C131     MOV.B #0x13, W1
0012E4  B3C020     MOV.B #0x2, W0
0012E6  07F90A     RCALL lcd_set_com_seg
549:                   lcd_set_com_seg(3,19,code&LCD_DSEG_C);
0012E8  FB801E     ZE [W14], W0
0012EA  600064     AND W0, #0x4, W0
0012EC  780100     MOV W0, W2
0012EE  B3C131     MOV.B #0x13, W1
0012F0  B3C030     MOV.B #0x3, W0
0012F2  07F904     RCALL lcd_set_com_seg
550:                   lcd_set_com_seg(4,19,code&LCD_DSEG_D);
0012F4  FB801E     ZE [W14], W0
0012F6  600068     AND W0, #0x8, W0
0012F8  780100     MOV W0, W2
0012FA  B3C131     MOV.B #0x13, W1
0012FC  B3C040     MOV.B #0x4, W0
0012FE  07F8FE     RCALL lcd_set_com_seg
551:                   
552:                   lcd_set_com_seg(1,18,code&LCD_DSEG_F);
001300  FB809E     ZE [W14], W1
001302  200200     MOV #0x20, W0
001304  608000     AND W1, W0, W0
001306  780100     MOV W0, W2
001308  B3C121     MOV.B #0x12, W1
00130A  B3C010     MOV.B #0x1, W0
00130C  07F8F7     RCALL lcd_set_com_seg
553:                   lcd_set_com_seg(2,18,code&LCD_DSEG_G);
00130E  FB809E     ZE [W14], W1
001310  200400     MOV #0x40, W0
001312  608000     AND W1, W0, W0
001314  780100     MOV W0, W2
001316  B3C121     MOV.B #0x12, W1
001318  B3C020     MOV.B #0x2, W0
00131A  07F8F0     RCALL lcd_set_com_seg
554:                   lcd_set_com_seg(3,18,code&LCD_DSEG_E);
00131C  FB801E     ZE [W14], W0
00131E  600070     AND W0, #0x10, W0
001320  780100     MOV W0, W2
001322  B3C121     MOV.B #0x12, W1
001324  B3C030     MOV.B #0x3, W0
001326  07F8EA     RCALL lcd_set_com_seg
555:                   //lcd_disp_com_seg(3,00,code&LCD_DSEG_DP);
556:               }
001328  FA8000     ULNK
00132A  060000     RETURN
557:               void lcd_disp_chr_loc_2_sm(uint8_t code)
558:               {
00132C  FA0002     LNK #0x2
00132E  784F00     MOV.B W0, [W14]
559:               	lcd_set_com_seg(1,9,code&LCD_DSEG_A);
001330  FB801E     ZE [W14], W0
001332  600061     AND W0, #0x1, W0
001334  780100     MOV W0, W2
001336  B3C091     MOV.B #0x9, W1
001338  B3C010     MOV.B #0x1, W0
00133A  07F8E0     RCALL lcd_set_com_seg
560:               	lcd_set_com_seg(2,9,code&LCD_DSEG_B);
00133C  FB801E     ZE [W14], W0
00133E  600062     AND W0, #0x2, W0
001340  780100     MOV W0, W2
001342  B3C091     MOV.B #0x9, W1
001344  B3C020     MOV.B #0x2, W0
001346  07F8DA     RCALL lcd_set_com_seg
561:                   lcd_set_com_seg(3,9,code&LCD_DSEG_C);
001348  FB801E     ZE [W14], W0
00134A  600064     AND W0, #0x4, W0
00134C  780100     MOV W0, W2
00134E  B3C091     MOV.B #0x9, W1
001350  B3C030     MOV.B #0x3, W0
001352  07F8D4     RCALL lcd_set_com_seg
562:                   lcd_set_com_seg(4,9,code&LCD_DSEG_D);
001354  FB801E     ZE [W14], W0
001356  600068     AND W0, #0x8, W0
001358  780100     MOV W0, W2
00135A  B3C091     MOV.B #0x9, W1
00135C  B3C040     MOV.B #0x4, W0
00135E  07F8CE     RCALL lcd_set_com_seg
563:                   
564:                   lcd_set_com_seg(1,8,code&LCD_DSEG_F);
001360  FB809E     ZE [W14], W1
001362  200200     MOV #0x20, W0
001364  608000     AND W1, W0, W0
001366  780100     MOV W0, W2
001368  B3C081     MOV.B #0x8, W1
00136A  B3C010     MOV.B #0x1, W0
00136C  07F8C7     RCALL lcd_set_com_seg
565:                   lcd_set_com_seg(2,8,code&LCD_DSEG_G);
00136E  FB809E     ZE [W14], W1
001370  200400     MOV #0x40, W0
001372  608000     AND W1, W0, W0
001374  780100     MOV W0, W2
001376  B3C081     MOV.B #0x8, W1
001378  B3C020     MOV.B #0x2, W0
00137A  07F8C0     RCALL lcd_set_com_seg
566:                   lcd_set_com_seg(3,8,code&LCD_DSEG_E);
00137C  FB801E     ZE [W14], W0
00137E  600070     AND W0, #0x10, W0
001380  780100     MOV W0, W2
001382  B3C081     MOV.B #0x8, W1
001384  B3C030     MOV.B #0x3, W0
001386  07F8BA     RCALL lcd_set_com_seg
567:                   //lcd_disp_com_seg(3,00,code&LCD_DSEG_DP);
568:               }
001388  FA8000     ULNK
00138A  060000     RETURN
569:               void lcd_disp_dp_loc_0_sm(bool dp)
570:               {
00138C  FA0002     LNK #0x2
00138E  784F00     MOV.B W0, [W14]
571:               	if(dp)
001390  78401E     MOV.B [W14], W0
001392  E00400     CP0.B W0
001394  320005     BRA Z, 0x13A0
572:               		lcd_set_com_seg(4,18,LCD_DSEG_DP);
001396  200802     MOV #0x80, W2
001398  B3C121     MOV.B #0x12, W1
00139A  B3C040     MOV.B #0x4, W0
00139C  07F8AF     RCALL lcd_set_com_seg
00139E  370004     BRA 0x13A8
573:               	else 
574:               		lcd_set_com_seg(4,18,0);
0013A0  EB0100     CLR W2
0013A2  B3C121     MOV.B #0x12, W1
0013A4  B3C040     MOV.B #0x4, W0
0013A6  07F8AA     RCALL lcd_set_com_seg
575:               }
0013A8  FA8000     ULNK
0013AA  060000     RETURN
576:               void lcd_disp_dp_loc_1_sm(bool dp)
577:               {
0013AC  FA0002     LNK #0x2
0013AE  784F00     MOV.B W0, [W14]
578:               	if(dp)
0013B0  78401E     MOV.B [W14], W0
0013B2  E00400     CP0.B W0
0013B4  320005     BRA Z, 0x13C0
579:               		lcd_set_com_seg(4,4,LCD_DSEG_DP);
0013B6  200802     MOV #0x80, W2
0013B8  B3C041     MOV.B #0x4, W1
0013BA  B3C040     MOV.B #0x4, W0
0013BC  07F89F     RCALL lcd_set_com_seg
0013BE  370004     BRA 0x13C8
580:               	else 
581:               		lcd_set_com_seg(4,4,0);
0013C0  EB0100     CLR W2
0013C2  B3C041     MOV.B #0x4, W1
0013C4  B3C040     MOV.B #0x4, W0
0013C6  07F89A     RCALL lcd_set_com_seg
582:               }
0013C8  FA8000     ULNK
0013CA  060000     RETURN
583:               void lcd_disp_dp_loc_sign_sm(bool sig)
584:               {
0013CC  FA0002     LNK #0x2
0013CE  784F00     MOV.B W0, [W14]
585:               	if(sig)
0013D0  78401E     MOV.B [W14], W0
0013D2  E00400     CP0.B W0
0013D4  320005     BRA Z, 0x13E0
586:               		lcd_set_com_seg(2,35,1);
0013D6  200012     MOV #0x1, W2
0013D8  B3C231     MOV.B #0x23, W1
0013DA  B3C020     MOV.B #0x2, W0
0013DC  07F88F     RCALL lcd_set_com_seg
0013DE  370004     BRA 0x13E8
587:               	else 
588:               		lcd_set_com_seg(2,35,0);
0013E0  EB0100     CLR W2
0013E2  B3C231     MOV.B #0x23, W1
0013E4  B3C020     MOV.B #0x2, W0
0013E6  07F88A     RCALL lcd_set_com_seg
589:               }
0013E8  FA8000     ULNK
0013EA  060000     RETURN
590:               void lcd_disp_dp_loc_sm_temperature(bool show)
591:               {
0013EC  FA0002     LNK #0x2
0013EE  784F00     MOV.B W0, [W14]
592:               	if(show)
0013F0  78401E     MOV.B [W14], W0
0013F2  E00400     CP0.B W0
0013F4  320005     BRA Z, 0x1400
593:               		lcd_set_com_seg(4,8,1);
0013F6  200012     MOV #0x1, W2
0013F8  B3C081     MOV.B #0x8, W1
0013FA  B3C040     MOV.B #0x4, W0
0013FC  07F87F     RCALL lcd_set_com_seg
0013FE  370004     BRA 0x1408
594:               	else 
595:               		lcd_set_com_seg(4,8,0);
001400  EB0100     CLR W2
001402  B3C081     MOV.B #0x8, W1
001404  B3C040     MOV.B #0x4, W0
001406  07F87A     RCALL lcd_set_com_seg
596:               }
001408  FA8000     ULNK
00140A  060000     RETURN
597:               void lcd_show_dp_sm(uint8_t loc,bool show)
598:               {
00140C  FA0002     LNK #0x2
00140E  784F00     MOV.B W0, [W14]
001410  984711     MOV.B W1, [W14+1]
599:               	switch(loc){
001412  FB801E     ZE [W14], W0
001414  E00000     CP0 W0
001416  320003     BRA Z, 0x141E
001418  500FE1     SUB W0, #0x1, [W15]
00141A  320004     BRA Z, 0x1424
600:               		case 0:lcd_disp_dp_loc_0_sm(show);break;
00141E  90401E     MOV.B [W14+1], W0
001420  07FFB5     RCALL lcd_disp_dp_loc_0_sm
001422  370003     BRA 0x142A
601:               		case 1:lcd_disp_dp_loc_1_sm(show);break;
001424  90401E     MOV.B [W14+1], W0
001426  07FFC2     RCALL lcd_disp_dp_loc_1_sm
001428  000000     NOP
602:               		//case 7:
603:               		default:break;
00141C  370006     BRA 0x142A
604:               	}		
605:               }
00142A  FA8000     ULNK
00142C  060000     RETURN
606:               void lcd_clear_all_dp_sm(void)
607:               {
00142E  FA0000     LNK #0x0
608:               	 lcd_disp_dp_loc_0_sm(false);
001430  EB4000     CLR.B W0
001432  07FFAC     RCALL lcd_disp_dp_loc_0_sm
609:               	 lcd_disp_dp_loc_1_sm(false);
001434  EB4000     CLR.B W0
001436  07FFBA     RCALL lcd_disp_dp_loc_1_sm
610:               }
001438  FA8000     ULNK
00143A  060000     RETURN
611:               //api
612:               uint8_t lcd_disp_get_code(uint8_t chr)
613:               {
00143C  FA0004     LNK #0x4
00143E  984720     MOV.B W0, [W14+2]
614:               	uint8_t i;
615:               	uint8_t ret;
616:               	for(i=0;i<sizeof(LCDDigitalIndexTable);i++){
001440  EB4000     CLR.B W0
001442  784F00     MOV.B W0, [W14]
001444  370007     BRA 0x1454
001452  E84F1E     INC.B [W14], [W14]
001454  B3C2A0     MOV.B #0x2A, W0
001456  78409E     MOV.B [W14], W1
001458  50CF80     SUB.B W1, W0, [W15]
00145A  36FFF5     BRA LEU, 0x1446
00145C  370001     BRA 0x1460
617:               		if(chr==LCDDigitalIndexTable[i])break;
001446  FB801E     ZE [W14], W0
001448  283C81     MOV #0x83C8, W1
00144A  7840E1     MOV.B [W1+W0], W1
00144C  90402E     MOV.B [W14+2], W0
00144E  50CF80     SUB.B W1, W0, [W15]
001450  320006     BRA Z, 0x145E
00145E  000000     NOP
618:               	}
619:               	if(i<sizeof(LCDDigitalIndexTable)){
001460  B3C2A0     MOV.B #0x2A, W0
001462  78409E     MOV.B [W14], W1
001464  50CF80     SUB.B W1, W0, [W15]
001466  3E0004     BRA GTU, 0x1470
620:               		ret= LCDDigitalTable[i];
001468  FB801E     ZE [W14], W0
00146A  283F31     MOV #0x83F3, W1
00146C  784161     MOV.B [W1+W0], W2
00146E  984712     MOV.B W2, [W14+1]
621:               	}
622:               	return ret;
001470  90401E     MOV.B [W14+1], W0
623:               }
001472  FA8000     ULNK
001474  060000     RETURN
624:               
625:               uint16_t lcd_disp_get_code_ex(uint8_t chr)
626:               {
001476  FA0006     LNK #0x6
001478  984740     MOV.B W0, [W14+4]
627:               	uint8_t i;
628:               	uint16_t ret;
629:               	for(i=0;i<sizeof(LCDDigitalTableIndexEx);i++){
00147A  EB4000     CLR.B W0
00147C  784F00     MOV.B W0, [W14]
00147E  370007     BRA 0x148E
00148C  E84F1E     INC.B [W14], [W14]
00148E  B3C3E0     MOV.B #0x3E, W0
001490  78409E     MOV.B [W14], W1
001492  50CF80     SUB.B W1, W0, [W15]
001494  36FFF5     BRA LEU, 0x1480
001496  370001     BRA 0x149A
630:               		if(chr==LCDDigitalTableIndexEx[i])break;
001480  FB801E     ZE [W14], W0
001482  2841D1     MOV #0x841D, W1
001484  7840E1     MOV.B [W1+W0], W1
001486  90404E     MOV.B [W14+4], W0
001488  50CF80     SUB.B W1, W0, [W15]
00148A  320006     BRA Z, 0x1498
001498  000000     NOP
631:               	}
632:               	if(i<sizeof(LCDDigitalTableIndexEx)){
00149A  B3C3E0     MOV.B #0x3E, W0
00149C  78409E     MOV.B [W14], W1
00149E  50CF80     SUB.B W1, W0, [W15]
0014A0  3E0006     BRA GTU, 0x14AE
633:               		ret= LCDDigitalTableEx[i];
0014A2  FB801E     ZE [W14], W0
0014A4  400080     ADD W0, W0, W1
0014A6  2845C0     MOV #0x845C, W0
0014A8  408000     ADD W1, W0, W0
0014AA  780090     MOV [W0], W1
0014AC  980711     MOV W1, [W14+2]
634:               	}
635:               	return ret;
0014AE  90001E     MOV [W14+2], W0
636:               }
0014B0  FA8000     ULNK
0014B2  060000     RETURN
637:               void lcd_clear_all_dp(void)
638:               {
0014B4  FA0000     LNK #0x0
639:               	lcd_disp_dp_loc_0(false);
0014B6  EB4000     CLR.B W0
0014B8  07FB81     RCALL lcd_disp_dp_loc_0
640:               	lcd_disp_dp_loc_1(false);
0014BA  EB4000     CLR.B W0
0014BC  07FBBF     RCALL lcd_disp_dp_loc_1
641:               	lcd_disp_dp_loc_2(false);
0014BE  EB4000     CLR.B W0
0014C0  07FBFD     RCALL lcd_disp_dp_loc_2
642:               	lcd_disp_dp_loc_4(false);
0014C2  EB4000     CLR.B W0
0014C4  07FC6B     RCALL lcd_disp_dp_loc_4
643:               	lcd_disp_dp_loc_5(false);
0014C6  EB4000     CLR.B W0
0014C8  07FCA9     RCALL lcd_disp_dp_loc_5
644:               	lcd_disp_dp_loc_6(false);
0014CA  EB4000     CLR.B W0
0014CC  07FCE7     RCALL lcd_disp_dp_loc_6
645:               }
0014CE  FA8000     ULNK
0014D0  060000     RETURN
646:               
647:               void lcd_show_dp(uint8_t loc,bool show)
648:               {
0014D2  FA0002     LNK #0x2
0014D4  784F00     MOV.B W0, [W14]
0014D6  984711     MOV.B W1, [W14+1]
649:               	switch(loc){
0014D8  FB801E     ZE [W14], W0
0014DA  500FE2     SUB W0, #0x2, [W15]
0014DC  320014     BRA Z, 0x1506
0014DE  500FE2     SUB W0, #0x2, [W15]
0014E0  3C0005     BRA GT, 0x14EC
0014E2  E00000     CP0 W0
0014E4  32000A     BRA Z, 0x14FA
0014E6  500FE1     SUB W0, #0x1, [W15]
0014E8  32000B     BRA Z, 0x1500
0014EC  500FE5     SUB W0, #0x5, [W15]
0014EE  320011     BRA Z, 0x1512
0014F0  500FE6     SUB W0, #0x6, [W15]
0014F2  320012     BRA Z, 0x1518
0014F4  500FE4     SUB W0, #0x4, [W15]
0014F6  32000A     BRA Z, 0x150C
650:               		case 0:lcd_disp_dp_loc_0(show);break;
0014FA  90401E     MOV.B [W14+1], W0
0014FC  07FB5F     RCALL lcd_disp_dp_loc_0
0014FE  37000F     BRA 0x151E
651:               		case 1:lcd_disp_dp_loc_1(show);break;
001500  90401E     MOV.B [W14+1], W0
001502  07FB9C     RCALL lcd_disp_dp_loc_1
001504  37000C     BRA 0x151E
652:               		case 2:lcd_disp_dp_loc_2(show);break;
001506  90401E     MOV.B [W14+1], W0
001508  07FBD9     RCALL lcd_disp_dp_loc_2
00150A  370009     BRA 0x151E
653:               		//case 3:
654:               		case 4:lcd_disp_dp_loc_4(show);break;
00150C  90401E     MOV.B [W14+1], W0
00150E  07FC46     RCALL lcd_disp_dp_loc_4
001510  370006     BRA 0x151E
655:               		case 5:lcd_disp_dp_loc_5(show);break;
001512  90401E     MOV.B [W14+1], W0
001514  07FC83     RCALL lcd_disp_dp_loc_5
001516  370003     BRA 0x151E
656:               		case 6:lcd_disp_dp_loc_6(show);break;
001518  90401E     MOV.B [W14+1], W0
00151A  07FCC0     RCALL lcd_disp_dp_loc_6
00151C  000000     NOP
657:               		//case 7:
658:               		default:break;
0014EA  370019     BRA 0x151E
0014F8  370012     BRA 0x151E
659:               	}		
660:               }
00151E  FA8000     ULNK
001520  060000     RETURN
661:               
662:               void lcd_show_chr(uint8_t loc,uint8_t chr)
663:               {
001522  FA0004     LNK #0x4
001524  984720     MOV.B W0, [W14+2]
001526  984731     MOV.B W1, [W14+3]
664:                   uint8_t code=lcd_disp_get_code(chr);
001528  90403E     MOV.B [W14+3], W0
00152A  07FF88     RCALL lcd_disp_get_code
00152C  784F00     MOV.B W0, [W14]
665:               	switch(loc){
00152E  90402E     MOV.B [W14+2], W0
001530  FB8000     ZE W0, W0
001532  500FE3     SUB W0, #0x3, [W15]
001534  32001B     BRA Z, 0x156C
001536  500FE3     SUB W0, #0x3, [W15]
001538  3C0007     BRA GT, 0x1548
00153A  500FE1     SUB W0, #0x1, [W15]
00153C  320011     BRA Z, 0x1560
00153E  500FE1     SUB W0, #0x1, [W15]
001540  3C0012     BRA GT, 0x1566
001542  E00000     CP0 W0
001544  32000A     BRA Z, 0x155A
001548  500FE5     SUB W0, #0x5, [W15]
00154A  320016     BRA Z, 0x1578
00154C  500FE5     SUB W0, #0x5, [W15]
00154E  350011     BRA LT, 0x1572
001550  500FE6     SUB W0, #0x6, [W15]
001552  320015     BRA Z, 0x157E
001554  500FE7     SUB W0, #0x7, [W15]
001556  320016     BRA Z, 0x1584
666:               		case 0:lcd_disp_chr_loc_0(code);break;
00155A  78401E     MOV.B [W14], W0
00155C  07FAFF     RCALL lcd_disp_chr_loc_0
00155E  370015     BRA 0x158A
667:               		case 1:lcd_disp_chr_loc_1(code);break;
001560  78401E     MOV.B [W14], W0
001562  07FB3C     RCALL lcd_disp_chr_loc_1
001564  370012     BRA 0x158A
668:               		case 2:lcd_disp_chr_loc_2(code);break;
001566  78401E     MOV.B [W14], W0
001568  07FB79     RCALL lcd_disp_chr_loc_2
00156A  37000F     BRA 0x158A
669:               		case 3:lcd_disp_chr_loc_3(code);break;
00156C  78401E     MOV.B [W14], W0
00156E  07FBB6     RCALL lcd_disp_chr_loc_3
001570  37000C     BRA 0x158A
670:               		case 4:lcd_disp_chr_loc_4(code);break;
001572  78401E     MOV.B [W14], W0
001574  07FBE3     RCALL lcd_disp_chr_loc_4
001576  370009     BRA 0x158A
671:               		case 5:lcd_disp_chr_loc_5(code);break;
001578  78401E     MOV.B [W14], W0
00157A  07FC20     RCALL lcd_disp_chr_loc_5
00157C  370006     BRA 0x158A
672:               		case 6:lcd_disp_chr_loc_6(code);break;
00157E  78401E     MOV.B [W14], W0
001580  07FC5D     RCALL lcd_disp_chr_loc_6
001582  370003     BRA 0x158A
673:               		case 7:lcd_disp_chr_loc_7(code);break;
001584  78401E     MOV.B [W14], W0
001586  07FC9A     RCALL lcd_disp_chr_loc_7
001588  000000     NOP
674:               		default:break;
001546  370021     BRA 0x158A
001558  370018     BRA 0x158A
675:               	}		
676:               }
00158A  FA8000     ULNK
00158C  060000     RETURN
677:               
678:               void lcd_show_chr_sm(uint8_t loc,uint8_t chr)
679:               {
00158E  FA0004     LNK #0x4
001590  984720     MOV.B W0, [W14+2]
001592  984731     MOV.B W1, [W14+3]
680:                   uint8_t code=lcd_disp_get_code(chr);
001594  90403E     MOV.B [W14+3], W0
001596  07FF52     RCALL lcd_disp_get_code
001598  784F00     MOV.B W0, [W14]
681:               	switch(loc){
00159A  90402E     MOV.B [W14+2], W0
00159C  FB8000     ZE W0, W0
00159E  500FE1     SUB W0, #0x1, [W15]
0015A0  320007     BRA Z, 0x15B0
0015A2  500FE2     SUB W0, #0x2, [W15]
0015A4  320008     BRA Z, 0x15B6
0015A6  E00000     CP0 W0
0015A8  3A000A     BRA NZ, 0x15BE
682:               		case 0:lcd_disp_chr_loc_0_sm(code);break;
0015AA  78401E     MOV.B [W14], W0
0015AC  07FE5F     RCALL lcd_disp_chr_loc_0_sm
0015AE  370008     BRA 0x15C0
683:               		case 1:lcd_disp_chr_loc_1_sm(code);break;
0015B0  78401E     MOV.B [W14], W0
0015B2  07FE8C     RCALL lcd_disp_chr_loc_1_sm
0015B4  370005     BRA 0x15C0
684:               		case 2:lcd_disp_chr_loc_2_sm(code);break;
0015B6  78401E     MOV.B [W14], W0
0015B8  07FEB9     RCALL lcd_disp_chr_loc_2_sm
0015BA  000000     NOP
0015BC  370001     BRA 0x15C0
685:               		default:break;
0015BE  000000     NOP
686:               	}		
687:               }
0015C0  FA8000     ULNK
0015C2  060000     RETURN
688:               void lcd_show_chr_ex(uint8_t loc,uint8_t chr)
689:               {
0015C4  FA0004     LNK #0x4
0015C6  984720     MOV.B W0, [W14+2]
0015C8  984731     MOV.B W1, [W14+3]
690:                   uint16_t code=lcd_disp_get_code_ex(chr);
0015CA  90403E     MOV.B [W14+3], W0
0015CC  07FF54     RCALL lcd_disp_get_code_ex
0015CE  780F00     MOV W0, [W14]
691:               	switch(loc){
0015D0  90402E     MOV.B [W14+2], W0
0015D2  FB8000     ZE W0, W0
0015D4  500FE1     SUB W0, #0x1, [W15]
0015D6  320007     BRA Z, 0x15E6
0015D8  500FE2     SUB W0, #0x2, [W15]
0015DA  320008     BRA Z, 0x15EC
0015DC  E00000     CP0 W0
0015DE  3A000A     BRA NZ, 0x15F4
692:               		case 0:lcd_disp_chr_loc_0_ex(code);break;
0015E0  78001E     MOV [W14], W0
0015E2  07FD60     RCALL lcd_disp_chr_loc_0_ex
0015E4  370008     BRA 0x15F6
693:               		case 1:lcd_disp_chr_loc_1_ex(code);break;
0015E6  78001E     MOV [W14], W0
0015E8  07FDA9     RCALL lcd_disp_chr_loc_1_ex
0015EA  370005     BRA 0x15F6
694:               		case 2:lcd_disp_chr_loc_2_ex(code);break;
0015EC  78001E     MOV [W14], W0
0015EE  07FDF2     RCALL lcd_disp_chr_loc_2_ex
0015F0  000000     NOP
0015F2  370001     BRA 0x15F6
695:               		default:break;
0015F4  000000     NOP
696:               	}		
697:               }
0015F6  FA8000     ULNK
0015F8  060000     RETURN
698:               void lcd_show_string_sm(uint8_t* str)
699:               {
0015FA  FA0004     LNK #0x4
0015FC  980710     MOV W0, [W14+2]
700:               	uint8_t t8=0;
0015FE  EB4000     CLR.B W0
001600  784F00     MOV.B W0, [W14]
701:               	while(*str!='\0' && t8<3){
001602  370009     BRA 0x1616
001616  90001E     MOV [W14+2], W0
001618  784010     MOV.B [W0], W0
00161A  E00400     CP0.B W0
00161C  320003     BRA Z, 0x1624
00161E  78401E     MOV.B [W14], W0
001620  504FE2     SUB.B W0, #0x2, [W15]
001622  36FFF0     BRA LEU, 0x1604
702:               		lcd_show_chr_sm(t8,*str);
001604  90001E     MOV [W14+2], W0
001606  784010     MOV.B [W0], W0
001608  784080     MOV.B W0, W1
00160A  78401E     MOV.B [W14], W0
00160C  07FFC0     RCALL lcd_show_chr_sm
703:               		str++;
00160E  90001E     MOV [W14+2], W0
001610  E80000     INC W0, W0
001612  980710     MOV W0, [W14+2]
704:               		t8++;
001614  E84F1E     INC.B [W14], [W14]
705:               	}
706:               }
001624  FA8000     ULNK
001626  060000     RETURN
707:               void lcd_show_string_ex(uint8_t* str)
708:               {
001628  FA0004     LNK #0x4
00162A  980710     MOV W0, [W14+2]
709:               	uint8_t t8=0;
00162C  EB4000     CLR.B W0
00162E  784F00     MOV.B W0, [W14]
710:               	while(*str!='\0' && t8<3){
001630  370009     BRA 0x1644
001644  90001E     MOV [W14+2], W0
001646  784010     MOV.B [W0], W0
001648  E00400     CP0.B W0
00164A  320003     BRA Z, 0x1652
00164C  78401E     MOV.B [W14], W0
00164E  504FE2     SUB.B W0, #0x2, [W15]
001650  36FFF0     BRA LEU, 0x1632
711:               		lcd_show_chr_ex(t8,*str);
001632  90001E     MOV [W14+2], W0
001634  784010     MOV.B [W0], W0
001636  784080     MOV.B W0, W1
001638  78401E     MOV.B [W14], W0
00163A  07FFC4     RCALL lcd_show_chr_ex
712:               		str++;
00163C  90001E     MOV [W14+2], W0
00163E  E80000     INC W0, W0
001640  980710     MOV W0, [W14+2]
713:               		t8++;
001642  E84F1E     INC.B [W14], [W14]
714:               	}
715:               }
001652  FA8000     ULNK
001654  060000     RETURN
716:               //line col.
717:               void lcd_show_chr_lc(uint8_t line,uint8_t col,uint8_t chr)
718:               {
001656  FA0006     LNK #0x6
001658  984720     MOV.B W0, [W14+2]
00165A  984731     MOV.B W1, [W14+3]
00165C  984742     MOV.B W2, [W14+4]
719:               	uint8_t loc;
720:               	if(line>1)return;
00165E  90402E     MOV.B [W14+2], W0
001660  504FE1     SUB.B W0, #0x1, [W15]
001662  3E000C     BRA GTU, 0x167C
00167C  000000     NOP
00167E  370001     BRA 0x1682
721:               	if(col>3)return;
001664  90403E     MOV.B [W14+3], W0
001666  504FE3     SUB.B W0, #0x3, [W15]
001668  3E000B     BRA GTU, 0x1680
001680  000000     NOP
722:               	loc=(line<<1)+col;
00166A  90402E     MOV.B [W14+2], W0
00166C  404000     ADD.B W0, W0, W0
00166E  784080     MOV.B W0, W1
001670  90403E     MOV.B [W14+3], W0
001672  40CF00     ADD.B W1, W0, [W14]
723:               	lcd_show_chr(loc,chr);
001674  9040CE     MOV.B [W14+4], W1
001676  78401E     MOV.B [W14], W0
001678  07FF54     RCALL lcd_show_chr
00167A  370003     BRA 0x1682
724:               }
001682  FA8000     ULNK
001684  060000     RETURN
725:               
726:               void lcd_show_string_l0(uint8_t* str)
727:               {
001686  FA0004     LNK #0x4
001688  980710     MOV W0, [W14+2]
728:               	uint8_t t8=0;
00168A  EB4000     CLR.B W0
00168C  784F00     MOV.B W0, [W14]
729:               	while(*str!='\0' && t8<4){
00168E  370009     BRA 0x16A2
0016A2  90001E     MOV [W14+2], W0
0016A4  784010     MOV.B [W0], W0
0016A6  E00400     CP0.B W0
0016A8  320003     BRA Z, 0x16B0
0016AA  78401E     MOV.B [W14], W0
0016AC  504FE3     SUB.B W0, #0x3, [W15]
0016AE  36FFF0     BRA LEU, 0x1690
730:               		lcd_show_chr(t8,*str);
001690  90001E     MOV [W14+2], W0
001692  784010     MOV.B [W0], W0
001694  784080     MOV.B W0, W1
001696  78401E     MOV.B [W14], W0
001698  07FF44     RCALL lcd_show_chr
731:               		str++;
00169A  90001E     MOV [W14+2], W0
00169C  E80000     INC W0, W0
00169E  980710     MOV W0, [W14+2]
732:               		t8++;
0016A0  E84F1E     INC.B [W14], [W14]
733:               	}
734:               }
0016B0  FA8000     ULNK
0016B2  060000     RETURN
735:               
736:               void lcd_show_string_l1(uint8_t* str)
737:               {
0016B4  FA0004     LNK #0x4
0016B6  980710     MOV W0, [W14+2]
738:               	uint8_t t8=0;
0016B8  EB4000     CLR.B W0
0016BA  784F00     MOV.B W0, [W14]
739:               	while(*str!='\0' && t8<4){
0016BC  370009     BRA 0x16D0
0016D0  90001E     MOV [W14+2], W0
0016D2  784010     MOV.B [W0], W0
0016D4  E00400     CP0.B W0
0016D6  320003     BRA Z, 0x16DE
0016D8  78401E     MOV.B [W14], W0
0016DA  504FE3     SUB.B W0, #0x3, [W15]
0016DC  36FFF0     BRA LEU, 0x16BE
740:               		lcd_show_chr(t8+4,*str);
0016BE  90001E     MOV [W14+2], W0
0016C0  784090     MOV.B [W0], W1
0016C2  78411E     MOV.B [W14], W2
0016C4  414064     ADD.B W2, #0x4, W0
0016C6  07FF2D     RCALL lcd_show_chr
741:               		str++;
0016C8  90001E     MOV [W14+2], W0
0016CA  E80000     INC W0, W0
0016CC  980710     MOV W0, [W14+2]
742:               		t8++;
0016CE  E84F1E     INC.B [W14], [W14]
743:               	}
744:               }
0016DE  FA8000     ULNK
0016E0  060000     RETURN
745:               
746:               void lcd_show_string(uint8_t* str)
747:               {
0016E2  FA0004     LNK #0x4
0016E4  980710     MOV W0, [W14+2]
748:               	uint8_t t8=0;
0016E6  EB4000     CLR.B W0
0016E8  784F00     MOV.B W0, [W14]
749:               	while(*str!='\0' && t8<8){
0016EA  370009     BRA 0x16FE
0016FE  90001E     MOV [W14+2], W0
001700  784010     MOV.B [W0], W0
001702  E00400     CP0.B W0
001704  320003     BRA Z, 0x170C
001706  78401E     MOV.B [W14], W0
001708  504FE7     SUB.B W0, #0x7, [W15]
00170A  36FFF0     BRA LEU, 0x16EC
750:               		lcd_show_chr(t8,*str);
0016EC  90001E     MOV [W14+2], W0
0016EE  784010     MOV.B [W0], W0
0016F0  784080     MOV.B W0, W1
0016F2  78401E     MOV.B [W14], W0
0016F4  07FF16     RCALL lcd_show_chr
751:               		str++;
0016F6  90001E     MOV [W14+2], W0
0016F8  E80000     INC W0, W0
0016FA  980710     MOV W0, [W14+2]
752:               		t8++;
0016FC  E84F1E     INC.B [W14], [W14]
753:               	}
754:               }
00170C  FA8000     ULNK
00170E  060000     RETURN
755:               
756:               
757:               
758:               void lcd_disp_refresh(void)
759:               {
001710  FA0000     LNK #0x0
760:               	//m_mem_cpy_len(pLcdReg,pLCD,LCD_PIXEL_REGISTER_SIZE);
761:               	LCDDATA0=pLCD[0];
001712  804900     MOV pLCD, W0
001714  882C80     MOV W0, LCDDATA0
762:               	LCDDATA1=pLCD[1];
001716  804910     MOV 0x922, W0
001718  882C90     MOV W0, LCDDATA1
763:               	LCDDATA2=pLCD[2];
00171A  804920     MOV 0x924, W0
00171C  882CA0     MOV W0, LCDDATA2
764:               	LCDDATA3=pLCD[3];
00171E  804930     MOV 0x926, W0
001720  882CB0     MOV W0, LCDDATA3
765:               	LCDDATA4=pLCD[4];
001722  804940     MOV _lcd_disp_battary_bar, W0
001724  882CC0     MOV W0, LCDDATA4
766:               	LCDDATA5=pLCD[5];
001726  804950     MOV 0x92A, W0
001728  882CD0     MOV W0, LCDDATA5
767:               	LCDDATA6=pLCD[6];
00172A  804960     MOV 0x92C, W0
00172C  882CE0     MOV W0, LCDDATA6
768:               	LCDDATA7=pLCD[7];
00172E  804970     MOV 0x92E, W0
001730  882CF0     MOV W0, LCDDATA7
769:               	LCDDATA8=pLCD[8];
001732  804980     MOV 0x930, W0
001734  882D00     MOV W0, LCDDATA8
770:               	LCDDATA9=pLCD[9];
001736  804990     MOV 0x932, W0
001738  882D10     MOV W0, LCDDATA9
771:               	
772:               	LCDDATA10=pLCD[10];
00173A  8049A0     MOV 0x934, W0
00173C  882D20     MOV W0, LCDDATA10
773:               	LCDDATA11=pLCD[11];
00173E  8049B0     MOV 0x936, W0
001740  882D30     MOV W0, LCDDATA11
774:               	LCDDATA12=pLCD[12];
001742  8049C0     MOV 0x938, W0
001744  882D40     MOV W0, LCDDATA12
775:               	LCDDATA13=pLCD[13];
001746  8049D0     MOV 0x93A, W0
001748  882D50     MOV W0, LCDDATA13
776:               	LCDDATA14=pLCD[14];
00174A  8049E0     MOV 0x93C, W0
00174C  882D60     MOV W0, LCDDATA14
777:               	LCDDATA15=pLCD[15];
00174E  8049F0     MOV 0x93E, W0
001750  882D70     MOV W0, LCDDATA15
778:               	LCDDATA16=pLCD[16];
001752  804A00     MOV 0x940, W0
001754  882D80     MOV W0, LCDDATA16
779:               	LCDDATA17=pLCD[17];
001756  804A10     MOV 0x942, W0
001758  882D90     MOV W0, LCDDATA17
780:               	LCDDATA18=pLCD[18];
00175A  804A20     MOV 0x944, W0
00175C  882DA0     MOV W0, LCDDATA18
781:               	LCDDATA19=pLCD[19];
00175E  804A30     MOV 0x946, W0
001760  882DB0     MOV W0, LCDDATA19
782:               	
783:               	LCDDATA20=pLCD[20];	
001762  804A40     MOV 0x948, W0
001764  882DC0     MOV W0, LCDDATA20
784:               	LCDDATA21=pLCD[21];
001766  804A50     MOV 0x94A, W0
001768  882DD0     MOV W0, LCDDATA21
785:               	LCDDATA22=pLCD[22];
00176A  804A60     MOV 0x94C, W0
00176C  882DE0     MOV W0, LCDDATA22
786:               	LCDDATA23=pLCD[23];
00176E  804A70     MOV 0x94E, W0
001770  882DF0     MOV W0, LCDDATA23
787:               	
788:               	LCDDATA24=pLCD[24];	
001772  804A80     MOV 0x950, W0
001774  882E00     MOV W0, LCDDATA24
789:               	LCDDATA25=pLCD[25];
001776  804A90     MOV 0x952, W0
001778  882E10     MOV W0, LCDDATA25
790:               	LCDDATA26=pLCD[26];
00177A  804AA0     MOV 0x954, W0
00177C  882E20     MOV W0, LCDDATA26
791:               	LCDDATA27=pLCD[27];	
00177E  804AB0     MOV 0x956, W0
001780  882E30     MOV W0, LCDDATA27
792:               	
793:               	LCDDATA28=pLCD[28];	
001782  804AC0     MOV 0x958, W0
001784  882E40     MOV W0, LCDDATA28
794:               	LCDDATA29=pLCD[29];
001786  804AD0     MOV 0x95A, W0
001788  882E50     MOV W0, LCDDATA29
795:               	LCDDATA30=pLCD[30];
00178A  804AE0     MOV 0x95C, W0
00178C  882E60     MOV W0, LCDDATA30
796:               	LCDDATA31=pLCD[31];		
00178E  804AF0     MOV 0x95E, W0
001790  882E70     MOV W0, LCDDATA31
797:               }
001792  FA8000     ULNK
001794  060000     RETURN
798:               
799:               void lcd_disp_all(uint16_t x)
800:               {
001796  FA0004     LNK #0x4
001798  980710     MOV W0, [W14+2]
801:                   uint8_t i;
802:                   for(i=0;i<LCD_PIXEL_REGISTER_SIZE;i++)
00179A  EB4000     CLR.B W0
00179C  784F00     MOV.B W0, [W14]
00179E  370007     BRA 0x17AE
0017AC  E84F1E     INC.B [W14], [W14]
0017AE  78401E     MOV.B [W14], W0
0017B0  504FFF     SUB.B W0, #0x1F, [W15]
0017B2  36FFF6     BRA LEU, 0x17A0
803:                   {
804:                       pLCD[i]=x;
0017A0  FB801E     ZE [W14], W0
0017A2  400080     ADD W0, W0, W1
0017A4  209200     MOV #0x920, W0
0017A6  408000     ADD W1, W0, W0
0017A8  90009E     MOV [W14+2], W1
0017AA  780801     MOV W1, [W0]
805:                   }
806:               	//lcd_disp_refresh();
807:               }
0017B4  FA8000     ULNK
0017B6  060000     RETURN
808:               
809:               void lcd_config(void)
810:               {
0017B8  FA0000     LNK #0x0
811:                   LCDCONbits.CS=0x00;
0017BA  802C21     MOV LCDCON, W1
0017BC  2FFE70     MOV #0xFFE7, W0
0017BE  608000     AND W1, W0, W0
0017C0  882C20     MOV W0, LCDCON
812:                   LCDCONbits.LCDSIDL=0;
0017C2  A9A585     BCLR 0x585, #5
813:                   LCDCONbits.SLPEN=0;
0017C4  A9C584     BCLR LCDCON, #6
814:                   LCDCONbits.WERR=0;
0017C6  A9A584     BCLR LCDCON, #5
815:                   LCDCONbits.LMUX=7;
0017C8  802C20     MOV LCDCON, W0
0017CA  B30070     IOR #0x7, W0
0017CC  882C20     MOV W0, LCDCON
816:                   
817:                   LCDREGbits.CPEN=1;
0017CE  A8E581     BSET 0x581, #7
818:                   LCDREGbits.BIAS=5;
0017D0  802C01     MOV LCDREG, W1
0017D2  2FFC70     MOV #0xFFC7, W0
0017D4  608080     AND W1, W0, W1
0017D6  200280     MOV #0x28, W0
0017D8  700001     IOR W0, W1, W0
0017DA  882C00     MOV W0, LCDREG
819:                   LCDREGbits.CKSEL=2;
0017DC  802C01     MOV LCDREG, W1
0017DE  2FFFC0     MOV #0xFFFC, W0
0017E0  608000     AND W1, W0, W0
0017E2  A01000     BSET W0, #1
0017E4  882C00     MOV W0, LCDREG
820:                   LCDREGbits.MODE13=1;
0017E6  A84580     BSET LCDREG, #2
821:                   
822:                   LCDPSbits.BIASMD=0;
0017E8  A9C586     BCLR LCDPS, #6
823:                   LCDPSbits.LP=3;
0017EA  802C31     MOV LCDPS, W1
0017EC  2FFF00     MOV #0xFFF0, W0
0017EE  608000     AND W1, W0, W0
0017F0  B30030     IOR #0x3, W0
0017F2  882C30     MOV W0, LCDPS
824:                   
825:                   LCDREFbits.LCDIRE=1;
0017F4  A8E583     BSET 0x583, #7
826:                   LCDREFbits.LCDCST=3;
0017F6  802C11     MOV LCDREF, W1
0017F8  2C7FF0     MOV #0xC7FF, W0
0017FA  608080     AND W1, W0, W1
0017FC  218000     MOV #0x1800, W0
0017FE  700001     IOR W0, W1, W0
001800  882C10     MOV W0, LCDREF
827:                   LCDREFbits.VLCD1PE=0;
001802  A90583     BCLR 0x583, #0
828:                   LCDREFbits.VLCD2PE=0;
001804  A92583     BCLR 0x583, #1
829:                   LCDREFbits.VLCD3PE=0;
001806  A94583     BCLR 0x583, #2
830:                   
831:                   LCDREFbits.LRLAP=3;
001808  802C11     MOV LCDREF, W1
00180A  200C00     MOV #0xC0, W0
00180C  700001     IOR W0, W1, W0
00180E  882C10     MOV W0, LCDREF
832:                   LCDREFbits.LRLBP=3;
001810  802C11     MOV LCDREF, W1
001812  200300     MOV #0x30, W0
001814  700001     IOR W0, W1, W0
001816  882C10     MOV W0, LCDREF
833:                   LCDREFbits.LRLAT=0;
001818  802C11     MOV LCDREF, W1
00181A  2FFF80     MOV #0xFFF8, W0
00181C  608000     AND W1, W0, W0
00181E  882C10     MOV W0, LCDREF
834:                   
835:                   
836:               
837:               	// TRISDbits.TRISD0=0;//debug
838:               	LCDSE0 = 0b0001111100010000;
001820  21F100     MOV #0x1F10, W0
001822  882C40     MOV W0, LCDSE0
839:               	LCDSE1 = 0b0000000000001100;
001824  2000C0     MOV #0xC, W0
001826  882C50     MOV W0, LCDSE1
840:               	LCDSE2 = 0b1100001111001100;
001828  2C3CC0     MOV #0xC3CC, W0
00182A  882C60     MOV W0, LCDSE2
841:               	LCDSE3 = 0b1111110010000110; // Disable Seg30, Seg28 and Seg27
00182C  2FC860     MOV #0xFC86, W0
00182E  882C70     MOV W0, LCDSE3
842:               	//LCDSE4 = 0b11111110; // Disable unused segments
843:               	//LCDSE5 = 0b11001111; // Disable unused segments
844:               
845:               	//clear all pixel data
846:                   lcd_disp_all(0xffff);
001830  EB8000     SETM W0
001832  07FFB1     RCALL lcd_disp_all
847:                   lcd_disp_refresh();
001834  07FF6D     RCALL lcd_disp_refresh
848:               	//lcd_clear_all();
849:               	//config reference voltage
850:               
851:               	//lcd_on();
852:               }
001836  FA8000     ULNK
001838  060000     RETURN
853:               void lcd_bl_on(void)
854:               {
00183A  FA0000     LNK #0x0
855:                   /*
856:                   set_portg_mode_out(PIN4);
857:                   RTCCFGbits.RTCOE=1;
858:                   set_portg_value_hight(PIN4);
859:                   blackEn=true;
860:                    * */
861:               }
00183C  FA8000     ULNK
00183E  060000     RETURN
862:               
863:               void lcd_bl_off(void)
864:               {
001840  FA0000     LNK #0x0
865:                   /*
866:                   set_portg_mode_in(PIN4);
867:                    RTCCFGbits.RTCOE=0;
868:                   // set_portg_value_hight(PIN4);
869:                    blackEn=false;
870:                    * */
871:               }
001842  FA8000     ULNK
001844  060000     RETURN
872:               
873:               void lcd_bl_init(void)
874:               {
001846  FA0000     LNK #0x0
875:               	set_portg_mode_out(PIN4);
001848  801780     MOV TRISG, W0
00184A  A14000     BCLR W0, #4
00184C  881780     MOV W0, TRISG
876:               	set_portg_value_hight(PIN4);
00184E  8017A0     MOV LATG, W0
001850  A04000     BSET W0, #4
001852  8817A0     MOV W0, LATG
877:               }
001854  FA8000     ULNK
001856  060000     RETURN
878:               void lcd_init(void)
879:               {
001858  FA0000     LNK #0x0
880:               	lcd_config();
00185A  07FFAE     RCALL lcd_config
881:               	//lcd_bl_init();
882:               	lcd_on();
00185C  A8E585     BSET 0x585, #7
883:                   kz_vadd_on();
00185E  070D06     RCALL kz_vadd_on
884:                   back_night_on();
001860  070D1D     RCALL back_night_on
885:               	//lcd_bl_on();
886:               	/*
887:                   if(blackEn){
888:                       lcd_bl_on();
889:                   }
890:                   else{
891:                       lcd_bl_off();
892:                   }
893:               	*/
894:               }
001862  FA8000     ULNK
001864  060000     RETURN
895:               //file end
---  F:/2017/cs66-b/cs66b.X/src/driver/i2c.c  -----------------------------------------------------------
1:                 #include "drivers.h"
2:                 #include "../soc/delay.h"
3:                 #include "../global/globle.h"
4:                 #define __nop_delay() do{ \
5:                 __nop();__nop();__nop();__nop();__nop(); \
6:                 __nop();__nop();__nop();__nop();__nop(); \
7:                 }while(0);
8:                 
9:                 
10:                void iic_start(void)
11:                {
0029F8  FA0000     LNK #0x0
12:                	iic_scl_mode_out();
0029FA  802730     MOV ANSD, W0
0029FC  A10000     BCLR W0, #0
0029FE  882730     MOV W0, ANSD
002A00  8016C0     MOV TRISD, W0
002A02  A10000     BCLR W0, #0
002A04  8816C0     MOV W0, TRISD
13:                	iic_sda_mode_out();
002A06  802730     MOV ANSD, W0
002A08  A1B000     BCLR W0, #11
002A0A  882730     MOV W0, ANSD
002A0C  8016C0     MOV TRISD, W0
002A0E  A1B000     BCLR W0, #11
002A10  8816C0     MOV W0, TRISD
14:                    
15:                	iic_sda_hight();
002A12  8016E0     MOV LATD, W0
002A14  A0B000     BSET W0, #11
002A16  8816E0     MOV W0, LATD
16:                	iic_scl_hight();
002A18  8016E0     MOV LATD, W0
002A1A  A00000     BSET W0, #0
002A1C  8816E0     MOV W0, LATD
17:                	delay_us(10);
002A1E  2000A0     MOV #0xA, W0
002A20  070482     RCALL delay_us
18:                	iic_sda_low();
002A22  8016E0     MOV LATD, W0
002A24  A1B000     BCLR W0, #11
002A26  8816E0     MOV W0, LATD
19:                	delay_us(10);
002A28  2000A0     MOV #0xA, W0
002A2A  07047D     RCALL delay_us
20:                	iic_scl_low();
002A2C  8016E0     MOV LATD, W0
002A2E  A10000     BCLR W0, #0
002A30  8816E0     MOV W0, LATD
21:                	delay_us(10);
002A32  2000A0     MOV #0xA, W0
002A34  070478     RCALL delay_us
22:                }
002A36  FA8000     ULNK
002A38  060000     RETURN
23:                
24:                void iic_stop(void)
25:                {
002A3A  FA0000     LNK #0x0
26:                	iic_scl_mode_out();
002A3C  802730     MOV ANSD, W0
002A3E  A10000     BCLR W0, #0
002A40  882730     MOV W0, ANSD
002A42  8016C0     MOV TRISD, W0
002A44  A10000     BCLR W0, #0
002A46  8816C0     MOV W0, TRISD
27:                	iic_sda_mode_out();
002A48  802730     MOV ANSD, W0
002A4A  A1B000     BCLR W0, #11
002A4C  882730     MOV W0, ANSD
002A4E  8016C0     MOV TRISD, W0
002A50  A1B000     BCLR W0, #11
002A52  8816C0     MOV W0, TRISD
28:                	iic_sda_low();
002A54  8016E0     MOV LATD, W0
002A56  A1B000     BCLR W0, #11
002A58  8816E0     MOV W0, LATD
29:                	delay_us(10);
002A5A  2000A0     MOV #0xA, W0
002A5C  070464     RCALL delay_us
30:                	iic_scl_hight();
002A5E  8016E0     MOV LATD, W0
002A60  A00000     BSET W0, #0
002A62  8816E0     MOV W0, LATD
31:                	delay_us(10);
002A64  2000A0     MOV #0xA, W0
002A66  07045F     RCALL delay_us
32:                	iic_sda_hight();
002A68  8016E0     MOV LATD, W0
002A6A  A0B000     BSET W0, #11
002A6C  8816E0     MOV W0, LATD
33:                	delay_us(10);
002A6E  2000A0     MOV #0xA, W0
002A70  07045A     RCALL delay_us
34:                }
002A72  FA8000     ULNK
002A74  060000     RETURN
35:                
36:                void iic_send_ack(int8_t ack)
37:                {
002A76  FA0002     LNK #0x2
002A78  784F00     MOV.B W0, [W14]
38:                	iic_scl_mode_out();
002A7A  802730     MOV ANSD, W0
002A7C  A10000     BCLR W0, #0
002A7E  882730     MOV W0, ANSD
002A80  8016C0     MOV TRISD, W0
002A82  A10000     BCLR W0, #0
002A84  8816C0     MOV W0, TRISD
39:                	iic_sda_mode_out();
002A86  802730     MOV ANSD, W0
002A88  A1B000     BCLR W0, #11
002A8A  882730     MOV W0, ANSD
002A8C  8016C0     MOV TRISD, W0
002A8E  A1B000     BCLR W0, #11
002A90  8816C0     MOV W0, TRISD
40:                	iic_scl_low();
002A92  8016E0     MOV LATD, W0
002A94  A10000     BCLR W0, #0
002A96  8816E0     MOV W0, LATD
41:                	__nop_delay();
002A98  000000     NOP
002A9A  000000     NOP
002A9C  000000     NOP
002A9E  000000     NOP
002AA0  000000     NOP
002AA2  000000     NOP
002AA4  000000     NOP
002AA6  000000     NOP
002AA8  000000     NOP
002AAA  000000     NOP
42:                	if(ack){
002AAC  78401E     MOV.B [W14], W0
002AAE  E00400     CP0.B W0
002AB0  320004     BRA Z, 0x2ABA
43:                		iic_sda_hight();
002AB2  8016E0     MOV LATD, W0
002AB4  A0B000     BSET W0, #11
002AB6  8816E0     MOV W0, LATD
002AB8  370003     BRA 0x2AC0
44:                	}else{
45:                		iic_sda_low();
002ABA  8016E0     MOV LATD, W0
002ABC  A1B000     BCLR W0, #11
002ABE  8816E0     MOV W0, LATD
46:                	}
47:                	__nop_delay();
002AC0  000000     NOP
002AC2  000000     NOP
002AC4  000000     NOP
002AC6  000000     NOP
002AC8  000000     NOP
002ACA  000000     NOP
002ACC  000000     NOP
002ACE  000000     NOP
002AD0  000000     NOP
002AD2  000000     NOP
48:                	iic_scl_hight();
002AD4  8016E0     MOV LATD, W0
002AD6  A00000     BSET W0, #0
002AD8  8816E0     MOV W0, LATD
49:                	__nop_delay();
002ADA  000000     NOP
002ADC  000000     NOP
002ADE  000000     NOP
002AE0  000000     NOP
002AE2  000000     NOP
002AE4  000000     NOP
002AE6  000000     NOP
002AE8  000000     NOP
002AEA  000000     NOP
002AEC  000000     NOP
50:                	iic_scl_low();
002AEE  8016E0     MOV LATD, W0
002AF0  A10000     BCLR W0, #0
002AF2  8816E0     MOV W0, LATD
51:                	__nop_delay();
002AF4  000000     NOP
002AF6  000000     NOP
002AF8  000000     NOP
002AFA  000000     NOP
002AFC  000000     NOP
002AFE  000000     NOP
002B00  000000     NOP
002B02  000000     NOP
002B04  000000     NOP
002B06  000000     NOP
52:                }
002B08  FA8000     ULNK
002B0A  060000     RETURN
53:                
54:                uint8_t iic_waite_ack(void)
55:                {
002B0C  FA0002     LNK #0x2
56:                	uint8_t timeout=200;
002B0E  B3CC80     MOV.B #0xC8, W0
002B10  784F00     MOV.B W0, [W14]
57:                	iic_scl_mode_out();
002B12  802730     MOV ANSD, W0
002B14  A10000     BCLR W0, #0
002B16  882730     MOV W0, ANSD
002B18  8016C0     MOV TRISD, W0
002B1A  A10000     BCLR W0, #0
002B1C  8816C0     MOV W0, TRISD
58:                	iic_sda_mode_in();
002B1E  802730     MOV ANSD, W0
002B20  A1B000     BCLR W0, #11
002B22  882730     MOV W0, ANSD
002B24  8016C0     MOV TRISD, W0
002B26  A0B000     BSET W0, #11
002B28  8816C0     MOV W0, TRISD
59:                    iic_scl_low();
002B2A  8016E0     MOV LATD, W0
002B2C  A10000     BCLR W0, #0
002B2E  8816E0     MOV W0, LATD
60:                    __nop_delay();
002B30  000000     NOP
002B32  000000     NOP
002B34  000000     NOP
002B36  000000     NOP
002B38  000000     NOP
002B3A  000000     NOP
002B3C  000000     NOP
002B3E  000000     NOP
002B40  000000     NOP
002B42  000000     NOP
61:                	iic_scl_hight();
002B44  8016E0     MOV LATD, W0
002B46  A00000     BSET W0, #0
002B48  8816E0     MOV W0, LATD
62:                    __nop_delay();
002B4A  000000     NOP
002B4C  000000     NOP
002B4E  000000     NOP
002B50  000000     NOP
002B52  000000     NOP
002B54  000000     NOP
002B56  000000     NOP
002B58  000000     NOP
002B5A  000000     NOP
002B5C  000000     NOP
63:                	while(timeout--){
002B5E  370005     BRA 0x2B6A
002B6A  FB801E     ZE [W14], W0
002B6C  EA0000     NEG W0, W0
002B6E  DE004F     LSR W0, #15, W0
002B70  784000     MOV.B W0, W0
002B72  E94F1E     DEC.B [W14], [W14]
002B74  E00400     CP0.B W0
002B76  3AFFF4     BRA NZ, 0x2B60
002B78  370001     BRA 0x2B7C
64:                		if(!iic_sda_get())break;
002B60  8016D1     MOV PORTD, W1
002B62  208000     MOV #0x800, W0
002B64  608000     AND W1, W0, W0
002B66  E00000     CP0 W0
002B68  320008     BRA Z, 0x2B7A
002B7A  000000     NOP
65:                	}
66:                	if(!timeout){
002B7C  78401E     MOV.B [W14], W0
002B7E  E00400     CP0.B W0
002B80  3A0003     BRA NZ, 0x2B88
67:                		iic_stop();
002B82  07FF5B     RCALL iic_stop
68:                		return 0;
002B84  EB4000     CLR.B W0
002B86  37000E     BRA 0x2BA4
69:                	}
70:                	iic_scl_low();
002B88  8016E0     MOV LATD, W0
002B8A  A10000     BCLR W0, #0
002B8C  8816E0     MOV W0, LATD
71:                    __nop_delay();
002B8E  000000     NOP
002B90  000000     NOP
002B92  000000     NOP
002B94  000000     NOP
002B96  000000     NOP
002B98  000000     NOP
002B9A  000000     NOP
002B9C  000000     NOP
002B9E  000000     NOP
002BA0  000000     NOP
72:                	return 1;	
002BA2  B3C010     MOV.B #0x1, W0
73:                }
002BA4  FA8000     ULNK
002BA6  060000     RETURN
74:                
75:                uint8_t iic_send_byte(uint8_t x)
76:                {
002BA8  FA0004     LNK #0x4
002BAA  984720     MOV.B W0, [W14+2]
77:                	uint8_t i;
78:                    iic_scl_mode_out();
002BAC  802730     MOV ANSD, W0
002BAE  A10000     BCLR W0, #0
002BB0  882730     MOV W0, ANSD
002BB2  8016C0     MOV TRISD, W0
002BB4  A10000     BCLR W0, #0
002BB6  8816C0     MOV W0, TRISD
79:                	iic_sda_mode_out();
002BB8  802730     MOV ANSD, W0
002BBA  A1B000     BCLR W0, #11
002BBC  882730     MOV W0, ANSD
002BBE  8016C0     MOV TRISD, W0
002BC0  A1B000     BCLR W0, #11
002BC2  8816C0     MOV W0, TRISD
80:                	iic_scl_low();
002BC4  8016E0     MOV LATD, W0
002BC6  A10000     BCLR W0, #0
002BC8  8816E0     MOV W0, LATD
81:                	__nop_delay();
002BCA  000000     NOP
002BCC  000000     NOP
002BCE  000000     NOP
002BD0  000000     NOP
002BD2  000000     NOP
002BD4  000000     NOP
002BD6  000000     NOP
002BD8  000000     NOP
002BDA  000000     NOP
002BDC  000000     NOP
82:                	for(i=0;i<8;i++){       
002BDE  EB4000     CLR.B W0
002BE0  784F00     MOV.B W0, [W14]
002BE2  370032     BRA 0x2C48
002C46  E84F1E     INC.B [W14], [W14]
002C48  78401E     MOV.B [W14], W0
002C4A  504FE7     SUB.B W0, #0x7, [W15]
002C4C  36FFCB     BRA LEU, 0x2BE4
83:                		if(x&0x80){
002BE4  90402E     MOV.B [W14+2], W0
002BE6  E00400     CP0.B W0
002BE8  3D0004     BRA GE, 0x2BF2
84:                			iic_sda_hight();
002BEA  8016E0     MOV LATD, W0
002BEC  A0B000     BSET W0, #11
002BEE  8816E0     MOV W0, LATD
002BF0  370003     BRA 0x2BF8
85:                        }
86:                		else{
87:                			iic_sda_low();
002BF2  8016E0     MOV LATD, W0
002BF4  A1B000     BCLR W0, #11
002BF6  8816E0     MOV W0, LATD
88:                        }
89:                		__nop_delay();
002BF8  000000     NOP
002BFA  000000     NOP
002BFC  000000     NOP
002BFE  000000     NOP
002C00  000000     NOP
002C02  000000     NOP
002C04  000000     NOP
002C06  000000     NOP
002C08  000000     NOP
002C0A  000000     NOP
90:                		iic_scl_hight();
002C0C  8016E0     MOV LATD, W0
002C0E  A00000     BSET W0, #0
002C10  8816E0     MOV W0, LATD
91:                		//__nop_delay();
92:                        __nop_delay();
002C12  000000     NOP
002C14  000000     NOP
002C16  000000     NOP
002C18  000000     NOP
002C1A  000000     NOP
002C1C  000000     NOP
002C1E  000000     NOP
002C20  000000     NOP
002C22  000000     NOP
002C24  000000     NOP
93:                		iic_scl_low();
002C26  8016E0     MOV LATD, W0
002C28  A10000     BCLR W0, #0
002C2A  8816E0     MOV W0, LATD
94:                        //__nop_delay();
95:                        __nop_delay();
002C2C  000000     NOP
002C2E  000000     NOP
002C30  000000     NOP
002C32  000000     NOP
002C34  000000     NOP
002C36  000000     NOP
002C38  000000     NOP
002C3A  000000     NOP
002C3C  000000     NOP
002C3E  000000     NOP
96:                		x<<=1;
002C40  90402E     MOV.B [W14+2], W0
002C42  404000     ADD.B W0, W0, W0
002C44  984720     MOV.B W0, [W14+2]
97:                	}
98:                	return iic_waite_ack();
002C4E  07FF5E     RCALL iic_waite_ack
99:                }
002C50  FA8000     ULNK
002C52  060000     RETURN
100:               
101:               uint8_t iic_received_byte(void)
102:               {
002C54  FA0002     LNK #0x2
103:               	uint8_t i;
104:               	uint8_t ret=0;
002C56  EB4000     CLR.B W0
002C58  984710     MOV.B W0, [W14+1]
105:               	iic_scl_mode_out();
002C5A  802730     MOV ANSD, W0
002C5C  A10000     BCLR W0, #0
002C5E  882730     MOV W0, ANSD
002C60  8016C0     MOV TRISD, W0
002C62  A10000     BCLR W0, #0
002C64  8816C0     MOV W0, TRISD
106:               	iic_sda_mode_in();//iic_sda_mode_in();
002C66  802730     MOV ANSD, W0
002C68  A1B000     BCLR W0, #11
002C6A  882730     MOV W0, ANSD
002C6C  8016C0     MOV TRISD, W0
002C6E  A0B000     BSET W0, #11
002C70  8816C0     MOV W0, TRISD
107:               	for(i=0;i<8;i++){
002C72  EB4000     CLR.B W0
002C74  784F00     MOV.B W0, [W14]
002C76  370026     BRA 0x2CC4
002CC2  E84F1E     INC.B [W14], [W14]
002CC4  78401E     MOV.B [W14], W0
002CC6  504FE7     SUB.B W0, #0x7, [W15]
002CC8  36FFD7     BRA LEU, 0x2C78
108:                       ret<<=1;
002C78  90401E     MOV.B [W14+1], W0
002C7A  404000     ADD.B W0, W0, W0
002C7C  984710     MOV.B W0, [W14+1]
109:               		iic_scl_low();
002C7E  8016E0     MOV LATD, W0
002C80  A10000     BCLR W0, #0
002C82  8816E0     MOV W0, LATD
110:                       __nop_delay();
002C84  000000     NOP
002C86  000000     NOP
002C88  000000     NOP
002C8A  000000     NOP
002C8C  000000     NOP
002C8E  000000     NOP
002C90  000000     NOP
002C92  000000     NOP
002C94  000000     NOP
002C96  000000     NOP
111:               		iic_scl_hight();
002C98  8016E0     MOV LATD, W0
002C9A  A00000     BSET W0, #0
002C9C  8816E0     MOV W0, LATD
112:                       __nop_delay();
002C9E  000000     NOP
002CA0  000000     NOP
002CA2  000000     NOP
002CA4  000000     NOP
002CA6  000000     NOP
002CA8  000000     NOP
002CAA  000000     NOP
002CAC  000000     NOP
002CAE  000000     NOP
002CB0  000000     NOP
113:               		if(iic_sda_get()){
002CB2  8016D1     MOV PORTD, W1
002CB4  208000     MOV #0x800, W0
002CB6  608000     AND W1, W0, W0
002CB8  E00000     CP0 W0
002CBA  320003     BRA Z, 0x2CC2
114:               			ret|=1;
002CBC  90401E     MOV.B [W14+1], W0
002CBE  A00400     BSET.B W0, #0
002CC0  984710     MOV.B W0, [W14+1]
115:               		}
116:               	}
117:               	iic_scl_low();
002CCA  8016E0     MOV LATD, W0
002CCC  A10000     BCLR W0, #0
002CCE  8816E0     MOV W0, LATD
118:                   __nop_delay();
002CD0  000000     NOP
002CD2  000000     NOP
002CD4  000000     NOP
002CD6  000000     NOP
002CD8  000000     NOP
002CDA  000000     NOP
002CDC  000000     NOP
002CDE  000000     NOP
002CE0  000000     NOP
002CE2  000000     NOP
119:               	return ret;
002CE4  90401E     MOV.B [W14+1], W0
120:               }
002CE6  FA8000     ULNK
002CE8  060000     RETURN
121:               uint8_t iic_received_byte_if_ack(uint8_t ack)
122:               {
002CEA  FA0004     LNK #0x4
002CEC  984720     MOV.B W0, [W14+2]
123:               	uint8_t ret=0;
002CEE  EB4000     CLR.B W0
002CF0  784F00     MOV.B W0, [W14]
124:               	ret=iic_received_byte();
002CF2  07FFB0     RCALL iic_received_byte
002CF4  784F00     MOV.B W0, [W14]
125:               	iic_send_ack(ack);
002CF6  90402E     MOV.B [W14+2], W0
002CF8  07FEBE     RCALL iic_send_ack
126:               	return ret;
002CFA  78401E     MOV.B [W14], W0
127:               }
002CFC  FA8000     ULNK
002CFE  060000     RETURN
128:               /*
129:               uint8_t iic_read_byte(uint8_t slaveAddr,uint8_t addr)
130:               {
131:               	uint8_t ret;
132:               	//device must enable 
133:               	iic_start();
134:               	iic_send_byte(slaveAddr);
135:               	iic_send_byte(addr);
136:               	//
137:               	iic_start();
138:               	iic_send_byte(slaveAddr+1);
139:               	ret=iic_received_byte_if_ack(IIC_NACK);
140:               	iic_stop();
141:                   return ret;
142:               }
143:               
144:               void iic_write_byte(uint8_t slaveAddr,uint8_t addr,uint8_t x)
145:               {
146:               	iic_start();
147:               	iic_send_byte(slaveAddr);
148:               	iic_send_byte(addr);
149:               	
150:               	iic_send_byte(x);
151:               	iic_stop();	
152:               }
153:               
154:               void iic_write_n_byte(uint8_t slaveAddr,uint8_t addr,uint8_t* buf,uint16_t len)
155:               {
156:               	uint16_t i;
157:               	for(i=0;i<len;i++){
158:               		iic_start();
159:               		iic_send_byte(slaveAddr);
160:               		iic_send_byte(addr++);
161:               		
162:               		iic_send_byte(*buf++);
163:               		iic_stop();			
164:               	}
165:               }
166:               */
---  F:/2017/cs66-b/cs66b.X/src/driver/gpio.c  ----------------------------------------------------------
1:                 #include "gpio_config.h"
2:                 void kz_vadd_on(void)
3:                 {
00326C  FA0000     LNK #0x0
4:                 	set_portg_mode_dig(PIN9);
00326E  802760     MOV ANSG, W0
003270  A19000     BCLR W0, #9
003272  882760     MOV W0, ANSG
5:                 	set_portg_mode_out(PIN9);
003274  801780     MOV TRISG, W0
003276  A19000     BCLR W0, #9
003278  881780     MOV W0, TRISG
6:                 	set_portg_value_low(PIN9);
00327A  8017A0     MOV LATG, W0
00327C  A19000     BCLR W0, #9
00327E  8817A0     MOV W0, LATG
7:                 }
003280  FA8000     ULNK
003282  060000     RETURN
8:                 void kz_vadd_off(void)
9:                 {
003284  FA0000     LNK #0x0
10:                	set_portg_mode_dig(PIN9);
003286  802760     MOV ANSG, W0
003288  A19000     BCLR W0, #9
00328A  882760     MOV W0, ANSG
11:                	set_portg_mode_out(PIN9);
00328C  801780     MOV TRISG, W0
00328E  A19000     BCLR W0, #9
003290  881780     MOV W0, TRISG
12:                	set_portg_value_hight(PIN9);
003292  8017A0     MOV LATG, W0
003294  A09000     BSET W0, #9
003296  8817A0     MOV W0, LATG
13:                }
003298  FA8000     ULNK
00329A  060000     RETURN
14:                void back_night_on(void)
15:                {
00329C  FA0000     LNK #0x0
16:                	set_portb_mode_dig(PIN11);
00329E  802710     MOV ANSB, W0
0032A0  A1B000     BCLR W0, #11
0032A2  882710     MOV W0, ANSB
17:                	set_portb_mode_out(PIN11);
0032A4  801640     MOV TRISB, W0
0032A6  A1B000     BCLR W0, #11
0032A8  881640     MOV W0, TRISB
18:                	set_portb_value_hight(PIN11);
0032AA  801660     MOV LATB, W0
0032AC  A0B000     BSET W0, #11
0032AE  881660     MOV W0, LATB
19:                }
0032B0  FA8000     ULNK
0032B2  060000     RETURN
20:                void back_night_off(void)
21:                {
0032B4  FA0000     LNK #0x0
22:                	set_portb_mode_dig(PIN11);
0032B6  802710     MOV ANSB, W0
0032B8  A1B000     BCLR W0, #11
0032BA  882710     MOV W0, ANSB
23:                	set_portb_mode_out(PIN11);
0032BC  801640     MOV TRISB, W0
0032BE  A1B000     BCLR W0, #11
0032C0  881640     MOV W0, TRISB
24:                	set_portb_value_low(PIN11);
0032C2  801660     MOV LATB, W0
0032C4  A1B000     BCLR W0, #11
0032C6  881660     MOV W0, LATB
25:                }
0032C8  FA8000     ULNK
0032CA  060000     RETURN
---  F:/2017/cs66-b/cs66b.X/src/driver/ex_eeprom.c  -----------------------------------------------------
1:                 #include "drivers.h"
2:                 #include "../soc/delay.h"
3:                 st_iicDeviceObj at24c02Ch0,at24c02Ch1;
4:                 
5:                 void at24c02_set_slave_addr(st_iicDeviceObj* pAt24c02,uint8_t slv)
6:                 {
000000  040200     GOTO __resetPRI, __reset
000002  000000     NOP
7:                     if(!((void*)pAt24c02))return;
000006  000360     NOP
000008  000360     NOP
000014  000360     NOP
8:                     pAt24c02->slaveAddr=slv;
00000C  000360     NOP
00000E  000360     NOP
000010  000360     NOP
9:                 }
000016  000360     NOP
10:                
11:                void at24c02_init(st_iicDeviceObj* pAt24c02, uint8_t slv)
12:                {
00001A  0030B2     NOP
13:                    pAt24c02->slaveAddr=slv;
000020  000360     NOP
000022  002FE6     NOP
000024  000360     NOP
14:                	pAt24c02->iic_start=iic_start;
000026  000360     NOP
000028  000360     NOP
00002A  000360     NOP
15:                	pAt24c02->iic_stop=iic_stop;
00002C  000360     NOP
00002E  000360     NOP
000030  000360     NOP
16:                	pAt24c02->iic_send_byte=iic_send_byte;
000032  000360     NOP
17:                	//pAt24c02->iic_read_byte=iic_read_byte;
18:                	pAt24c02->iic_waite_ack=iic_waite_ack;
000038  000360     NOP
19:                    //pAt24c02->iic_received_byte=iic_received_byte;
20:                	pAt24c02->iic_received_byte_if_ack=iic_received_byte_if_ack;
00003E  000360     NOP
000040  000360     NOP
000042  000360     NOP
21:                	//pAt24c02->iic_write_byte=iic_write_byte;
22:                	//pAt24c02->iic_write_n_byte=iic_write_n_byte;    
23:                }
000044  000360     NOP
000046  000360     NOP
000048  000360     NOP
00004A  000360     NOP
24:                void at24c02_init_all_chip(void)
25:                {
000048  000360     NOP
26:                    at24c02_init(&at24c02Ch0,0xaa);//
00004A  000360     NOP
00004C  000360     NOP
00004E  000360     NOP
27:                    at24c02_init(&at24c02Ch1,0xac);//
000050  000360     NOP
000052  000360     NOP
28:                }
000056  000360     NOP
000058  000360     NOP
29:                uint8_t at24c02_read_byte(st_iicDeviceObj* pAt24c02,uint8_t addr)
30:                {
00005A  000360     NOP
31:                	uint8_t ret;
32:                	//device must enable 
33:                	pAt24c02->iic_start();
000060  000360     NOP
000062  000360     NOP
34:                	pAt24c02->iic_send_byte(pAt24c02->slaveAddr);
000066  000360     NOP
35:                	pAt24c02->iic_send_byte(addr);
000070  000360     NOP
36:                	//
37:                	pAt24c02->iic_start();
000078  000360     NOP
38:                	pAt24c02->iic_send_byte(pAt24c02->slaveAddr+1);
00007E  000360     NOP
000080  000360     NOP
39:                	ret=pAt24c02->iic_received_byte_if_ack(IIC_NACK);
00008A  000360     NOP
40:                	pAt24c02->iic_stop();
000094  000360     NOP
41:                    return ret;
00009A  000360     NOP
42:                }
00009C  000360     NOP
43:                void at24c02_read_n_byte(st_iicDeviceObj* pAt24c02,uint8_t addr,uint8_t* buf,uint16_t len)
44:                {
0000A0  000360     NOP
45:                	//device must enable 
46:                	uint16_t i;
47:                	pAt24c02->iic_start();
0000AA  000360     NOP
48:                	pAt24c02->iic_send_byte(pAt24c02->slaveAddr);
0000B0  000360     NOP
49:                	pAt24c02->iic_send_byte(addr);
0000BA  000360     NOP
50:                	//
51:                	pAt24c02->iic_start();
0000C2  000360     NOP
0000C4  000360     NOP
0000C6  000360     NOP
52:                	pAt24c02->iic_send_byte(pAt24c02->slaveAddr+1);
0000C8  000360     NOP
0000CA  000360     NOP
0000CC  000360     NOP
0000CE  000360     NOP
0000D0  000360     NOP
0000D2  000360     NOP
0000D4  000360     NOP
0000D6  000360     NOP
0000D8  000360     NOP
53:                	for(i=0;i<len-1;i++){
0000D4  000360     NOP
0000D6  000360     NOP
0000D8  000360     NOP
0000DA  000360     NOP
0000EC  000360     NOP
0000EE  000360     NOP
0000F0  000360     NOP
0000F2  000360     NOP
0000F4  000360     NOP
0000F6  000360     NOP
0000F8  000360     NOP
54:                		*buf++=pAt24c02->iic_received_byte_if_ack(IIC_ACK);
0000DA  000360     NOP
0000DC  000360     NOP
0000DE  000360     NOP
0000E0  000360     NOP
0000E2  000360     NOP
0000E4  000360     NOP
0000E6  000360     NOP
0000E8  000360     NOP
0000EA  000360     NOP
0000EC  000360     NOP
55:                	}
56:                	*buf=pAt24c02->iic_received_byte_if_ack(IIC_NACK);
0000F6  000360     NOP
0000F8  000360     NOP
0000FA  000360     NOP
0000FC  000360     NOP
0000FE  000360     NOP
000100  FFFFFF     NOPR
000102  FFFFFF     NOPR
000104  000360     NOP
000106  000360     NOP
57:                	pAt24c02->iic_stop();	
58:                }
000108  000360     NOP
00010A  000360     NOP
59:                void at24c02_write_byte(st_iicDeviceObj* pAt24c02,uint8_t addr,uint8_t x)
60:                {
00010C  000360     NOP
00010E  000360     NOP
000110  000360     NOP
000112  000360     NOP
61:                	pAt24c02->iic_start();
000114  000360     NOP
000116  000360     NOP
000118  000360     NOP
62:                	pAt24c02->iic_send_byte(pAt24c02->slaveAddr);
00011A  000360     NOP
00011C  000360     NOP
00011E  000360     NOP
000120  000360     NOP
000122  000360     NOP
63:                	pAt24c02->iic_send_byte(addr);
000124  000360     NOP
000126  000360     NOP
000128  000360     NOP
00012A  000360     NOP
64:                	
65:                	pAt24c02->iic_send_byte(x);
00012C  000360     NOP
00012E  000360     NOP
000130  000360     NOP
000132  000360     NOP
000134  000360     NOP
000136  000360     NOP
000138  000360     NOP
66:                	pAt24c02->iic_stop();	
000134  000360     NOP
000136  000360     NOP
000138  000360     NOP
67:                }
00013A  000360     NOP
00013C  000360     NOP
68:                /*
69:                void at24c02_write_n_byte(st_iicDeviceObj* pAt24c02,uint8_t addr,uint8_t* buf,uint16_t len)
70:                {
71:                	uint16_t i;
72:                	for(i=0;i<len;i++){
73:                		pAt24c02->iic_start();
74:                		pAt24c02->iic_send_byte(pAt24c02->slaveAddr);
75:                		pAt24c02->iic_send_byte(addr++);
76:                		
77:                		pAt24c02->iic_send_byte(*buf++);
78:                		pAt24c02->iic_stop();
79:                        delay_ms(1);
80:                		//delay_us(20);
81:                	}
82:                }
83:                
84:                */
85:                extern uint8_t globleBuffer[];
86:                void at24c02_write_n_byte(st_iicDeviceObj* pAt24c02,uint8_t addr,uint8_t* buf,uint16_t len)
87:                {
00013E  000360     NOP
000140  000360     NOP
000142  000360     NOP
000144  000360     NOP
000146  000360     NOP
88:                	uint16_t i;
89:                	uint8_t tmpBuf[256];
90:                	at24c02_read_n_byte(pAt24c02,addr,tmpBuf,len);
000148  000360     NOP
00014A  000360     NOP
00014C  000360     NOP
00014E  000360     NOP
000150  000360     NOP
000152  000360     NOP
91:                	
92:                	for(i=0;i<len;i++){
000154  000360     NOP
000156  000360     NOP
000158  000360     NOP
00015A  000360     NOP
0001A2  000360     NOP
0001A4  000360     NOP
0001A6  000360     NOP
0001A8  000360     NOP
0001AA  000360     NOP
93:                		if(tmpBuf[i]==buf[i])continue;
00015A  000360     NOP
00015C  000360     NOP
00015E  000360     NOP
000160  000360     NOP
000162  000360     NOP
000164  000360     NOP
000166  000360     NOP
000168  000360     NOP
0001A0  000360     NOP
94:                		
95:                		pAt24c02->iic_start();
00016A  000360     NOP
00016C  000360     NOP
00016E  000360     NOP
96:                		pAt24c02->iic_send_byte(pAt24c02->slaveAddr);
000170  000360     NOP
000172  000360     NOP
000174  000360     NOP
000176  000360     NOP
000178  000360     NOP
97:                		pAt24c02->iic_send_byte(addr+i);
00017A  000360     NOP
00017C  000360     NOP
00017E  000360     NOP
000180  000360     NOP
000182  000360     NOP
000184  000360     NOP
000186  000360     NOP
98:                		pAt24c02->iic_send_byte(buf[i]);
000188  000360     NOP
00018A  000360     NOP
00018C  000360     NOP
00018E  000360     NOP
000190  000360     NOP
000192  000360     NOP
99:                		pAt24c02->iic_stop();
000194  000360     NOP
000196  000360     NOP
000198  000360     NOP
100:                       delay_ms(1);
00019A  000360     NOP
00019C  000360     NOP
00019E  000360     NOP
101:               	}
102:               }
0001AC  000360     NOP
0001AE  000360     NOP
103:               
104:               
105:               
106:               //file end
107:               
---  F:/2017/cs66-b/cs66b.X/src/driver/ads1148_hal.c  ---------------------------------------------------
1:                 #include "drivers.h"
2:                 #include "ads1148.h"
3:                 #include "../soc/delay.h"
4:                 #include "../global/globle.h"
5:                 //rd10
6:                 #define __some_nop() __nop();__nop();__nop();__nop();__nop();__nop();
7:                 void ads1148_hal_sck_mod_out(void)
8:                 {
0026DC  FA0000     LNK #0x0
9:                     set_port_mode_dig(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
0026DE  802730     MOV ANSD, W0
0026E0  A1A000     BCLR W0, #10
0026E2  882730     MOV W0, ANSD
10:                	set_port_mode_out(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
0026E4  8016C0     MOV TRISD, W0
0026E6  A1A000     BCLR W0, #10
0026E8  8816C0     MOV W0, TRISD
11:                	#if ADS1148_SCK_IDLE_STATUE==0
12:                	set_port_value_low(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
0026EA  8016E0     MOV LATD, W0
0026EC  A1A000     BCLR W0, #10
0026EE  8816E0     MOV W0, LATD
13:                	#else
14:                	set_port_value_hight(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
15:                	#endif
16:                }
0026F0  FA8000     ULNK
0026F2  060000     RETURN
17:                
18:                void ads1148_hal_sck_set_hight(void)
19:                {
0026F4  FA0000     LNK #0x0
20:                	set_port_value_hight(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
0026F6  8016E0     MOV LATD, W0
0026F8  A0A000     BSET W0, #10
0026FA  8816E0     MOV W0, LATD
21:                }
0026FC  FA8000     ULNK
0026FE  060000     RETURN
22:                
23:                void ads1148_hal_sck_set_low(void)
24:                {
002700  FA0000     LNK #0x0
25:                	set_port_value_low(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
002702  8016E0     MOV LATD, W0
002704  A1A000     BCLR W0, #10
002706  8816E0     MOV W0, LATD
26:                }
002708  FA8000     ULNK
00270A  060000     RETURN
27:                
28:                void ads1148_hal_sck_mod_in(void)
29:                {
00270C  FA0000     LNK #0x0
30:                    set_port_mode_dig(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
00270E  802730     MOV ANSD, W0
002710  A1A000     BCLR W0, #10
002712  882730     MOV W0, ANSD
31:                	set_port_mode_in(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
002714  8016C0     MOV TRISD, W0
002716  A0A000     BSET W0, #10
002718  8816C0     MOV W0, TRISD
32:                	//set_port_value_hight(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
33:                }
00271A  FA8000     ULNK
00271C  060000     RETURN
34:                
35:                /*
36:                void ads1148_hal_din_mod_out(void)
37:                {
38:                    set_port_mode_dig(ADS1148_DIN_PORT,ADS1148_DIN_PIN);
39:                	set_port_mode_out(ADS1148_DIN_PORT,ADS1148_DIN_PIN);
40:                	set_port_value_hight(ADS1148_DIN_PORT,ADS1148_DIN_PIN);
41:                }
42:                */
43:                
44:                void ads1148_hal_din_mod_in(void)
45:                {
00271E  FA0000     LNK #0x0
46:                    set_port_mode_dig(ADS1148_DIN_PORT,ADS1148_DIN_PIN);
002720  802730     MOV ANSD, W0
002722  A18000     BCLR W0, #8
002724  882730     MOV W0, ANSD
47:                	set_port_mode_in(ADS1148_DIN_PORT,ADS1148_DIN_PIN);
002726  8016C0     MOV TRISD, W0
002728  A08000     BSET W0, #8
00272A  8816C0     MOV W0, TRISD
48:                	//set_port_value_hight(ADS1148_DIN_PORT,ADS1148_DIN_PIN);
49:                }
00272C  FA8000     ULNK
00272E  060000     RETURN
50:                
51:                uint16_t ads1148_hal_din_get(void)
52:                {
002730  FA0002     LNK #0x2
53:                	uint16_t t16;
54:                	t16=get_port_value(ADS1148_DIN_PORT,ADS1148_DIN_PIN);
002732  8016D1     MOV PORTD, W1
002734  201000     MOV #0x100, W0
002736  608F00     AND W1, W0, [W14]
55:                	return t16;
002738  78001E     MOV [W14], W0
56:                }
00273A  FA8000     ULNK
00273C  060000     RETURN
57:                
58:                void ads1148_hal_dout_mod_out(void)
59:                {
00273E  FA0000     LNK #0x0
60:                    set_port_mode_dig(ADS1148_DOUT_PORT,ADS1148_DOUT_PIN);
002740  802730     MOV ANSD, W0
002742  A19000     BCLR W0, #9
002744  882730     MOV W0, ANSD
61:                	set_port_mode_out(ADS1148_DOUT_PORT,ADS1148_DOUT_PIN);
002746  8016C0     MOV TRISD, W0
002748  A19000     BCLR W0, #9
00274A  8816C0     MOV W0, TRISD
62:                	set_port_value_hight(ADS1148_DOUT_PORT,ADS1148_DOUT_PIN);
00274C  8016E0     MOV LATD, W0
00274E  A09000     BSET W0, #9
002750  8816E0     MOV W0, LATD
63:                }
002752  FA8000     ULNK
002754  060000     RETURN
64:                
65:                void ads1148_hal_dout_set_hight(void)
66:                {
002756  FA0000     LNK #0x0
67:                	set_port_value_hight(ADS1148_DOUT_PORT,ADS1148_DOUT_PIN);
002758  8016E0     MOV LATD, W0
00275A  A09000     BSET W0, #9
00275C  8816E0     MOV W0, LATD
68:                }
00275E  FA8000     ULNK
002760  060000     RETURN
69:                
70:                void ads1148_hal_dout_set_low(void)
71:                {
002762  FA0000     LNK #0x0
72:                	set_port_value_low(ADS1148_DOUT_PORT,ADS1148_DOUT_PIN);
002764  8016E0     MOV LATD, W0
002766  A19000     BCLR W0, #9
002768  8816E0     MOV W0, LATD
73:                }
00276A  FA8000     ULNK
00276C  060000     RETURN
74:                
75:                void ads1148_hal_dout_mod_in(void)
76:                {
00276E  FA0000     LNK #0x0
77:                    set_port_mode_dig(ADS1148_DOUT_PORT,ADS1148_DOUT_PIN);
002770  802730     MOV ANSD, W0
002772  A19000     BCLR W0, #9
002774  882730     MOV W0, ANSD
78:                	set_port_mode_in(ADS1148_DOUT_PORT,ADS1148_DOUT_PIN);
002776  8016C0     MOV TRISD, W0
002778  A09000     BSET W0, #9
00277A  8816C0     MOV W0, TRISD
79:                	//set_port_value_hight(ADS1148_DOUT_PORT,ADS1148_DOUT_PIN);
80:                }
00277C  FA8000     ULNK
00277E  060000     RETURN
81:                
82:                /*
83:                void ads1148_hal_drdy_0_mod_out(void)
84:                {
85:                    //set_port_mode_dig(ADS1148_DRDY_0_PORT,ADS1148_DRDY_0_PIN);
86:                	set_port_mode_out(ADS1148_DRDY_0_PORT,ADS1148_DRDY_0_PIN);
87:                	set_port_value_hight(ADS1148_DRDY_0_PORT,ADS1148_DRDY_0_PIN);
88:                }
89:                */
90:                
91:                void ads1148_hal_drdy_0_mod_in(void)
92:                {
002780  FA0000     LNK #0x0
93:                    set_port_mode_dig(ADS1148_DRDY_0_PORT,ADS1148_DRDY_0_PIN);
002782  802701     MOV ANSA, W1
002784  27FFF0     MOV #0x7FFF, W0
002786  608000     AND W1, W0, W0
002788  882700     MOV W0, ANSA
94:                	set_port_mode_in(ADS1148_DRDY_0_PORT,ADS1148_DRDY_0_PIN);
00278A  801601     MOV TRISA, W1
00278C  280000     MOV #0x8000, W0
00278E  700001     IOR W0, W1, W0
002790  881600     MOV W0, TRISA
95:                	//set_port_value_hight(ADS1148_DRDY_0_PORT,ADS1148_DRDY_0_PIN);
96:                }
002792  FA8000     ULNK
002794  060000     RETURN
97:                
98:                uint16_t ads1148_hal_drdy_0_get(void)
99:                {
002796  FA0002     LNK #0x2
100:               	uint16_t t16;
101:               	t16=get_port_value(ADS1148_DRDY_0_PORT,ADS1148_DRDY_0_PIN);
002798  801611     MOV PORTA, W1
00279A  280000     MOV #0x8000, W0
00279C  608F00     AND W1, W0, [W14]
102:                   asm("nop");
00279E  000000     NOP
103:               	return t16;
0027A0  78001E     MOV [W14], W0
104:               }
0027A2  FA8000     ULNK
0027A4  060000     RETURN
105:               
106:               void ads1148_hal_cs_0_mod_out(void)
107:               {
0027A6  FA0000     LNK #0x0
108:                   set_port_mode_dig(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
0027A8  802700     MOV ANSA, W0
0027AA  A1E000     BCLR W0, #14
0027AC  882700     MOV W0, ANSA
109:               	set_port_mode_out(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
0027AE  801600     MOV TRISA, W0
0027B0  A1E000     BCLR W0, #14
0027B2  881600     MOV W0, TRISA
110:               	set_port_value_hight(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
0027B4  801620     MOV LATA, W0
0027B6  A0E000     BSET W0, #14
0027B8  881620     MOV W0, LATA
111:               }
0027BA  FA8000     ULNK
0027BC  060000     RETURN
112:               
113:               void ads1148_hal_cs_0_mod_in(void)
114:               {
0027BE  FA0000     LNK #0x0
115:                   set_port_mode_dig(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
0027C0  802700     MOV ANSA, W0
0027C2  A1E000     BCLR W0, #14
0027C4  882700     MOV W0, ANSA
116:               	set_port_mode_in(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
0027C6  801600     MOV TRISA, W0
0027C8  A0E000     BSET W0, #14
0027CA  881600     MOV W0, TRISA
117:               	//set_port_value_hight(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
118:               }
0027CC  FA8000     ULNK
0027CE  060000     RETURN
119:               
120:               void ads1148_hal_cs_0_set_hight(void)
121:               {
0027D0  FA0000     LNK #0x0
122:               	set_port_value_hight(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
0027D2  801620     MOV LATA, W0
0027D4  A0E000     BSET W0, #14
0027D6  881620     MOV W0, LATA
123:               }
0027D8  FA8000     ULNK
0027DA  060000     RETURN
124:               
125:               void ads1148_hal_cs_0_set_low(void)
126:               {
0027DC  FA0000     LNK #0x0
127:               	set_port_value_hight(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
0027DE  801620     MOV LATA, W0
0027E0  A03000     BSET W0, #3
0027E2  881620     MOV W0, LATA
128:               	set_port_value_low(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
0027E4  801620     MOV LATA, W0
0027E6  A1E000     BCLR W0, #14
0027E8  881620     MOV W0, LATA
129:               }
0027EA  FA8000     ULNK
0027EC  060000     RETURN
130:               
131:               void ads1148_hal_start_0_mod_out(void)
132:               {
0027EE  FA0000     LNK #0x0
133:                   set_port_mode_dig(ADS1148_START_0_PORT,ADS1148_START_0_PIN);
0027F0  802700     MOV ANSA, W0
0027F2  A15000     BCLR W0, #5
0027F4  882700     MOV W0, ANSA
134:               	set_port_mode_out(ADS1148_START_0_PORT,ADS1148_START_0_PIN);
0027F6  801600     MOV TRISA, W0
0027F8  A15000     BCLR W0, #5
0027FA  881600     MOV W0, TRISA
135:               	set_port_value_hight(ADS1148_START_0_PORT,ADS1148_START_0_PIN);
0027FC  801620     MOV LATA, W0
0027FE  A05000     BSET W0, #5
002800  881620     MOV W0, LATA
136:               }
002802  FA8000     ULNK
002804  060000     RETURN
137:               
138:               void ads1148_hal_start_0_set_hight(void)
139:               {
002806  FA0000     LNK #0x0
140:               	set_port_value_hight(ADS1148_START_0_PORT,ADS1148_START_0_PIN);
002808  801620     MOV LATA, W0
00280A  A05000     BSET W0, #5
00280C  881620     MOV W0, LATA
141:               }
00280E  FA8000     ULNK
002810  060000     RETURN
142:               
143:               void ads1148_hal_start_0_set_low(void)
144:               {
002812  FA0000     LNK #0x0
145:               	set_port_value_low(ADS1148_START_0_PORT,ADS1148_START_0_PIN);
002814  801620     MOV LATA, W0
002816  A15000     BCLR W0, #5
002818  881620     MOV W0, LATA
146:               }
00281A  FA8000     ULNK
00281C  060000     RETURN
147:               
148:               
149:               void ads1148_hal_start_0_mod_in(void)
150:               {
00281E  FA0000     LNK #0x0
151:                   set_port_mode_dig(ADS1148_START_0_PORT,ADS1148_START_0_PIN);
002820  802700     MOV ANSA, W0
002822  A15000     BCLR W0, #5
002824  882700     MOV W0, ANSA
152:               	set_port_mode_in(ADS1148_START_0_PORT,ADS1148_START_0_PIN);
002826  801600     MOV TRISA, W0
002828  A05000     BSET W0, #5
00282A  881600     MOV W0, TRISA
153:               	//set_port_value_hight(ADS1148_START_0_PORT,ADS1148_START_0_PIN);
154:               }
00282C  FA8000     ULNK
00282E  060000     RETURN
155:               /*
156:               void ads1148_hal_drdy_1_mod_out(void)
157:               {
158:                   //set_port_mode_dig(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
159:               	set_port_mode_out(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
160:               	set_port_value_hight(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
161:               }
162:               
163:               void ads1148_hal_drdy_1_set_hight(void)
164:               {
165:               	set_port_value_hight(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
166:               }
167:               
168:               void ads1148_hal_drdy_1_set_low(void)
169:               {
170:               	set_port_value_low(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
171:               }
172:               */
173:               
174:               void ads1148_hal_drdy_1_mod_in(void)
175:               {
002830  FA0000     LNK #0x0
176:                   set_port_mode_dig(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
002832  802700     MOV ANSA, W0
002834  A14000     BCLR W0, #4
002836  882700     MOV W0, ANSA
177:               	set_port_mode_in(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
002838  801600     MOV TRISA, W0
00283A  A04000     BSET W0, #4
00283C  881600     MOV W0, TRISA
178:               	//set_port_value_hight(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
179:               }
00283E  FA8000     ULNK
002840  060000     RETURN
180:               
181:               uint16_t ads1148_hal_drdy_1_get(void)
182:               {
002842  FA0002     LNK #0x2
183:               	uint16_t t16;
184:               	t16=get_port_value(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
002844  801610     MOV PORTA, W0
002846  600F70     AND W0, #0x10, [W14]
185:               	return t16;
002848  78001E     MOV [W14], W0
186:               }
00284A  FA8000     ULNK
00284C  060000     RETURN
187:               
188:               void ads1148_hal_cs_1_mod_out(void)
189:               {
00284E  FA0000     LNK #0x0
190:                   set_port_mode_dig(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
002850  802700     MOV ANSA, W0
002852  A13000     BCLR W0, #3
002854  882700     MOV W0, ANSA
191:               	set_port_mode_out(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
002856  801600     MOV TRISA, W0
002858  A13000     BCLR W0, #3
00285A  881600     MOV W0, TRISA
192:               	set_port_value_hight(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
00285C  801620     MOV LATA, W0
00285E  A03000     BSET W0, #3
002860  881620     MOV W0, LATA
193:               }
002862  FA8000     ULNK
002864  060000     RETURN
194:               
195:               void ads1148_hal_cs_1_set_hight(void)
196:               {
002866  FA0000     LNK #0x0
197:               	set_port_value_hight(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
002868  801620     MOV LATA, W0
00286A  A03000     BSET W0, #3
00286C  881620     MOV W0, LATA
198:               }
00286E  FA8000     ULNK
002870  060000     RETURN
199:               
200:               void ads1148_hal_cs_1_set_low(void)
201:               {
002872  FA0000     LNK #0x0
202:               	set_port_value_hight(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
002874  801620     MOV LATA, W0
002876  A0E000     BSET W0, #14
002878  881620     MOV W0, LATA
203:               	set_port_value_low(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
00287A  801620     MOV LATA, W0
00287C  A13000     BCLR W0, #3
00287E  881620     MOV W0, LATA
204:               }
002880  FA8000     ULNK
002882  060000     RETURN
205:               
206:               
207:               void ads1148_hal_cs_1_mod_in(void)
208:               {
002884  FA0000     LNK #0x0
209:                   set_port_mode_dig(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
002886  802700     MOV ANSA, W0
002888  A13000     BCLR W0, #3
00288A  882700     MOV W0, ANSA
210:               	set_port_mode_in(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
00288C  801600     MOV TRISA, W0
00288E  A03000     BSET W0, #3
002890  881600     MOV W0, TRISA
211:               	//set_port_value_hight(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
212:               }
002892  FA8000     ULNK
002894  060000     RETURN
213:               
214:               
215:               void ads1148_hal_start_1_mod_out(void)
216:               {
002896  FA0000     LNK #0x0
217:                   set_port_mode_dig(ADS1148_START_1_PORT,ADS1148_START_1_PIN);
002898  802700     MOV ANSA, W0
00289A  A12000     BCLR W0, #2
00289C  882700     MOV W0, ANSA
218:               	set_port_mode_out(ADS1148_START_1_PORT,ADS1148_START_1_PIN);
00289E  801600     MOV TRISA, W0
0028A0  A12000     BCLR W0, #2
0028A2  881600     MOV W0, TRISA
219:               	set_port_value_hight(ADS1148_START_1_PORT,ADS1148_START_1_PIN);
0028A4  801620     MOV LATA, W0
0028A6  A02000     BSET W0, #2
0028A8  881620     MOV W0, LATA
220:               }
0028AA  FA8000     ULNK
0028AC  060000     RETURN
221:               
222:               void ads1148_hal_start_1_set_hight(void)
223:               {
0028AE  FA0000     LNK #0x0
224:               	set_port_value_hight(ADS1148_START_1_PORT,ADS1148_START_1_PIN);
0028B0  801620     MOV LATA, W0
0028B2  A02000     BSET W0, #2
0028B4  881620     MOV W0, LATA
225:               }
0028B6  FA8000     ULNK
0028B8  060000     RETURN
226:               
227:               void ads1148_hal_start_1_set_low(void)
228:               {
0028BA  FA0000     LNK #0x0
229:               	set_port_value_low(ADS1148_START_1_PORT,ADS1148_START_1_PIN);
0028BC  801620     MOV LATA, W0
0028BE  A12000     BCLR W0, #2
0028C0  881620     MOV W0, LATA
230:               }
0028C2  FA8000     ULNK
0028C4  060000     RETURN
231:               
232:               
233:               void ads1148_hal_start_1_mod_in(void)
234:               {
0028C6  FA0000     LNK #0x0
235:                   set_port_mode_dig(ADS1148_START_1_PORT,ADS1148_START_1_PIN);
0028C8  802700     MOV ANSA, W0
0028CA  A12000     BCLR W0, #2
0028CC  882700     MOV W0, ANSA
236:               	set_port_mode_in(ADS1148_START_1_PORT,ADS1148_START_1_PIN);
0028CE  801600     MOV TRISA, W0
0028D0  A02000     BSET W0, #2
0028D2  881600     MOV W0, TRISA
237:               	//set_port_value_hight(ADS1148_START_1_PORT,ADS1148_START_1_PIN);
238:               }
0028D4  FA8000     ULNK
0028D6  060000     RETURN
239:               
240:               void ads1148_hal_port_mode_dig_all(void)
241:               {
0028D8  FA0000     LNK #0x0
242:               	
243:               	set_port_mode_dig(ADS1148_SCK_PORT,ADS1148_SCK_PIN);
0028DA  802730     MOV ANSD, W0
0028DC  A1A000     BCLR W0, #10
0028DE  882730     MOV W0, ANSD
244:               	set_port_mode_dig(ADS1148_DIN_PORT,ADS1148_DIN_PIN);
0028E0  802730     MOV ANSD, W0
0028E2  A18000     BCLR W0, #8
0028E4  882730     MOV W0, ANSD
245:               	set_port_mode_dig(ADS1148_DOUT_PORT,ADS1148_DOUT_PIN);
0028E6  802730     MOV ANSD, W0
0028E8  A19000     BCLR W0, #9
0028EA  882730     MOV W0, ANSD
246:               	set_port_mode_dig(ADS1148_DRDY_0_PORT,ADS1148_DRDY_0_PIN);
0028EC  802701     MOV ANSA, W1
0028EE  27FFF0     MOV #0x7FFF, W0
0028F0  608000     AND W1, W0, W0
0028F2  882700     MOV W0, ANSA
247:               	set_port_mode_dig(ADS1148_CS_0_PORT,ADS1148_CS_0_PIN);
0028F4  802700     MOV ANSA, W0
0028F6  A1E000     BCLR W0, #14
0028F8  882700     MOV W0, ANSA
248:               	set_port_mode_dig(ADS1148_START_0_PORT,ADS1148_START_0_PIN);
0028FA  802700     MOV ANSA, W0
0028FC  A15000     BCLR W0, #5
0028FE  882700     MOV W0, ANSA
249:               	set_port_mode_dig(ADS1148_DRDY_1_PORT,ADS1148_DRDY_1_PIN);
002900  802700     MOV ANSA, W0
002902  A14000     BCLR W0, #4
002904  882700     MOV W0, ANSA
250:               	set_port_mode_dig(ADS1148_CS_1_PORT,ADS1148_CS_1_PIN);
002906  802700     MOV ANSA, W0
002908  A13000     BCLR W0, #3
00290A  882700     MOV W0, ANSA
251:               	set_port_mode_dig(ADS1148_START_1_PORT,ADS1148_START_1_PIN);
00290C  802700     MOV ANSA, W0
00290E  A12000     BCLR W0, #2
002910  882700     MOV W0, ANSA
252:               	
253:               }
002912  FA8000     ULNK
002914  060000     RETURN
254:               
255:               void ads1148_hal_port_init_chip0(void)
256:               {
002916  FA0000     LNK #0x0
257:               	ads1148_hal_sck_mod_out();
002918  07FEE1     RCALL ads1148_hal_sck_mod_out
258:               	ads1148_hal_din_mod_in();
00291A  07FF01     RCALL ads1148_hal_din_mod_in
259:               	ads1148_hal_dout_mod_out();
00291C  07FF10     RCALL ads1148_hal_dout_mod_out
260:               	ads1148_hal_cs_0_mod_out();
00291E  07FF43     RCALL ads1148_hal_cs_0_mod_out
261:               	ads1148_hal_start_0_mod_out();
002920  07FF66     RCALL ads1148_hal_start_0_mod_out
262:               	ads1148_hal_drdy_0_mod_in();
002922  07FF2E     RCALL ads1148_hal_drdy_0_mod_in
263:               }
002924  FA8000     ULNK
002926  060000     RETURN
264:               
265:               void ads1148_hal_port_deinit_chip0(void)
266:               {
002928  FA0000     LNK #0x0
267:               	ads1148_hal_sck_mod_in();
00292A  07FEF0     RCALL ads1148_hal_sck_mod_in
268:               	ads1148_hal_din_mod_in();
00292C  07FEF8     RCALL ads1148_hal_din_mod_in
269:               	ads1148_hal_dout_mod_in();
00292E  07FF1F     RCALL ads1148_hal_dout_mod_in
270:               	ads1148_hal_cs_0_mod_in();
002930  07FF46     RCALL ads1148_hal_cs_0_mod_in
271:               	ads1148_hal_start_0_mod_in();
002932  07FF75     RCALL ads1148_hal_start_0_mod_in
272:               	ads1148_hal_drdy_0_mod_in();
002934  07FF25     RCALL ads1148_hal_drdy_0_mod_in
273:               }
002936  FA8000     ULNK
002938  060000     RETURN
274:               
275:               void ads1148_hal_port_init_chip1(void)
276:               {
00293A  FA0000     LNK #0x0
277:               	
278:               	ads1148_hal_sck_mod_out();
00293C  07FECF     RCALL ads1148_hal_sck_mod_out
279:               	ads1148_hal_din_mod_in();
00293E  07FEEF     RCALL ads1148_hal_din_mod_in
280:               	ads1148_hal_dout_mod_out();
002940  07FEFE     RCALL ads1148_hal_dout_mod_out
281:               	ads1148_hal_cs_1_mod_out();
002942  07FF85     RCALL ads1148_hal_cs_1_mod_out
282:               	ads1148_hal_start_1_mod_out();
002944  07FFA8     RCALL ads1148_hal_start_1_mod_out
283:               	ads1148_hal_drdy_1_mod_in();	
002946  07FF74     RCALL ads1148_hal_drdy_1_mod_in
284:               }
002948  FA8000     ULNK
00294A  060000     RETURN
285:               
286:               void ads1148_hal_port_deinit_chip1(void)
287:               {
00294C  FA0000     LNK #0x0
288:               	ads1148_hal_sck_mod_in();
00294E  07FEDE     RCALL ads1148_hal_sck_mod_in
289:               	ads1148_hal_din_mod_in();
002950  07FEE6     RCALL ads1148_hal_din_mod_in
290:               	ads1148_hal_dout_mod_in();
002952  07FF0D     RCALL ads1148_hal_dout_mod_in
291:               	ads1148_hal_cs_1_mod_in();
002954  07FF97     RCALL ads1148_hal_cs_1_mod_in
292:               	ads1148_hal_start_1_mod_in();
002956  07FFB7     RCALL ads1148_hal_start_1_mod_in
293:               	ads1148_hal_drdy_1_mod_in();	
002958  07FF6B     RCALL ads1148_hal_drdy_1_mod_in
294:               }
00295A  FA8000     ULNK
00295C  060000     RETURN
295:               /*
296:               
297:               */
298:               #if( ADS1148_SCK_IDLE_STATUE == 0)
299:               volatile uint8_t ads1148_hal_write_read_byte(uint8_t x)
300:               {
00295E  FA0004     LNK #0x4
002960  984720     MOV.B W0, [W14+2]
301:               	uint8_t i,ret=0;
002962  EB4000     CLR.B W0
002964  984710     MOV.B W0, [W14+1]
302:               	//ads1148_hal_sck_set_low();
303:               	for(i=0;i<8;i++){
002966  EB4000     CLR.B W0
002968  784F00     MOV.B W0, [W14]
00296A  370027     BRA 0x29BA
0029B8  E84F1E     INC.B [W14], [W14]
0029BA  78401E     MOV.B [W14], W0
0029BC  504FE7     SUB.B W0, #0x7, [W15]
0029BE  36FFD6     BRA LEU, 0x296C
304:               		//delay_us(1);
305:                       __some_nop();
00296C  000000     NOP
00296E  000000     NOP
002970  000000     NOP
002972  000000     NOP
002974  000000     NOP
002976  000000     NOP
306:               		ret<<=1;
002978  90401E     MOV.B [W14+1], W0
00297A  404000     ADD.B W0, W0, W0
00297C  984710     MOV.B W0, [W14+1]
307:               		ads1148_hal_sck_set_hight();
00297E  07FEBA     RCALL ads1148_hal_sck_set_hight
308:               		if(ads1148_hal_din_get()){
002980  07FED7     RCALL ads1148_hal_din_get
002982  E00000     CP0 W0
002984  320003     BRA Z, 0x298C
309:               			ret|=1;
002986  90401E     MOV.B [W14+1], W0
002988  A00400     BSET.B W0, #0
00298A  984710     MOV.B W0, [W14+1]
310:               		}
311:               		//delay_us(1);
312:                       __some_nop();
00298C  000000     NOP
00298E  000000     NOP
002990  000000     NOP
002992  000000     NOP
002994  000000     NOP
002996  000000     NOP
313:               		if(x&0x80){
002998  90402E     MOV.B [W14+2], W0
00299A  E00400     CP0.B W0
00299C  3D0002     BRA GE, 0x29A2
314:               			ads1148_hal_dout_set_hight();
00299E  07FEDB     RCALL ads1148_hal_dout_set_hight
0029A0  370001     BRA 0x29A4
315:               		}else{
316:               			ads1148_hal_dout_set_low();
0029A2  07FEDF     RCALL ads1148_hal_dout_set_low
317:               		}
318:               		x<<=1;
0029A4  90402E     MOV.B [W14+2], W0
0029A6  404000     ADD.B W0, W0, W0
0029A8  984720     MOV.B W0, [W14+2]
319:                       __some_nop();
0029AA  000000     NOP
0029AC  000000     NOP
0029AE  000000     NOP
0029B0  000000     NOP
0029B2  000000     NOP
0029B4  000000     NOP
320:               		ads1148_hal_sck_set_low();
0029B6  07FEA4     RCALL ads1148_hal_sck_set_low
321:               	}
322:               	ads1148_hal_sck_set_low();
0029C0  07FE9F     RCALL ads1148_hal_sck_set_low
323:               	return ret;
0029C2  90401E     MOV.B [W14+1], W0
324:               }
0029C4  FA8000     ULNK
0029C6  060000     RETURN
325:               #else
326:               volatile uint8_t ads1148_hal_write_read_byte(uint8_t x)
327:               {
328:               	volatile uint8_t i,ret=0;
329:               	ads1148_hal_sck_set_hight();
330:               	for(i=0;i<8;i++){
331:               		if(x&0x80){
332:               			ads1148_hal_dout_set_hight();
333:               		}else{
334:               			ads1148_hal_dout_set_low();
335:               		}
336:                       x<<=1;
337:               		ads1148_hal_sck_set_low();
338:               		ret<<=1;
339:               		ads1148_hal_sck_set_hight();
340:               		if(ads1148_hal_din_get()){
341:               			ret|=1;
342:               		}
343:               	}
344:               	ads1148_hal_sck_set_hight();
345:               	return ret;
346:               }
347:               #endif	
348:               void ads1148_hal_pwr_off(void)
349:               {
0029C8  FA0000     LNK #0x0
350:                   set_port_mode_dig(ADS1148_PWR_PORT,ADS1148_PWR_PIN);
0029CA  802760     MOV ANSG, W0
0029CC  A19000     BCLR W0, #9
0029CE  882760     MOV W0, ANSG
351:               	set_port_mode_out(ADS1148_PWR_PORT,ADS1148_PWR_PIN);
0029D0  801780     MOV TRISG, W0
0029D2  A19000     BCLR W0, #9
0029D4  881780     MOV W0, TRISG
352:               	set_port_value_hight(ADS1148_PWR_PORT,ADS1148_PWR_PIN);	
0029D6  8017A0     MOV LATG, W0
0029D8  A09000     BSET W0, #9
0029DA  8817A0     MOV W0, LATG
353:               }
0029DC  FA8000     ULNK
0029DE  060000     RETURN
354:               void ads1148_hal_pwr_on(void)
355:               {
0029E0  FA0000     LNK #0x0
356:                   set_port_mode_dig(ADS1148_PWR_PORT,ADS1148_PWR_PIN);
0029E2  802760     MOV ANSG, W0
0029E4  A19000     BCLR W0, #9
0029E6  882760     MOV W0, ANSG
357:               	set_port_mode_out(ADS1148_PWR_PORT,ADS1148_PWR_PIN);
0029E8  801780     MOV TRISG, W0
0029EA  A19000     BCLR W0, #9
0029EC  881780     MOV W0, TRISG
358:               	set_port_value_low(ADS1148_PWR_PORT,ADS1148_PWR_PIN);	
0029EE  8017A0     MOV LATG, W0
0029F0  A19000     BCLR W0, #9
0029F2  8817A0     MOV W0, LATG
359:               }
0029F4  FA8000     ULNK
0029F6  060000     RETURN
360:               
---  F:/2017/cs66-b/cs66b.X/src/driver/ads1148.c  -------------------------------------------------------
1:                 #include "drivers.h"
2:                 #include "../soc/delay.h"
3:                 #include "../soc/ticker.h"
4:                 #include "ads1148.h"
5:                 #include "float.h"
6:                 
7:                 // #include "../../os_configs/FreeRTOSConfig.h"
8:                 // #include "../../os_kernel/include/FreeRTOS.h"
9:                 // #include "../../os_kernel/include/task.h"  
10:                #include "../global/globle.h"
11:                
12:                ads1148Obj_t ads1148Chip0,ads1148Chip1;
13:                
14:                
15:                uint8_t ads1148_send_cmd(ads1148Obj_t* obj,uint8_t cmd)
16:                {
001866  FA0006     LNK #0x6
001868  980710     MOV W0, [W14+2]
00186A  984741     MOV.B W1, [W14+4]
17:                    uint8_t ret;
18:                	#if ADS1148_SCK_IDLE_STATUE==0
19:                    obj->pins_sck_set_low();
00186C  90001E     MOV [W14+2], W0
00186E  900020     MOV [W0+4], W0
001870  010000     CALL W0
20:                	#else
21:                	obj->pins_sck_set_hight();
22:                	#endif
23:                	obj->pins_cs_set_low();
001872  90001E     MOV [W14+2], W0
001874  900070     MOV [W0+14], W0
001876  010000     CALL W0
24:                    ret=obj->ads1148_write_read_via_spi(cmd);
001878  90001E     MOV [W14+2], W0
00187A  9008D0     MOV [W0+26], W1
00187C  90404E     MOV.B [W14+4], W0
00187E  010001     CALL W1
001880  784F00     MOV.B W0, [W14]
25:                	delay_us(10);
001882  2000A0     MOV #0xA, W0
001884  070D50     RCALL delay_us
26:                	obj->pins_cs_set_hight();
001886  90001E     MOV [W14+2], W0
001888  900800     MOV [W0+16], W0
00188A  010000     CALL W0
27:                	delay_us(2);
00188C  200020     MOV #0x2, W0
00188E  070D4B     RCALL delay_us
28:                    return ret;
001890  78401E     MOV.B [W14], W0
29:                }
001892  FA8000     ULNK
001894  060000     RETURN
30:                
31:                volatile uint16_t ads1148_read_data(ads1148Obj_t* obj)
32:                {
001896  FA0006     LNK #0x6
001898  980720     MOV W0, [W14+4]
33:                	volatile uint16_t t16=0;
00189A  EB0000     CLR W0
00189C  980710     MOV W0, [W14+2]
34:                	uint8_t t8=0;
00189E  EB4000     CLR.B W0
0018A0  784F00     MOV.B W0, [W14]
35:                	#if ADS1148_SCK_IDLE_STATUE==0
36:                    obj->pins_sck_set_low();
0018A2  90002E     MOV [W14+4], W0
0018A4  900020     MOV [W0+4], W0
0018A6  010000     CALL W0
37:                	#else
38:                	obj->pins_sck_set_hight();
39:                	#endif
40:                    delay_us(10);
0018A8  2000A0     MOV #0xA, W0
0018AA  070D3D     RCALL delay_us
41:                	obj->pins_cs_set_low();
0018AC  90002E     MOV [W14+4], W0
0018AE  900070     MOV [W0+14], W0
0018B0  010000     CALL W0
42:                	obj->ads1148_write_read_via_spi(ADS1148_CMD_RDATA);
0018B2  90002E     MOV [W14+4], W0
0018B4  9008D0     MOV [W0+26], W1
0018B6  B3C130     MOV.B #0x13, W0
0018B8  010001     CALL W1
43:                    delay_us(5);
0018BA  200050     MOV #0x5, W0
0018BC  070D34     RCALL delay_us
44:                	t8=obj->ads1148_write_read_via_spi(ADS1148_CMD_NOP);
0018BE  90002E     MOV [W14+4], W0
0018C0  9008D0     MOV [W0+26], W1
0018C2  EBC000     SETM.B W0
0018C4  010001     CALL W1
0018C6  784F00     MOV.B W0, [W14]
45:                	t16=t8;
0018C8  FB801E     ZE [W14], W0
0018CA  980710     MOV W0, [W14+2]
46:                	t16<<=8;
0018CC  90001E     MOV [W14+2], W0
0018CE  DD0048     SL W0, #8, W0
0018D0  980710     MOV W0, [W14+2]
47:                    delay_us(5);
0018D2  200050     MOV #0x5, W0
0018D4  070D28     RCALL delay_us
48:                	t8=obj->ads1148_write_read_via_spi(ADS1148_CMD_NOP);
0018D6  90002E     MOV [W14+4], W0
0018D8  9008D0     MOV [W0+26], W1
0018DA  EBC000     SETM.B W0
0018DC  010001     CALL W1
0018DE  784F00     MOV.B W0, [W14]
49:                	t16 |= t8;
0018E0  FB809E     ZE [W14], W1
0018E2  90001E     MOV [W14+2], W0
0018E4  700001     IOR W0, W1, W0
0018E6  980710     MOV W0, [W14+2]
50:                    delay_us(10);
0018E8  2000A0     MOV #0xA, W0
0018EA  070D1D     RCALL delay_us
51:                	obj->pins_cs_set_hight();
0018EC  90002E     MOV [W14+4], W0
0018EE  900800     MOV [W0+16], W0
0018F0  010000     CALL W0
52:                	delay_us(2);
0018F2  200020     MOV #0x2, W0
0018F4  070D18     RCALL delay_us
53:                	return t16;
0018F6  90001E     MOV [W14+2], W0
54:                }
0018F8  FA8000     ULNK
0018FA  060000     RETURN
55:                
56:                void ads1148_write_register(ads1148Obj_t* obj,uint8_t offsetaddr,uint8_t *buf,uint8_t num)
57:                {
0018FC  FA000A     LNK #0xA
0018FE  980710     MOV W0, [W14+2]
001900  984741     MOV.B W1, [W14+4]
001902  980732     MOV W2, [W14+6]
001904  984F03     MOV.B W3, [W14+8]
58:                	uint8_t i;
59:                	uint8_t cmd;
60:                	if(num<1)return;
001906  90480E     MOV.B [W14+8], W0
001908  E00400     CP0.B W0
00190A  32002E     BRA Z, 0x1968
001968  000000     NOP
61:                	#if ADS1148_SCK_IDLE_STATUE==0
62:                    obj->pins_sck_set_low();
00190C  90001E     MOV [W14+2], W0
00190E  900020     MOV [W0+4], W0
001910  010000     CALL W0
63:                	#else
64:                	obj->pins_sck_set_hight();
65:                	#endif
66:                	obj->pins_cs_set_low();
001912  90001E     MOV [W14+2], W0
001914  900070     MOV [W0+14], W0
001916  010000     CALL W0
67:                	cmd=ADS1148_CMD_WREG;
001918  B3C400     MOV.B #0x40, W0
00191A  984710     MOV.B W0, [W14+1]
68:                	cmd |= (offsetaddr & 0x0f);
00191C  90404E     MOV.B [W14+4], W0
00191E  6040EF     AND.B W0, #0xF, W1
001920  90401E     MOV.B [W14+1], W0
001922  70C000     IOR.B W1, W0, W0
001924  984710     MOV.B W0, [W14+1]
69:                	obj->ads1148_write_read_via_spi(cmd);
001926  90001E     MOV [W14+2], W0
001928  9008D0     MOV [W0+26], W1
00192A  90401E     MOV.B [W14+1], W0
00192C  010001     CALL W1
70:                	obj->ads1148_write_read_via_spi(num-1);
00192E  90001E     MOV [W14+2], W0
001930  9008D0     MOV [W0+26], W1
001932  90480E     MOV.B [W14+8], W0
001934  E94000     DEC.B W0, W0
001936  010001     CALL W1
71:                	for(i=0;i<num;i++){
001938  EB4000     CLR.B W0
00193A  784F00     MOV.B W0, [W14]
00193C  370009     BRA 0x1950
00194E  E84F1E     INC.B [W14], [W14]
001950  90480E     MOV.B [W14+8], W0
001952  78409E     MOV.B [W14], W1
001954  50CF80     SUB.B W1, W0, [W15]
001956  39FFF3     BRA NC, 0x193E
72:                		obj->ads1148_write_read_via_spi(*buf);
00193E  90001E     MOV [W14+2], W0
001940  9008D0     MOV [W0+26], W1
001942  90003E     MOV [W14+6], W0
001944  784010     MOV.B [W0], W0
001946  010001     CALL W1
73:                		buf++;
001948  90003E     MOV [W14+6], W0
00194A  E80000     INC W0, W0
00194C  980730     MOV W0, [W14+6]
74:                	}
75:                    delay_us(10);
001958  2000A0     MOV #0xA, W0
00195A  070CE5     RCALL delay_us
76:                	obj->pins_cs_set_hight();
00195C  90001E     MOV [W14+2], W0
00195E  900800     MOV [W0+16], W0
001960  010000     CALL W0
77:                	delay_us(2);
001962  200020     MOV #0x2, W0
001964  070CE0     RCALL delay_us
001966  370001     BRA 0x196A
78:                }
00196A  FA8000     ULNK
00196C  060000     RETURN
79:                
80:                void ads1148_read_register(ads1148Obj_t* obj,uint8_t offsetaddr,uint8_t *buf,uint8_t num)
81:                {
00196E  FA000C     LNK #0xC
001970  980720     MOV W0, [W14+4]
001972  984761     MOV.B W1, [W14+6]
001974  980742     MOV W2, [W14+8]
001976  984F23     MOV.B W3, [W14+10]
82:                	uint8_t t8;
83:                	uint8_t i;
84:                	uint8_t cmd;
85:                	if(num<1)return;
001978  90482E     MOV.B [W14+10], W0
00197A  E00400     CP0.B W0
00197C  320031     BRA Z, 0x19E0
0019E0  000000     NOP
86:                	#if ADS1148_SCK_IDLE_STATUE==0
87:                    obj->pins_sck_set_low();
00197E  90002E     MOV [W14+4], W0
001980  900020     MOV [W0+4], W0
001982  010000     CALL W0
88:                	#else
89:                	obj->pins_sck_set_hight();
90:                	#endif
91:                	obj->pins_cs_set_low();
001984  90002E     MOV [W14+4], W0
001986  900070     MOV [W0+14], W0
001988  010000     CALL W0
92:                	cmd=ADS1148_CMD_RREG;
00198A  B3C200     MOV.B #0x20, W0
00198C  984710     MOV.B W0, [W14+1]
93:                	cmd |= (offsetaddr & 0x0f);
00198E  90406E     MOV.B [W14+6], W0
001990  6040EF     AND.B W0, #0xF, W1
001992  90401E     MOV.B [W14+1], W0
001994  70C000     IOR.B W1, W0, W0
001996  984710     MOV.B W0, [W14+1]
94:                	t8=obj->ads1148_write_read_via_spi(cmd);
001998  90002E     MOV [W14+4], W0
00199A  9008D0     MOV [W0+26], W1
00199C  90401E     MOV.B [W14+1], W0
00199E  010001     CALL W1
0019A0  984720     MOV.B W0, [W14+2]
95:                	t8=obj->ads1148_write_read_via_spi(num-1);
0019A2  90002E     MOV [W14+4], W0
0019A4  9008D0     MOV [W0+26], W1
0019A6  90482E     MOV.B [W14+10], W0
0019A8  E94000     DEC.B W0, W0
0019AA  010001     CALL W1
0019AC  984720     MOV.B W0, [W14+2]
96:                	for(i=0;i<num;i++){
0019AE  EB4000     CLR.B W0
0019B0  784F00     MOV.B W0, [W14]
0019B2  37000A     BRA 0x19C8
0019C6  E84F1E     INC.B [W14], [W14]
0019C8  90482E     MOV.B [W14+10], W0
0019CA  78409E     MOV.B [W14], W1
0019CC  50CF80     SUB.B W1, W0, [W15]
0019CE  39FFF2     BRA NC, 0x19B4
97:                		*buf=obj->ads1148_write_read_via_spi(ADS1148_CMD_NOP);
0019B4  90002E     MOV [W14+4], W0
0019B6  9008D0     MOV [W0+26], W1
0019B8  EBC000     SETM.B W0
0019BA  010001     CALL W1
0019BC  9000CE     MOV [W14+8], W1
0019BE  784880     MOV.B W0, [W1]
98:                		buf++;
0019C0  90004E     MOV [W14+8], W0
0019C2  E80000     INC W0, W0
0019C4  980740     MOV W0, [W14+8]
99:                	}
100:               	//obj->pins_sck_set_hight();
101:               	delay_us(10);
0019D0  2000A0     MOV #0xA, W0
0019D2  070CA9     RCALL delay_us
102:               	obj->pins_cs_set_hight();
0019D4  90002E     MOV [W14+4], W0
0019D6  900800     MOV [W0+16], W0
0019D8  010000     CALL W0
103:               	delay_us(2);
0019DA  200020     MOV #0x2, W0
0019DC  070CA4     RCALL delay_us
0019DE  370001     BRA 0x19E2
104:               }
0019E2  FA8000     ULNK
0019E4  060000     RETURN
105:               //api
106:               void ads1148_slef_calibration(ads1148Obj_t* obj)
107:               {
0019E6  FA0002     LNK #0x2
0019E8  780F00     MOV W0, [W14]
108:               	#if ADS1148_SCK_IDLE_STATUE==0
109:                   obj->pins_sck_set_low();
0019EA  78001E     MOV [W14], W0
0019EC  900020     MOV [W0+4], W0
0019EE  010000     CALL W0
110:               	#else
111:               	obj->pins_sck_set_hight();
112:               	#endif
113:               	obj->pins_cs_set_low();
0019F0  78001E     MOV [W14], W0
0019F2  900070     MOV [W0+14], W0
0019F4  010000     CALL W0
114:               	obj->ads1148_write_read_via_spi(ADS1148_CMD_SYSOCAL);
0019F6  78001E     MOV [W14], W0
0019F8  9008D0     MOV [W0+26], W1
0019FA  B3C600     MOV.B #0x60, W0
0019FC  010001     CALL W1
115:               	delay_ms(300);//bug
0019FE  2012C0     MOV #0x12C, W0
001A00  070CA6     RCALL delay_ms
116:               	obj->pins_cs_set_hight();
001A02  78001E     MOV [W14], W0
001A04  900800     MOV [W0+16], W0
001A06  010000     CALL W0
117:               	delay_us(2);
001A08  200020     MOV #0x2, W0
001A0A  070C8D     RCALL delay_us
118:               }
001A0C  FA8000     ULNK
001A0E  060000     RETURN
119:               
120:               void ads1148_set_channle_normal(ads1148Obj_t* obj,uint8_t chp,uint8_t chn)
121:               {
001A10  FA0006     LNK #0x6
001A12  980710     MOV W0, [W14+2]
001A14  984741     MOV.B W1, [W14+4]
001A16  984752     MOV.B W2, [W14+5]
122:               	st_ads1148RegMUX0 mux0Temp;
123:               
124:               	//mux0Temp.mux0=obj->ads1148Regs.regs.regMUX0.mux0;
125:               	ads1148_read_register(obj,ADS1148_REG_ADDR_MUX0,(uint8_t*)&mux0Temp,1);
001A18  B3C013     MOV.B #0x1, W3
001A1A  78010E     MOV W14, W2
001A1C  EB4080     CLR.B W1
001A1E  90001E     MOV [W14+2], W0
001A20  07FFA6     RCALL ads1148_read_register
126:                   mux0Temp.bits.mux_sp=chp;
001A22  90404E     MOV.B [W14+4], W0
001A24  604067     AND.B W0, #0x7, W0
001A26  6040E7     AND.B W0, #0x7, W1
001A28  200030     MOV #0x3, W0
001A2A  DD0800     SL W1, W0, W0
001A2C  78411E     MOV.B [W14], W2
001A2E  B3CC71     MOV.B #0xC7, W1
001A30  614081     AND.B W2, W1, W1
001A32  70C000     IOR.B W1, W0, W0
001A34  784F00     MOV.B W0, [W14]
127:                   mux0Temp.bits.mux_sn=chn;
001A36  90405E     MOV.B [W14+5], W0
001A38  604067     AND.B W0, #0x7, W0
001A3A  604067     AND.B W0, #0x7, W0
001A3C  78411E     MOV.B [W14], W2
001A3E  B3CF81     MOV.B #0xF8, W1
001A40  614081     AND.B W2, W1, W1
001A42  70C000     IOR.B W1, W0, W0
001A44  784F00     MOV.B W0, [W14]
128:                   obj->ads1148Regs.regs.regMUX0.mux0=mux0Temp.mux0;
001A46  78409E     MOV.B [W14], W1
001A48  90001E     MOV [W14+2], W0
001A4A  985841     MOV.B W1, [W0+28]
129:                   ads1148_write_register(obj,ADS1148_REG_ADDR_MUX0,(uint8_t*)&mux0Temp,1);
001A4C  B3C013     MOV.B #0x1, W3
001A4E  78010E     MOV W14, W2
001A50  EB4080     CLR.B W1
001A52  90001E     MOV [W14+2], W0
001A54  07FF53     RCALL ads1148_write_register
130:               
131:               }
001A56  FA8000     ULNK
001A58  060000     RETURN
132:               void ads1148_set_bcs(ads1148Obj_t* obj,uint8_t bcs)
133:               {
001A5A  FA0006     LNK #0x6
001A5C  980710     MOV W0, [W14+2]
001A5E  984741     MOV.B W1, [W14+4]
134:               	st_ads1148RegMUX0 mux0Temp;
135:               	//mux0Temp.mux0=obj->ads1148Regs.regs.regMUX0.mux0;
136:               	ads1148_read_register(obj,ADS1148_REG_ADDR_MUX0,(uint8_t*)&mux0Temp,1);
001A60  B3C013     MOV.B #0x1, W3
001A62  78010E     MOV W14, W2
001A64  EB4080     CLR.B W1
001A66  90001E     MOV [W14+2], W0
001A68  07FF82     RCALL ads1148_read_register
137:                   mux0Temp.bits.bcs=bcs;
001A6A  90404E     MOV.B [W14+4], W0
001A6C  6040E3     AND.B W0, #0x3, W1
001A6E  200060     MOV #0x6, W0
001A70  DD0800     SL W1, W0, W0
001A72  78409E     MOV.B [W14], W1
001A74  B243F1     AND.B #0x3F, W1
001A76  70C000     IOR.B W1, W0, W0
001A78  784F00     MOV.B W0, [W14]
138:               
139:                   obj->ads1148Regs.regs.regMUX0.mux0=mux0Temp.mux0;
001A7A  78409E     MOV.B [W14], W1
001A7C  90001E     MOV [W14+2], W0
001A7E  985841     MOV.B W1, [W0+28]
140:                   ads1148_write_register(obj,ADS1148_REG_ADDR_MUX0,(uint8_t*)&mux0Temp,1);
001A80  B3C013     MOV.B #0x1, W3
001A82  78010E     MOV W14, W2
001A84  EB4080     CLR.B W1
001A86  90001E     MOV [W14+2], W0
001A88  07FF39     RCALL ads1148_write_register
141:               }
001A8A  FA8000     ULNK
001A8C  060000     RETURN
142:               
143:               void ads1148_set_vbias(ads1148Obj_t* obj,uint8_t vbias)
144:               {
001A8E  FA0006     LNK #0x6
001A90  980710     MOV W0, [W14+2]
001A92  984741     MOV.B W1, [W14+4]
145:                   uint8_t t8;
146:                   t8=vbias;
001A94  9040CE     MOV.B [W14+4], W1
001A96  784F01     MOV.B W1, [W14]
147:                   ads1148_write_register(obj,ADS1148_REG_ADDR_VBIAS,(uint8_t*)&t8,1);
001A98  B3C013     MOV.B #0x1, W3
001A9A  78010E     MOV W14, W2
001A9C  B3C011     MOV.B #0x1, W1
001A9E  90001E     MOV [W14+2], W0
001AA0  07FF2D     RCALL ads1148_write_register
148:               	
149:               }
001AA2  FA8000     ULNK
001AA4  060000     RETURN
150:               
151:               void ads1148_set_vref(ads1148Obj_t* obj,uint8_t vref)
152:               {
001AA6  FA0006     LNK #0x6
001AA8  980710     MOV W0, [W14+2]
001AAA  984741     MOV.B W1, [W14+4]
153:               	ads1148RegMUX1_t mux1Temp;
154:               	ads1148_read_register(obj,ADS1148_REG_ADDR_MUX1,(uint8_t*)&mux1Temp,1);
001AAC  B3C013     MOV.B #0x1, W3
001AAE  78010E     MOV W14, W2
001AB0  B3C021     MOV.B #0x2, W1
001AB2  90001E     MOV [W14+2], W0
001AB4  07FF5C     RCALL ads1148_read_register
155:               	if(vref>ADS1148_REFSELT_INREF_CON_REF0)vref=ADS1148_REFSELT_INREF_CON_REF0;
001AB6  90404E     MOV.B [W14+4], W0
001AB8  504FE3     SUB.B W0, #0x3, [W15]
001ABA  360002     BRA LEU, 0x1AC0
001ABC  B3C030     MOV.B #0x3, W0
001ABE  984740     MOV.B W0, [W14+4]
156:                   if(vref<=ADS1148_REFSELT_REF1){
001AC0  90404E     MOV.B [W14+4], W0
001AC2  504FE1     SUB.B W0, #0x1, [W15]
001AC4  3E0005     BRA GTU, 0x1AD0
157:                       mux1Temp.bits.vrefcon=ADS1148_VREFCON_INREF_OFF;
001AC6  78409E     MOV.B [W14], W1
001AC8  B3C9F0     MOV.B #0x9F, W0
001ACA  60C000     AND.B W1, W0, W0
001ACC  784F00     MOV.B W0, [W14]
001ACE  370005     BRA 0x1ADA
158:                   }else{
159:                       mux1Temp.bits.vrefcon=ADS1148_VREFCON_INREF_ON;
001AD0  78409E     MOV.B [W14], W1
001AD2  B3C9F0     MOV.B #0x9F, W0
001AD4  60C000     AND.B W1, W0, W0
001AD6  A05400     BSET.B W0, #5
001AD8  784F00     MOV.B W0, [W14]
160:                   }
161:               	mux1Temp.bits.refselt=vref;
001ADA  90404E     MOV.B [W14+4], W0
001ADC  604063     AND.B W0, #0x3, W0
001ADE  6040E3     AND.B W0, #0x3, W1
001AE0  200030     MOV #0x3, W0
001AE2  DD0800     SL W1, W0, W0
001AE4  78411E     MOV.B [W14], W2
001AE6  B3CE71     MOV.B #0xE7, W1
001AE8  614081     AND.B W2, W1, W1
001AEA  70C000     IOR.B W1, W0, W0
001AEC  784F00     MOV.B W0, [W14]
162:                   ads1148_write_register(obj,ADS1148_REG_ADDR_MUX1,(uint8_t*)&mux1Temp,1);
001AEE  B3C013     MOV.B #0x1, W3
001AF0  78010E     MOV W14, W2
001AF2  B3C021     MOV.B #0x2, W1
001AF4  90001E     MOV [W14+2], W0
001AF6  07FF02     RCALL ads1148_write_register
163:               }
001AF8  FA8000     ULNK
001AFA  060000     RETURN
164:               
165:               void ads1148_set_muxcal(ads1148Obj_t* obj,uint8_t muxcal)
166:               {
001AFC  FA0006     LNK #0x6
001AFE  980710     MOV W0, [W14+2]
001B00  984741     MOV.B W1, [W14+4]
167:               	ads1148RegMUX1_t mux1Temp;
168:               	ads1148_read_register(obj,ADS1148_REG_ADDR_MUX1,(uint8_t*)&mux1Temp,1);
001B02  B3C013     MOV.B #0x1, W3
001B04  78010E     MOV W14, W2
001B06  B3C021     MOV.B #0x2, W1
001B08  90001E     MOV [W14+2], W0
001B0A  07FF31     RCALL ads1148_read_register
169:               	if(muxcal>ADS1148_MUXCAL_DVDD_DVSS_DIV_4)muxcal=ADS1148_MUXCAL_DVDD_DVSS_DIV_4;
001B0C  90404E     MOV.B [W14+4], W0
001B0E  504FE7     SUB.B W0, #0x7, [W15]
001B10  360002     BRA LEU, 0x1B16
001B12  B3C070     MOV.B #0x7, W0
001B14  984740     MOV.B W0, [W14+4]
170:               	mux1Temp.bits.muxcal=muxcal;
001B16  90404E     MOV.B [W14+4], W0
001B18  604067     AND.B W0, #0x7, W0
001B1A  604067     AND.B W0, #0x7, W0
001B1C  78411E     MOV.B [W14], W2
001B1E  B3CF81     MOV.B #0xF8, W1
001B20  614081     AND.B W2, W1, W1
001B22  70C000     IOR.B W1, W0, W0
001B24  784F00     MOV.B W0, [W14]
171:                   ads1148_write_register(obj,ADS1148_REG_ADDR_MUX1,(uint8_t*)&mux1Temp,1);
001B26  B3C013     MOV.B #0x1, W3
001B28  78010E     MOV W14, W2
001B2A  B3C021     MOV.B #0x2, W1
001B2C  90001E     MOV [W14+2], W0
001B2E  07FEE6     RCALL ads1148_write_register
172:               }
001B30  FA8000     ULNK
001B32  060000     RETURN
173:               
174:               void ads1148_set_data_rate(ads1148Obj_t* obj,uint8_t dr)
175:               {
001B34  FA0006     LNK #0x6
001B36  980710     MOV W0, [W14+2]
001B38  984741     MOV.B W1, [W14+4]
176:                   ads1148RegSYS0_t sys0Temp;
177:               	ads1148_read_register(obj,ADS1148_REG_ADDR_SYS0,(uint8_t*)&sys0Temp,1);
001B3A  B3C013     MOV.B #0x1, W3
001B3C  78010E     MOV W14, W2
001B3E  B3C031     MOV.B #0x3, W1
001B40  90001E     MOV [W14+2], W0
001B42  07FF15     RCALL ads1148_read_register
178:               	sys0Temp.bits.dr=dr;
001B44  90404E     MOV.B [W14+4], W0
001B46  60406F     AND.B W0, #0xF, W0
001B48  60406F     AND.B W0, #0xF, W0
001B4A  78411E     MOV.B [W14], W2
001B4C  B3CF01     MOV.B #0xF0, W1
001B4E  614081     AND.B W2, W1, W1
001B50  70C000     IOR.B W1, W0, W0
001B52  784F00     MOV.B W0, [W14]
179:                   ads1148_write_register(obj,ADS1148_REG_ADDR_SYS0,(uint8_t*)&sys0Temp,1);
001B54  B3C013     MOV.B #0x1, W3
001B56  78010E     MOV W14, W2
001B58  B3C031     MOV.B #0x3, W1
001B5A  90001E     MOV [W14+2], W0
001B5C  07FECF     RCALL ads1148_write_register
180:               }
001B5E  FA8000     ULNK
001B60  060000     RETURN
181:               
182:               void ads1148_set_ani_pga(ads1148Obj_t* obj,uint8_t pga)
183:               {
001B62  FA0006     LNK #0x6
001B64  980710     MOV W0, [W14+2]
001B66  984741     MOV.B W1, [W14+4]
184:                   ads1148RegSYS0_t sys0Temp;
185:               	ads1148_read_register(obj,ADS1148_REG_ADDR_SYS0,(uint8_t*)&sys0Temp,1);
001B68  B3C013     MOV.B #0x1, W3
001B6A  78010E     MOV W14, W2
001B6C  B3C031     MOV.B #0x3, W1
001B6E  90001E     MOV [W14+2], W0
001B70  07FEFE     RCALL ads1148_read_register
186:               	sys0Temp.bits.pga=pga;
001B72  90404E     MOV.B [W14+4], W0
001B74  604067     AND.B W0, #0x7, W0
001B76  6040E7     AND.B W0, #0x7, W1
001B78  200040     MOV #0x4, W0
001B7A  DD0800     SL W1, W0, W0
001B7C  78411E     MOV.B [W14], W2
001B7E  B3C8F1     MOV.B #0x8F, W1
001B80  614081     AND.B W2, W1, W1
001B82  70C000     IOR.B W1, W0, W0
001B84  784F00     MOV.B W0, [W14]
187:                   ads1148_write_register(obj,ADS1148_REG_ADDR_SYS0,(uint8_t*)&sys0Temp,1);
001B86  B3C013     MOV.B #0x1, W3
001B88  78010E     MOV W14, W2
001B8A  B3C031     MOV.B #0x3, W1
001B8C  90001E     MOV [W14+2], W0
001B8E  07FEB6     RCALL ads1148_write_register
188:               }
001B90  FA8000     ULNK
001B92  060000     RETURN
189:               
190:               void ads1148_set_imag_idac(ads1148Obj_t* obj,uint8_t imag)
191:               {
001B94  FA0006     LNK #0x6
001B96  980710     MOV W0, [W14+2]
001B98  984741     MOV.B W1, [W14+4]
192:                   ads1148RegIDAC0_t idac0Temp;
193:               	ads1148_read_register(obj,ADS1148_REG_ADDR_IDAC0,(uint8_t*)&idac0Temp,1);
001B9A  B3C013     MOV.B #0x1, W3
001B9C  78010E     MOV W14, W2
001B9E  B3C0A1     MOV.B #0xA, W1
001BA0  90001E     MOV [W14+2], W0
001BA2  07FEE5     RCALL ads1148_read_register
194:               	idac0Temp.bits.imag=imag;
001BA4  90404E     MOV.B [W14+4], W0
001BA6  604067     AND.B W0, #0x7, W0
001BA8  604067     AND.B W0, #0x7, W0
001BAA  78411E     MOV.B [W14], W2
001BAC  B3CF81     MOV.B #0xF8, W1
001BAE  614081     AND.B W2, W1, W1
001BB0  70C000     IOR.B W1, W0, W0
001BB2  784F00     MOV.B W0, [W14]
195:                   ads1148_write_register(obj,ADS1148_REG_ADDR_IDAC0,(uint8_t*)&idac0Temp,1);
001BB4  B3C013     MOV.B #0x1, W3
001BB6  78010E     MOV W14, W2
001BB8  B3C0A1     MOV.B #0xA, W1
001BBA  90001E     MOV [W14+2], W0
001BBC  07FE9F     RCALL ads1148_write_register
196:               }
001BBE  FA8000     ULNK
001BC0  060000     RETURN
197:               
198:               void ads1148_set_drdy_mode(ads1148Obj_t* obj,uint8_t mode)
199:               {
001BC2  FA0006     LNK #0x6
001BC4  980710     MOV W0, [W14+2]
001BC6  984741     MOV.B W1, [W14+4]
200:                   ads1148RegIDAC0_t idac0Temp;
201:               	ads1148_read_register(obj,ADS1148_REG_ADDR_IDAC0,(uint8_t*)&idac0Temp,1);
001BC8  B3C013     MOV.B #0x1, W3
001BCA  78010E     MOV W14, W2
001BCC  B3C0A1     MOV.B #0xA, W1
001BCE  90001E     MOV [W14+2], W0
001BD0  07FECE     RCALL ads1148_read_register
202:               	idac0Temp.bits.drdyMode=mode;
001BD2  90404E     MOV.B [W14+4], W0
001BD4  604061     AND.B W0, #0x1, W0
001BD6  6040E1     AND.B W0, #0x1, W1
001BD8  200030     MOV #0x3, W0
001BDA  DD0800     SL W1, W0, W0
001BDC  78409E     MOV.B [W14], W1
001BDE  A13401     BCLR.B W1, #3
001BE0  70C000     IOR.B W1, W0, W0
001BE2  784F00     MOV.B W0, [W14]
203:                   ads1148_write_register(obj,ADS1148_REG_ADDR_IDAC0,(uint8_t*)&idac0Temp,1);
001BE4  B3C013     MOV.B #0x1, W3
001BE6  78010E     MOV W14, W2
001BE8  B3C0A1     MOV.B #0xA, W1
001BEA  90001E     MOV [W14+2], W0
001BEC  07FE87     RCALL ads1148_write_register
204:               }
001BEE  FA8000     ULNK
001BF0  060000     RETURN
205:               
206:               void ads1148_set_idac1_pins(ads1148Obj_t* obj,uint8_t i1dir)
207:               {
001BF2  FA0006     LNK #0x6
001BF4  980710     MOV W0, [W14+2]
001BF6  984741     MOV.B W1, [W14+4]
208:                   ads1148RegIDAC1_t idac1Temp;
209:               	ads1148_read_register(obj,ADS1148_REG_ADDR_IDAC1,(uint8_t*)&idac1Temp,1);
001BF8  B3C013     MOV.B #0x1, W3
001BFA  78010E     MOV W14, W2
001BFC  B3C0B1     MOV.B #0xB, W1
001BFE  90001E     MOV [W14+2], W0
001C00  07FEB6     RCALL ads1148_read_register
210:               	idac1Temp.bits.i1dir=i1dir;
001C02  90404E     MOV.B [W14+4], W0
001C04  6040EF     AND.B W0, #0xF, W1
001C06  200040     MOV #0x4, W0
001C08  DD0800     SL W1, W0, W0
001C0A  78409E     MOV.B [W14], W1
001C0C  60C0EF     AND.B W1, #0xF, W1
001C0E  70C000     IOR.B W1, W0, W0
001C10  784F00     MOV.B W0, [W14]
211:                   ads1148_write_register(obj,ADS1148_REG_ADDR_IDAC1,(uint8_t*)&idac1Temp,1);
001C12  B3C013     MOV.B #0x1, W3
001C14  78010E     MOV W14, W2
001C16  B3C0B1     MOV.B #0xB, W1
001C18  90001E     MOV [W14+2], W0
001C1A  07FE70     RCALL ads1148_write_register
212:               }
001C1C  FA8000     ULNK
001C1E  060000     RETURN
213:               
214:               void ads1148_set_idac2_pins(ads1148Obj_t* obj,uint8_t i2dir)
215:               {
001C20  FA0006     LNK #0x6
001C22  980710     MOV W0, [W14+2]
001C24  984741     MOV.B W1, [W14+4]
216:                   ads1148RegIDAC1_t idac1Temp;
217:               	ads1148_read_register(obj,ADS1148_REG_ADDR_IDAC1,(uint8_t*)&idac1Temp,1);
001C26  B3C013     MOV.B #0x1, W3
001C28  78010E     MOV W14, W2
001C2A  B3C0B1     MOV.B #0xB, W1
001C2C  90001E     MOV [W14+2], W0
001C2E  07FE9F     RCALL ads1148_read_register
218:               	idac1Temp.bits.i2dir=i2dir;
001C30  90404E     MOV.B [W14+4], W0
001C32  60406F     AND.B W0, #0xF, W0
001C34  60406F     AND.B W0, #0xF, W0
001C36  78411E     MOV.B [W14], W2
001C38  B3CF01     MOV.B #0xF0, W1
001C3A  614081     AND.B W2, W1, W1
001C3C  70C000     IOR.B W1, W0, W0
001C3E  784F00     MOV.B W0, [W14]
219:                   ads1148_write_register(obj,ADS1148_REG_ADDR_IDAC1,(uint8_t*)&idac1Temp,1);
001C40  B3C013     MOV.B #0x1, W3
001C42  78010E     MOV W14, W2
001C44  B3C0B1     MOV.B #0xB, W1
001C46  90001E     MOV [W14+2], W0
001C48  07FE59     RCALL ads1148_write_register
220:               }
001C4A  FA8000     ULNK
001C4C  060000     RETURN
221:               
222:               void ads1148_set_idac12_pins(ads1148Obj_t* obj,uint8_t i1dir,uint8_t i2dir)
223:               {
001C4E  FA0006     LNK #0x6
001C50  980710     MOV W0, [W14+2]
001C52  984741     MOV.B W1, [W14+4]
001C54  984752     MOV.B W2, [W14+5]
224:                   ads1148RegIDAC1_t idac1Temp;
225:               	ads1148_read_register(obj,ADS1148_REG_ADDR_IDAC1,(uint8_t*)&idac1Temp,1);
001C56  B3C013     MOV.B #0x1, W3
001C58  78010E     MOV W14, W2
001C5A  B3C0B1     MOV.B #0xB, W1
001C5C  90001E     MOV [W14+2], W0
001C5E  07FE87     RCALL ads1148_read_register
226:               	idac1Temp.bits.i2dir=i2dir;
001C60  90405E     MOV.B [W14+5], W0
001C62  60406F     AND.B W0, #0xF, W0
001C64  60406F     AND.B W0, #0xF, W0
001C66  78411E     MOV.B [W14], W2
001C68  B3CF01     MOV.B #0xF0, W1
001C6A  614081     AND.B W2, W1, W1
001C6C  70C000     IOR.B W1, W0, W0
001C6E  784F00     MOV.B W0, [W14]
227:                   idac1Temp.bits.i1dir=i1dir;
001C70  90404E     MOV.B [W14+4], W0
001C72  6040EF     AND.B W0, #0xF, W1
001C74  200040     MOV #0x4, W0
001C76  DD0800     SL W1, W0, W0
001C78  78409E     MOV.B [W14], W1
001C7A  60C0EF     AND.B W1, #0xF, W1
001C7C  70C000     IOR.B W1, W0, W0
001C7E  784F00     MOV.B W0, [W14]
228:                   ads1148_write_register(obj,ADS1148_REG_ADDR_IDAC1,(uint8_t*)&idac1Temp,1);
001C80  B3C013     MOV.B #0x1, W3
001C82  78010E     MOV W14, W2
001C84  B3C0B1     MOV.B #0xB, W1
001C86  90001E     MOV [W14+2], W0
001C88  07FE39     RCALL ads1148_write_register
229:               }
001C8A  FA8000     ULNK
001C8C  060000     RETURN
230:               
231:               void ads1148_get_all_register(ads1148Obj_t* obj)
232:               {
001C8E  FA0002     LNK #0x2
001C90  780F00     MOV W0, [W14]
233:               	ads1148_read_register(obj,ADS1148_REG_ADDR_MUX0,obj->ads1148Regs.buf,14);
001C92  78009E     MOV [W14], W1
001C94  40807C     ADD W1, #0x1C, W0
001C96  B3C0E3     MOV.B #0xE, W3
001C98  780100     MOV W0, W2
001C9A  EB4080     CLR.B W1
001C9C  78001E     MOV [W14], W0
001C9E  07FE67     RCALL ads1148_read_register
234:               }
001CA0  FA8000     ULNK
001CA2  060000     RETURN
235:               //
236:               void ads1148_init_obj_0(void)
237:               {
001CA4  FA0000     LNK #0x0
238:               	ads1148Chip0.chipNm=0;
001CA6  208AC0     MOV #0x8AC, W0
001CA8  EB4080     CLR.B W1
001CAA  784801     MOV.B W1, [W0]
239:                   ads1148Chip0.pins_sck_set_hight=ads1148_hal_sck_set_hight;
001CAC  226F40     MOV #0x26F4, W0
001CAE  884410     MOV W0, 0x882
240:                   ads1148Chip0.pins_sck_set_low=ads1148_hal_sck_set_low;
001CB0  227000     MOV #0x2700, W0
001CB2  884400     MOV W0, 0x880
241:                   
242:                   ads1148Chip0.pins_dout_set_hight=ads1148_hal_dout_set_hight;
001CB4  227560     MOV #0x2756, W0
001CB6  884440     MOV W0, 0x888
243:                   ads1148Chip0.pins_dout_set_low=ads1148_hal_dout_set_low;
001CB8  227620     MOV #0x2762, W0
001CBA  884430     MOV W0, 0x886
244:                   
245:                   ads1148Chip0.pins_din_get=ads1148_hal_din_get;
001CBC  227300     MOV #0x2730, W0
001CBE  884420     MOV W0, 0x884
246:                   
247:                   ads1148Chip0.pins_cs_set_hight=ads1148_hal_cs_0_set_hight;
001CC0  227D00     MOV #0x27D0, W0
001CC2  884460     MOV W0, 0x88C
248:                   ads1148Chip0.pins_cs_set_low=ads1148_hal_cs_0_set_low;
001CC4  227DC0     MOV #0x27DC, W0
001CC6  884450     MOV W0, 0x88A
249:                   
250:                   ads1148Chip0.pins_start_set_hight=ads1148_hal_start_0_set_hight;
001CC8  228060     MOV #0x2806, W0
001CCA  884470     MOV W0, 0x88E
251:                   ads1148Chip0.pins_start_set_low=ads1148_hal_start_0_set_low;
001CCC  228120     MOV #0x2812, W0
001CCE  884480     MOV W0, 0x890
252:                   
253:                   ads1148Chip0.pins_drdy_get=ads1148_hal_drdy_0_get;
001CD0  227960     MOV #0x2796, W0
001CD2  8844A0     MOV W0, 0x894
254:                   
255:                   ads1148Chip0.pins_init=ads1148_hal_port_init_chip0;
001CD4  229160     MOV #0x2916, W0
001CD6  8843E0     MOV W0, ads1148Chip0
256:                   ads1148Chip0.ads1148_write_read_via_spi=ads1148_hal_write_read_byte;
001CD8  2295E0     MOV #0x295E, W0
001CDA  8844B0     MOV W0, 0x896
257:                
258:               }
001CDC  FA8000     ULNK
001CDE  060000     RETURN
259:               void ads1148_init_obj_1(void)
260:               {
001CE0  FA0000     LNK #0x0
261:               	ads1148Chip1.chipNm=1;
001CE2  208DE0     MOV #0x8DE, W0
001CE4  B3C011     MOV.B #0x1, W1
001CE6  784801     MOV.B W1, [W0]
262:                   ads1148Chip1.pins_sck_set_hight=ads1148_hal_sck_set_hight;
001CE8  226F40     MOV #0x26F4, W0
001CEA  8845A0     MOV W0, 0x8B4
263:                   ads1148Chip1.pins_sck_set_low=ads1148_hal_sck_set_low;
001CEC  227000     MOV #0x2700, W0
001CEE  884590     MOV W0, 0x8B2
264:                   
265:                   ads1148Chip1.pins_dout_set_hight=ads1148_hal_dout_set_hight;
001CF0  227560     MOV #0x2756, W0
001CF2  8845D0     MOV W0, 0x8BA
266:                   ads1148Chip1.pins_dout_set_low=ads1148_hal_dout_set_low;
001CF4  227620     MOV #0x2762, W0
001CF6  8845C0     MOV W0, 0x8B8
267:                   
268:                   ads1148Chip1.pins_din_get=ads1148_hal_din_get;
001CF8  227300     MOV #0x2730, W0
001CFA  8845B0     MOV W0, 0x8B6
269:                   
270:                   ads1148Chip1.pins_cs_set_hight=ads1148_hal_cs_1_set_hight;
001CFC  228660     MOV #0x2866, W0
001CFE  8845F0     MOV W0, 0x8BE
271:                   ads1148Chip1.pins_cs_set_low=ads1148_hal_cs_1_set_low;
001D00  228720     MOV #0x2872, W0
001D02  8845E0     MOV W0, 0x8BC
272:                   
273:                   ads1148Chip1.pins_start_set_hight=ads1148_hal_start_1_set_hight;
001D04  228AE0     MOV #0x28AE, W0
001D06  884600     MOV W0, 0x8C0
274:                   ads1148Chip1.pins_start_set_low=ads1148_hal_start_1_set_low;
001D08  228BA0     MOV #0x28BA, W0
001D0A  884610     MOV W0, 0x8C2
275:                   
276:                   ads1148Chip1.pins_drdy_get=ads1148_hal_drdy_1_get;
001D0C  228420     MOV #0x2842, W0
001D0E  884630     MOV W0, 0x8C6
277:                   
278:                   ads1148Chip1.pins_init=ads1148_hal_port_init_chip1;
001D10  2293A0     MOV #0x293A, W0
001D12  884570     MOV W0, ads1148Chip1
279:                   ads1148Chip1.ads1148_write_read_via_spi=ads1148_hal_write_read_byte;
001D14  2295E0     MOV #0x295E, W0
001D16  884640     MOV W0, _lcd_disp_level
280:               }
001D18  FA8000     ULNK
001D1A  060000     RETURN
281:               void ads1148_set_sync(ads1148Obj_t* obj)
282:               {
001D1C  FA0004     LNK #0x4
001D1E  980710     MOV W0, [W14+2]
283:                   uint8_t ret;
284:               	#if ADS1148_SCK_IDLE_STATUE==0
285:                   obj->pins_sck_set_low();
001D20  90001E     MOV [W14+2], W0
001D22  900020     MOV [W0+4], W0
001D24  010000     CALL W0
286:               	#else
287:               	obj->pins_sck_set_hight();
288:               	#endif
289:               	obj->pins_cs_set_low();
001D26  90001E     MOV [W14+2], W0
001D28  900070     MOV [W0+14], W0
001D2A  010000     CALL W0
290:                   //ret=obj->ads1148_write_read_via_spi(ADS1148_CMD_RESET);
291:                   //delay_ms(1);
292:                   ret=obj->ads1148_write_read_via_spi(ADS1148_CMD_SYNC);
001D2C  90001E     MOV [W14+2], W0
001D2E  9008D0     MOV [W0+26], W1
001D30  B3C050     MOV.B #0x5, W0
001D32  010001     CALL W1
001D34  784F00     MOV.B W0, [W14]
293:                   //delay_ms(1);
294:                   ret=obj->ads1148_write_read_via_spi(ADS1148_CMD_SYNC);
001D36  90001E     MOV [W14+2], W0
001D38  9008D0     MOV [W0+26], W1
001D3A  B3C050     MOV.B #0x5, W0
001D3C  010001     CALL W1
001D3E  784F00     MOV.B W0, [W14]
295:               	delay_ms(1);
001D40  200010     MOV #0x1, W0
001D42  070B05     RCALL delay_ms
296:               	obj->pins_cs_set_hight();
001D44  90001E     MOV [W14+2], W0
001D46  900800     MOV [W0+16], W0
001D48  010000     CALL W0
297:               	delay_us(2);
001D4A  200020     MOV #0x2, W0
001D4C  070AEC     RCALL delay_us
298:               }
001D4E  FA8000     ULNK
001D50  060000     RETURN
299:               const uint8_t ads1148DefaultBuf[]={1,0,0,0,0,0,0,0,0,0x40,0x90,0xff};
300:               
301:               void ads1148_init_chip_regs(ads1148Obj_t* obj)
302:               {
001D52  FA0004     LNK #0x4
001D54  980710     MOV W0, [W14+2]
303:               	uint16_t t16;
304:                   //float f;
305:               	obj->pins_init();
001D56  90001E     MOV [W14+2], W0
001D58  780010     MOV [W0], W0
001D5A  010000     CALL W0
306:               	ads1148_send_cmd(obj,ADS1148_CMD_RESET);
001D5C  B3C071     MOV.B #0x7, W1
001D5E  90001E     MOV [W14+2], W0
001D60  07FD82     RCALL ads1148_send_cmd
307:                   delay_ms(10);
001D62  2000A0     MOV #0xA, W0
001D64  070AF4     RCALL delay_ms
308:               	//delay_ms(1);
309:               	//ads1148_set_bcs(obj,ADS1148_BCS_2uA0);
310:               	ads1148_set_vref(obj,ADS1148_REFSELT_INREF);
001D66  B3C021     MOV.B #0x2, W1
001D68  90001E     MOV [W14+2], W0
001D6A  07FE9D     RCALL ads1148_set_vref
311:               	//ads1148_set_data_rate(obj,ADS1148_SYS0_DR_2000SPS);
312:               	ads1148_set_muxcal(obj,ADS1148_MUXCAL_GAIN_CALIB);
001D6C  B3C021     MOV.B #0x2, W1
001D6E  90001E     MOV [W14+2], W0
001D70  07FEC5     RCALL ads1148_set_muxcal
313:               	ads1148_set_ani_pga(obj,ADS1148_PGA_1);	
001D72  EB4080     CLR.B W1
001D74  90001E     MOV [W14+2], W0
001D76  07FEF5     RCALL ads1148_set_ani_pga
314:               	ads1148_get_all_register(obj);
001D78  90001E     MOV [W14+2], W0
001D7A  07FF89     RCALL ads1148_get_all_register
315:                   __nop();
001D7C  000000     NOP
316:               	ads1148_start_convert(obj);
001D7E  90001E     MOV [W14+2], W0
001D80  07002A     RCALL ads1148_start_convert
317:               	//delay_us(5);
318:               	ads1148_waite_convert(obj);
001D82  90001E     MOV [W14+2], W0
001D84  070036     RCALL ads1148_waite_convert
319:               	ads1148_waite_convert(obj);
001D86  90001E     MOV [W14+2], W0
001D88  070034     RCALL ads1148_waite_convert
320:                   t16=ads1148_read_data(obj);
001D8A  90001E     MOV [W14+2], W0
001D8C  07FD84     RCALL ads1148_read_data
001D8E  780F00     MOV W0, [W14]
321:               	obj->fullSacle=t16;
001D90  78009E     MOV [W14], W1
001D92  90001E     MOV [W14+2], W0
001D94  981071     MOV W1, [W0+46]
322:               	
323:               	ads1148_set_muxcal(obj,ADS1148_MUXCAL_OFFSET_CALIB);
001D96  B3C011     MOV.B #0x1, W1
001D98  90001E     MOV [W14+2], W0
001D9A  07FEB0     RCALL ads1148_set_muxcal
324:               	ads1148_waite_convert(obj);
001D9C  90001E     MOV [W14+2], W0
001D9E  070029     RCALL ads1148_waite_convert
325:               	ads1148_waite_convert(obj);
001DA0  90001E     MOV [W14+2], W0
001DA2  070027     RCALL ads1148_waite_convert
326:                   t16=ads1148_read_data(obj);
001DA4  90001E     MOV [W14+2], W0
001DA6  07FD77     RCALL ads1148_read_data
001DA8  780F00     MOV W0, [W14]
327:               	obj->offset=t16;
001DAA  78009E     MOV [W14], W1
001DAC  90001E     MOV [W14+2], W0
001DAE  981061     MOV W1, [W0+44]
328:               
329:               	ads1148_start_convert(obj);
001DB0  90001E     MOV [W14+2], W0
001DB2  070011     RCALL ads1148_start_convert
330:               	//ads1148_set_data_rate(obj,ADS1148_SYS0_DR_2000SPS);
331:               	ads1148_get_all_register(obj);
001DB4  90001E     MOV [W14+2], W0
001DB6  07FF6B     RCALL ads1148_get_all_register
332:               	__nop();
001DB8  000000     NOP
333:               
334:               }
001DBA  FA8000     ULNK
001DBC  060000     RETURN
335:               
336:               void ads1148_init_all_obj(void)
337:               {
001DBE  FA0000     LNK #0x0
338:               	ads1148_init_obj_0();
001DC0  07FF71     RCALL ads1148_init_obj_0
339:               	ads1148_init_obj_1();
001DC2  07FF8E     RCALL ads1148_init_obj_1
340:               }
001DC4  FA8000     ULNK
001DC6  060000     RETURN
341:               
342:               void ads1148_init_device(void)
343:               {
001DC8  FA0000     LNK #0x0
344:                   ads1148_init_chip_regs(&ads1148Chip0);
001DCA  2087C0     MOV #0x87C, W0
001DCC  07FFC2     RCALL ads1148_init_chip_regs
345:                   ads1148_init_chip_regs(&ads1148Chip1);  
001DCE  208AE0     MOV #0x8AE, W0
001DD0  07FFC0     RCALL ads1148_init_chip_regs
346:               }
001DD2  FA8000     ULNK
001DD4  060000     RETURN
347:               
348:               void ads1148_start_convert(ads1148Obj_t* obj)
349:               {
001DD6  FA0002     LNK #0x2
001DD8  780F00     MOV W0, [W14]
350:               	obj->pins_start_set_hight();
001DDA  78001E     MOV [W14], W0
001DDC  900810     MOV [W0+18], W0
001DDE  010000     CALL W0
351:               }
001DE0  FA8000     ULNK
001DE2  060000     RETURN
352:               void ads1148_stop_convert(ads1148Obj_t* obj)
353:               {
001DE4  FA0002     LNK #0x2
001DE6  780F00     MOV W0, [W14]
354:               	obj->pins_start_set_low();
001DE8  78001E     MOV [W14], W0
001DEA  900820     MOV [W0+20], W0
001DEC  010000     CALL W0
355:               }
001DEE  FA8000     ULNK
001DF0  060000     RETURN
356:               void ads1148_waite_convert(ads1148Obj_t* obj)
357:               {
001DF2  FA0002     LNK #0x2
001DF4  780F00     MOV W0, [W14]
358:                   while(!(obj->pins_drdy_get())){
001DF6  370001     BRA 0x1DFA
001DFA  78001E     MOV [W14], W0
001DFC  900840     MOV [W0+24], W0
001DFE  010000     CALL W0
001E00  E00000     CP0 W0
001E02  32FFFA     BRA Z, 0x1DF8
359:               		asm("nop");
001DF8  000000     NOP
360:                   }
361:                   while(obj->pins_drdy_get())
001E04  370001     BRA 0x1E08
001E08  78001E     MOV [W14], W0
001E0A  900840     MOV [W0+24], W0
001E0C  010000     CALL W0
001E0E  E00000     CP0 W0
001E10  3AFFFA     BRA NZ, 0x1E06
362:                   {
363:                       asm("nop");
001E06  000000     NOP
364:                   };
365:                   asm("nop");
001E12  000000     NOP
366:                   asm("nop");
001E14  000000     NOP
367:                   asm("nop");
001E16  000000     NOP
368:                   asm("nop");
001E18  000000     NOP
369:               }
001E1A  FA8000     ULNK
001E1C  060000     RETURN
370:               void ads1148_test(void)
371:               {
001E1E  FA000E     LNK #0xE
372:               	volatile uint32_t staTm,eclipsTm,convertNum;
373:                   uint16_t t16;
374:               	
375:                   ads1148_init_chip_regs(&ads1148Chip0);
001E20  2087C0     MOV #0x87C, W0
001E22  07FF97     RCALL ads1148_init_chip_regs
376:                   ads1148_init_chip_regs(&ads1148Chip1);  
001E24  208AE0     MOV #0x8AE, W0
001E26  07FF95     RCALL ads1148_init_chip_regs
377:               	
378:               	ads1148_set_muxcal(&ads1148Chip0,ADS1148_MUXCAL_AVDD_AVSS_DIV_4);
001E28  B3C061     MOV.B #0x6, W1
001E2A  2087C0     MOV #0x87C, W0
001E2C  07FE67     RCALL ads1148_set_muxcal
379:                   
380:               	ads1148_start_convert(&ads1148Chip0);
001E2E  2087C0     MOV #0x87C, W0
001E30  07FFD2     RCALL ads1148_start_convert
381:                   delay_us(5);
001E32  200050     MOV #0x5, W0
001E34  070A78     RCALL delay_us
382:               	staTm=ticker_ms_get();
001E36  0709A6     RCALL ticker_ms_get
001E38  980710     MOV W0, [W14+2]
001E3A  980721     MOV W1, [W14+4]
383:                   convertNum=0x00ul;
001E3C  B80060     MUL.UU W0, #0, W0
001E3E  980750     MOV W0, [W14+10]
001E40  980761     MOV W1, [W14+12]
384:               	while(1){
385:                       ads1148_waite_convert(&ads1148Chip0);
001E42  2087C0     MOV #0x87C, W0
001E44  07FFD6     RCALL ads1148_waite_convert
386:                       //delay_us(5);
387:                       t16=ads1148_read_data(&ads1148Chip0);
001E46  2087C0     MOV #0x87C, W0
001E48  07FD26     RCALL ads1148_read_data
001E4A  780F00     MOV W0, [W14]
388:               		__nop();
001E4C  000000     NOP
389:               		asm("nop");
001E4E  000000     NOP
390:               		eclipsTm=ticker_ms_get()-staTm;
001E50  070999     RCALL ticker_ms_get
001E52  BE0100     MOV.D W0, W2
001E54  90001E     MOV [W14+2], W0
001E56  9000AE     MOV [W14+4], W1
001E58  510000     SUB W2, W0, W0
001E5A  598081     SUBB W3, W1, W1
001E5C  980730     MOV W0, [W14+6]
001E5E  980741     MOV W1, [W14+8]
391:               		convertNum++;		
001E60  90005E     MOV [W14+10], W0
001E62  9000EE     MOV [W14+12], W1
001E64  400061     ADD W0, #0x1, W0
001E66  4880E0     ADDC W1, #0x0, W1
001E68  980750     MOV W0, [W14+10]
001E6A  980761     MOV W1, [W14+12]
392:                   }
001E6C  37FFEA     BRA 0x1E42
393:               }
---  F:/2017/cs66-b/cs66b.X/src/depend/m_string.c  ------------------------------------------------------
1:                 #include "stdint.h"
2:                 #include "m_string.h"
3:                 const uint8_t HexTable[]="0123456789abcdef";
4:                 /*
5:                 const uint8_t Bcd2HexTable[]=
6:                 {
7:                 	 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0,	//00
8:                 	10,11,12,13,14,15,16,17,18,19,00,00,00,00,00,00,	//10	
9:                 	20,21,22,23,24,25,26,27,28,29,00,00,00,00,00,00,	//20	
10:                	30,31,32,33,34,35,36,37,38,39,00,00,00,00,00,00,	//30	
11:                	40,41,42,43,44,45,46,47,48,49,00,00,00,00,00,00,	//40	
12:                	50,51,52,53,54,55,56,57,58,59,00,00,00,00,00,00,	//50	
13:                	60,61,62,63,64,65,66,67,68,69,00,00,00,00,00,00,	//60	
14:                	70,71,72,73,74,75,76,77,78,79,00,00,00,00,00,00,	//70	
15:                	80,81,82,83,84,85,86,87,88,89,00,00,00,00,00,00,	//80	
16:                	90,91,92,93,94,95,96,97,98,99,00,00,00,00,00,00,	//90	
17:                };
18:                const uint8_t Hex2BcdTable[]=
19:                {
20:                    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,  //0
21:                    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,  //1
22:                    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,  //2
23:                    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,  //3
24:                    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,  //4
25:                    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,  //5
26:                    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,  //6
27:                    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,  //7    
28:                    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,  //8
29:                    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,  //9 
30:                };
31:                */
32:                void m_mem_set(uint8_t* buf,uint8_t x,uint8_t len)
33:                {
001E6E  FA0004     LNK #0x4
001E70  780F00     MOV W0, [W14]
001E72  984721     MOV.B W1, [W14+2]
001E74  984732     MOV.B W2, [W14+3]
34:                	while(len--)
001E76  370004     BRA 0x1E80
001E80  90403E     MOV.B [W14+3], W0
001E82  FB8000     ZE W0, W0
001E84  EA0000     NEG W0, W0
001E86  DE004F     LSR W0, #15, W0
001E88  784000     MOV.B W0, W0
001E8A  9040BE     MOV.B [W14+3], W1
001E8C  E94081     DEC.B W1, W1
001E8E  984731     MOV.B W1, [W14+3]
001E90  E00400     CP0.B W0
001E92  3AFFF2     BRA NZ, 0x1E78
35:                	{
36:                		*buf++=x;
001E78  78001E     MOV [W14], W0
001E7A  9040AE     MOV.B [W14+2], W1
001E7C  784801     MOV.B W1, [W0]
001E7E  E80F1E     INC [W14], [W14]
37:                	}
38:                }
001E94  FA8000     ULNK
001E96  060000     RETURN
39:                
40:                
41:                void m_mem_cpy_len(uint8_t* d,uint8_t* s,uint16_t len)
42:                {
001E98  FA0006     LNK #0x6
001E9A  780F00     MOV W0, [W14]
001E9C  980711     MOV W1, [W14+2]
001E9E  980722     MOV W2, [W14+4]
43:                	
44:                	while(len)
001EA0  37000B     BRA 0x1EB8
001EB8  90002E     MOV [W14+4], W0
001EBA  E00000     CP0 W0
001EBC  3AFFF2     BRA NZ, 0x1EA2
45:                	{
46:                		*d++=*s++;
001EA2  90001E     MOV [W14+2], W0
001EA4  784090     MOV.B [W0], W1
001EA6  78001E     MOV [W14], W0
001EA8  784801     MOV.B W1, [W0]
001EAA  E80F1E     INC [W14], [W14]
001EAC  90001E     MOV [W14+2], W0
001EAE  E80000     INC W0, W0
001EB0  980710     MOV W0, [W14+2]
47:                		len--;
001EB2  90002E     MOV [W14+4], W0
001EB4  E90000     DEC W0, W0
001EB6  980720     MOV W0, [W14+4]
48:                	}
49:                }
001EBE  FA8000     ULNK
001EC0  060000     RETURN
50:                
51:                void m_mem_cpy(uint8_t* d,uint8_t* s)
52:                {
001EC2  FA0004     LNK #0x4
001EC4  780F00     MOV W0, [W14]
001EC6  980711     MOV W1, [W14+2]
53:                	while(*s!='\0')
001EC8  370008     BRA 0x1EDA
001EDA  90001E     MOV [W14+2], W0
001EDC  784010     MOV.B [W0], W0
001EDE  E00400     CP0.B W0
001EE0  3AFFF4     BRA NZ, 0x1ECA
54:                	{
55:                		*d++=*s++;
001ECA  90001E     MOV [W14+2], W0
001ECC  784090     MOV.B [W0], W1
001ECE  78001E     MOV [W14], W0
001ED0  784801     MOV.B W1, [W0]
001ED2  E80F1E     INC [W14], [W14]
001ED4  90001E     MOV [W14+2], W0
001ED6  E80000     INC W0, W0
001ED8  980710     MOV W0, [W14+2]
56:                	}
57:                	*d='\0';
001EE2  78001E     MOV [W14], W0
001EE4  EB4080     CLR.B W1
001EE6  784801     MOV.B W1, [W0]
58:                }
001EE8  FA8000     ULNK
001EEA  060000     RETURN
59:                
60:                uint16_t m_str_cmp(uint8_t* d,uint8_t* s)
61:                {
001EEC  FA0006     LNK #0x6
001EEE  980710     MOV W0, [W14+2]
001EF0  980721     MOV W1, [W14+4]
62:                	uint16_t ret=1;
001EF2  200010     MOV #0x1, W0
001EF4  780F00     MOV W0, [W14]
63:                	while(*d!='\0' && *s!='\0')
001EF6  37000F     BRA 0x1F16
001F16  90001E     MOV [W14+2], W0
001F18  784010     MOV.B [W0], W0
001F1A  E00400     CP0.B W0
001F1C  320004     BRA Z, 0x1F26
001F1E  90002E     MOV [W14+4], W0
001F20  784010     MOV.B [W0], W0
001F22  E00400     CP0.B W0
001F24  3AFFE9     BRA NZ, 0x1EF8
64:                	{
65:                		if(*d != *s)
001EF8  90001E     MOV [W14+2], W0
001EFA  784090     MOV.B [W0], W1
001EFC  90002E     MOV [W14+4], W0
001EFE  784010     MOV.B [W0], W0
001F00  50CF80     SUB.B W1, W0, [W15]
001F02  320003     BRA Z, 0x1F0A
66:                		{
67:                			ret=0;
001F04  EB0000     CLR W0
001F06  780F00     MOV W0, [W14]
68:                			break;
001F08  37000E     BRA 0x1F26
69:                		}
70:                		s++;d++;
001F0A  90002E     MOV [W14+4], W0
001F0C  E80000     INC W0, W0
001F0E  980720     MOV W0, [W14+4]
001F10  90001E     MOV [W14+2], W0
001F12  E80000     INC W0, W0
001F14  980710     MOV W0, [W14+2]
71:                	}
72:                	return ret;
001F26  78001E     MOV [W14], W0
73:                }
001F28  FA8000     ULNK
001F2A  060000     RETURN
74:                
75:                uint16_t m_str_cmp_len(uint8_t* d,uint8_t* s,uint8_t len)
76:                {
001F2C  FA0008     LNK #0x8
001F2E  980710     MOV W0, [W14+2]
001F30  980721     MOV W1, [W14+4]
001F32  984762     MOV.B W2, [W14+6]
77:                	uint16_t ret=1;
001F34  200010     MOV #0x1, W0
001F36  780F00     MOV W0, [W14]
78:                	while(len--)
001F38  37000F     BRA 0x1F58
001F58  90406E     MOV.B [W14+6], W0
001F5A  FB8000     ZE W0, W0
001F5C  EA0000     NEG W0, W0
001F5E  DE004F     LSR W0, #15, W0
001F60  784000     MOV.B W0, W0
001F62  9040EE     MOV.B [W14+6], W1
001F64  E94081     DEC.B W1, W1
001F66  984761     MOV.B W1, [W14+6]
001F68  E00400     CP0.B W0
001F6A  3AFFE7     BRA NZ, 0x1F3A
79:                	{
80:                		if(*d != *s)
001F3A  90001E     MOV [W14+2], W0
001F3C  784090     MOV.B [W0], W1
001F3E  90002E     MOV [W14+4], W0
001F40  784010     MOV.B [W0], W0
001F42  50CF80     SUB.B W1, W0, [W15]
001F44  320003     BRA Z, 0x1F4C
81:                		{
82:                			ret=0;
001F46  EB0000     CLR W0
001F48  780F00     MOV W0, [W14]
83:                			break;
001F4A  370010     BRA 0x1F6C
84:                		}
85:                		s++;d++;
001F4C  90002E     MOV [W14+4], W0
001F4E  E80000     INC W0, W0
001F50  980720     MOV W0, [W14+4]
001F52  90001E     MOV [W14+2], W0
001F54  E80000     INC W0, W0
001F56  980710     MOV W0, [W14+2]
86:                	}
87:                	return ret;
001F6C  78001E     MOV [W14], W0
88:                }
001F6E  FA8000     ULNK
001F70  060000     RETURN
89:                /*
90:                uint16_t m_str_match(uint8_t* b,uint8_t* c)
91:                {
92:                	uint8_t *bb,*cc;
93:                	uint16_t ret=0;
94:                	while(*b!='\0' )
95:                	{
96:                		cc=c;
97:                		bb=b++;
98:                		ret=0;
99:                		while(*bb!='\0' && *cc!='\0')
100:               		{
101:               			if(*bb!=*cc)
102:               			{
103:               				ret=0;
104:               				break;
105:               			}
106:               			bb++;
107:               			cc++;
108:               		}
109:               		if(*cc=='\0')
110:               		{
111:               			//if(ret)return ret;
112:               			//ret=1;
113:               			return 1;
114:               		}
115:               	}
116:               	return ret;
117:               }
118:               */
119:               int32_t m_math_pow(int32_t x,uint8_t y)
120:               {
001F72  FA000A     LNK #0xA
001F74  980720     MOV W0, [W14+4]
001F76  980731     MOV W1, [W14+6]
001F78  984F02     MOV.B W2, [W14+8]
121:               	int32_t ret=1;
001F7A  200010     MOV #0x1, W0
001F7C  200001     MOV #0x0, W1
001F7E  BE8F00     MOV.D W0, [W14]
122:               	if(y==0)return 1;
001F80  90480E     MOV.B [W14+8], W0
001F82  E00400     CP0.B W0
001F84  3A0014     BRA NZ, 0x1FAE
001F86  200010     MOV #0x1, W0
001F88  200001     MOV #0x0, W1
001F8A  37001D     BRA 0x1FC6
123:               	while(y--)
001FAE  000000     NOP
001FB0  90480E     MOV.B [W14+8], W0
001FB2  FB8000     ZE W0, W0
001FB4  EA0000     NEG W0, W0
001FB6  DE004F     LSR W0, #15, W0
001FB8  784000     MOV.B W0, W0
001FBA  90488E     MOV.B [W14+8], W1
001FBC  E94081     DEC.B W1, W1
001FBE  984F01     MOV.B W1, [W14+8]
001FC0  E00400     CP0.B W0
001FC2  3AFFE4     BRA NZ, 0x1F8C
124:               	{
125:               		ret*=x;
001F8C  90009E     MOV [W14+2], W1
001F8E  90002E     MOV [W14+4], W0
001F90  B98800     MUL.SS W1, W0, W0
001F92  780100     MOV W0, W2
001F94  9000BE     MOV [W14+6], W1
001F96  78001E     MOV [W14], W0
001F98  B98800     MUL.SS W1, W0, W0
001F9A  780000     MOV W0, W0
001F9C  410100     ADD W2, W0, W2
001F9E  78009E     MOV [W14], W1
001FA0  90002E     MOV [W14+4], W0
001FA2  B80800     MUL.UU W1, W0, W0
001FA4  410101     ADD W2, W1, W2
001FA6  780082     MOV W2, W1
001FA8  BE8F00     MOV.D W0, [W14]
001FAA  BE8F00     MOV.D W0, [W14]
001FAC  370001     BRA 0x1FB0
126:               	}
127:               	return ret;
001FC4  BE001E     MOV.D [W14], W0
128:               }
001FC6  FA8000     ULNK
001FC8  060000     RETURN
129:               
130:               void m_int_2_str(uint8_t* buf,int32_t x,uint8_t len)
131:               {
001FCA  FA000C     LNK #0xC
001FCC  980720     MOV W0, [W14+4]
001FCE  980732     MOV W2, [W14+6]
001FD0  980743     MOV W3, [W14+8]
001FD2  984F21     MOV.B W1, [W14+10]
132:               	int32_t t;
133:               	if(!len)return;
001FD4  90482E     MOV.B [W14+10], W0
001FD6  E00400     CP0.B W0
001FD8  320037     BRA Z, 0x2048
002048  000000     NOP
134:               	
135:               	t=m_math_pow(10,len);
001FDA  90492E     MOV.B [W14+10], W2
001FDC  2000A0     MOV #0xA, W0
001FDE  200001     MOV #0x0, W1
001FE0  07FFC8     RCALL m_math_pow
001FE2  BE8F00     MOV.D W0, [W14]
136:               	if(x>=t-1)x=t-1;
001FE4  EB8200     SETM W4
001FE6  EB8280     SETM W5
001FE8  42013E     ADD W4, [W14++], W2
001FEA  4A81AE     ADDC W5, [W14--], W3
001FEC  90003E     MOV [W14+6], W0
001FEE  9000CE     MOV [W14+8], W1
001FF0  510F80     SUB W2, W0, [W15]
001FF2  598F81     SUBB W3, W1, [W15]
001FF4  3C001D     BRA GT, 0x2030
001FF6  EB8100     SETM W2
001FF8  EB8180     SETM W3
001FFA  41003E     ADD W2, [W14++], W0
001FFC  4980AE     ADDC W3, [W14--], W1
001FFE  980730     MOV W0, [W14+6]
002000  980741     MOV W1, [W14+8]
137:               	while(len--)
002002  370017     BRA 0x2032
002030  000000     NOP
002032  90482E     MOV.B [W14+10], W0
002034  FB8000     ZE W0, W0
002036  EA0000     NEG W0, W0
002038  DE004F     LSR W0, #15, W0
00203A  784000     MOV.B W0, W0
00203C  9048AE     MOV.B [W14+10], W1
00203E  E94081     DEC.B W1, W1
002040  984F21     MOV.B W1, [W14+10]
002042  E00400     CP0.B W0
002044  3AFFDF     BRA NZ, 0x2004
002046  370001     BRA 0x204A
138:               	{
139:               		t=x%10;
002004  90003E     MOV [W14+6], W0
002006  9000CE     MOV [W14+8], W1
002008  2000A2     MOV #0xA, W2
00200A  200003     MOV #0x0, W3
00200C  07F1BB     RCALL ___modsi3
00200E  BE8F00     MOV.D W0, [W14]
140:               		*buf--=HexTable[t];
002010  284EA0     MOV #0x84EA, W0
002012  40001E     ADD W0, [W14], W0
002014  784090     MOV.B [W0], W1
002016  90002E     MOV [W14+4], W0
002018  784801     MOV.B W1, [W0]
00201A  90002E     MOV [W14+4], W0
00201C  E90000     DEC W0, W0
00201E  980720     MOV W0, [W14+4]
141:               		x/=10;
002020  90003E     MOV [W14+6], W0
002022  9000CE     MOV [W14+8], W1
002024  2000A2     MOV #0xA, W2
002026  200003     MOV #0x0, W3
002028  07F19E     RCALL ___divsi3
00202A  980730     MOV W0, [W14+6]
00202C  980741     MOV W1, [W14+8]
00202E  370001     BRA 0x2032
142:               	}
143:               }
00204A  FA8000     ULNK
00204C  060000     RETURN
144:               
145:               
146:               uint8_t m_str_head_hide(uint8_t* str,uint8_t loc)
147:               {
00204E  FA0006     LNK #0x6
002050  980710     MOV W0, [W14+2]
002052  984741     MOV.B W1, [W14+4]
148:               	uint8_t ret=0;
002054  EB4000     CLR.B W0
002056  784F00     MOV.B W0, [W14]
149:               	while(loc--)
002058  37000C     BRA 0x2072
002072  90404E     MOV.B [W14+4], W0
002074  FB8000     ZE W0, W0
002076  EA0000     NEG W0, W0
002078  DE004F     LSR W0, #15, W0
00207A  784000     MOV.B W0, W0
00207C  9040CE     MOV.B [W14+4], W1
00207E  E94081     DEC.B W1, W1
002080  984741     MOV.B W1, [W14+4]
002082  E00400     CP0.B W0
002084  3AFFEA     BRA NZ, 0x205A
002086  370001     BRA 0x208A
150:               	{
151:               		if(*str=='0')
00205A  90001E     MOV [W14+2], W0
00205C  784090     MOV.B [W0], W1
00205E  B3C300     MOV.B #0x30, W0
002060  50CF80     SUB.B W1, W0, [W15]
002062  3A0012     BRA NZ, 0x2088
152:               		{
153:               			*str++=' ';
002064  90001E     MOV [W14+2], W0
002066  B3C201     MOV.B #0x20, W1
002068  784801     MOV.B W1, [W0]
00206A  90001E     MOV [W14+2], W0
00206C  E80000     INC W0, W0
00206E  980710     MOV W0, [W14+2]
154:               			ret++;
002070  E84F1E     INC.B [W14], [W14]
155:               		}
156:               		else
157:               		{
158:               			break;
002088  000000     NOP
159:               		}
160:               	}
161:               	return ret;
00208A  78401E     MOV.B [W14], W0
162:               }
00208C  FA8000     ULNK
00208E  060000     RETURN
163:               
164:               uint16_t HEX8(uint8_t* hex,uint8_t x)
165:               {
002090  FA0004     LNK #0x4
002092  780F00     MOV W0, [W14]
002094  984721     MOV.B W1, [W14+2]
166:               	*hex++=HexTable[(x&0xf0)>>4];
002096  90402E     MOV.B [W14+2], W0
002098  FB8000     ZE W0, W0
00209A  DE0044     LSR W0, #4, W0
00209C  784000     MOV.B W0, W0
00209E  FB8000     ZE W0, W0
0020A0  284EA1     MOV #0x84EA, W1
0020A2  7840E1     MOV.B [W1+W0], W1
0020A4  78001E     MOV [W14], W0
0020A6  784801     MOV.B W1, [W0]
0020A8  E80F1E     INC [W14], [W14]
167:               	*hex++=HexTable[(x&0x0f)];
0020AA  90402E     MOV.B [W14+2], W0
0020AC  FB8000     ZE W0, W0
0020AE  60006F     AND W0, #0xF, W0
0020B0  284EA1     MOV #0x84EA, W1
0020B2  7840E1     MOV.B [W1+W0], W1
0020B4  78001E     MOV [W14], W0
0020B6  784801     MOV.B W1, [W0]
0020B8  E80F1E     INC [W14], [W14]
168:               	hex='\0';
0020BA  EB0000     CLR W0
0020BC  780F00     MOV W0, [W14]
169:                   return 3;
0020BE  200030     MOV #0x3, W0
170:               }
0020C0  FA8000     ULNK
0020C2  060000     RETURN
171:               
172:               
173:               uint16_t m_str_b2h(uint8_t* h,uint8_t* b,uint16_t len)
174:                {
0020C4  FA000A     LNK #0xA
0020C6  980720     MOV W0, [W14+4]
0020C8  980731     MOV W1, [W14+6]
0020CA  980742     MOV W2, [W14+8]
175:               	 uint16_t i=0;
0020CC  EB0000     CLR W0
0020CE  780F00     MOV W0, [W14]
176:               	 uint8_t t8;
177:               	 for(i=0;i<len;i++)
0020D0  EB0000     CLR W0
0020D2  780F00     MOV W0, [W14]
0020D4  37001D     BRA 0x2110
00210E  E80F1E     INC [W14], [W14]
002110  90004E     MOV [W14+8], W0
002112  78009E     MOV [W14], W1
002114  508F80     SUB W1, W0, [W15]
002116  39FFDF     BRA NC, 0x20D6
178:               	 {
179:               		 t8=*b++;
0020D6  90003E     MOV [W14+6], W0
0020D8  784090     MOV.B [W0], W1
0020DA  984721     MOV.B W1, [W14+2]
0020DC  90003E     MOV [W14+6], W0
0020DE  E80000     INC W0, W0
0020E0  980730     MOV W0, [W14+6]
180:               		 *h++=HexTable[(t8&0xf0)>>4];
0020E2  90402E     MOV.B [W14+2], W0
0020E4  FB8000     ZE W0, W0
0020E6  DE0044     LSR W0, #4, W0
0020E8  784000     MOV.B W0, W0
0020EA  FB8000     ZE W0, W0
0020EC  284EA1     MOV #0x84EA, W1
0020EE  7840E1     MOV.B [W1+W0], W1
0020F0  90002E     MOV [W14+4], W0
0020F2  784801     MOV.B W1, [W0]
0020F4  90002E     MOV [W14+4], W0
0020F6  E80000     INC W0, W0
0020F8  980720     MOV W0, [W14+4]
181:               		 *h++=HexTable[(t8&0x0f)];
0020FA  90402E     MOV.B [W14+2], W0
0020FC  FB8000     ZE W0, W0
0020FE  60006F     AND W0, #0xF, W0
002100  284EA1     MOV #0x84EA, W1
002102  7840E1     MOV.B [W1+W0], W1
002104  90002E     MOV [W14+4], W0
002106  784801     MOV.B W1, [W0]
002108  90002E     MOV [W14+4], W0
00210A  E80000     INC W0, W0
00210C  980720     MOV W0, [W14+4]
182:               	 }
183:               	 return (len<<1);
002118  90004E     MOV [W14+8], W0
00211A  400000     ADD W0, W0, W0
184:                }
00211C  FA8000     ULNK
00211E  060000     RETURN
185:                
186:               #define _chr2hex(h,c) do{ \
187:                   if(c>='0' && c <='9')h|=(c-'0'); \
188:                   else if(c>='A' && c<='F')h|=(c-'A'+0x0a); \
189:                   else if(c>='a' && c<='f')h|=(c-'a'+0x0a); \
190:                   else h|=0; \
191:               }while(0);
192:               
193:               
194:               uint16_t m_str_h2b(uint8_t* b,uint8_t* h,uint16_t len)
195:                {
002120  FA000A     LNK #0xA
002122  980720     MOV W0, [W14+4]
002124  980731     MOV W1, [W14+6]
002126  980742     MOV W2, [W14+8]
196:               	uint16_t i=len;
002128  9000CE     MOV [W14+8], W1
00212A  780F01     MOV W1, [W14]
197:               	uint8_t bb,s;
198:               	while(i>=2)
00212C  370077     BRA 0x221C
00221C  78001E     MOV [W14], W0
00221E  500FE1     SUB W0, #0x1, [W15]
002220  3EFF86     BRA GTU, 0x212E
199:               	{
200:                       bb=0;
00212E  EB4000     CLR.B W0
002130  984720     MOV.B W0, [W14+2]
201:                       s=*h++;
002132  90003E     MOV [W14+6], W0
002134  784090     MOV.B [W0], W1
002136  984731     MOV.B W1, [W14+3]
002138  90003E     MOV [W14+6], W0
00213A  E80000     INC W0, W0
00213C  980730     MOV W0, [W14+6]
202:                       _chr2hex(bb,s);
00213E  9040BE     MOV.B [W14+3], W1
002140  B3C2F0     MOV.B #0x2F, W0
002142  50CF80     SUB.B W1, W0, [W15]
002144  36000C     BRA LEU, 0x215E
002146  9040BE     MOV.B [W14+3], W1
002148  B3C390     MOV.B #0x39, W0
00214A  50CF80     SUB.B W1, W0, [W15]
00214C  3E0008     BRA GTU, 0x215E
00214E  9040BE     MOV.B [W14+3], W1
002150  B3CD00     MOV.B #0xD0, W0
002152  40C000     ADD.B W1, W0, W0
002154  784080     MOV.B W0, W1
002156  90402E     MOV.B [W14+2], W0
002158  70C000     IOR.B W1, W0, W0
00215A  984720     MOV.B W0, [W14+2]
00215C  37001F     BRA 0x219C
00215E  9040BE     MOV.B [W14+3], W1
002160  B3C400     MOV.B #0x40, W0
002162  50CF80     SUB.B W1, W0, [W15]
002164  36000C     BRA LEU, 0x217E
002166  9040BE     MOV.B [W14+3], W1
002168  B3C460     MOV.B #0x46, W0
00216A  50CF80     SUB.B W1, W0, [W15]
00216C  3E0008     BRA GTU, 0x217E
00216E  9040BE     MOV.B [W14+3], W1
002170  B3CC90     MOV.B #0xC9, W0
002172  40C000     ADD.B W1, W0, W0
002174  784080     MOV.B W0, W1
002176  90402E     MOV.B [W14+2], W0
002178  70C000     IOR.B W1, W0, W0
00217A  984720     MOV.B W0, [W14+2]
00217C  37000F     BRA 0x219C
00217E  9040BE     MOV.B [W14+3], W1
002180  B3C600     MOV.B #0x60, W0
002182  50CF80     SUB.B W1, W0, [W15]
002184  36000B     BRA LEU, 0x219C
002186  9040BE     MOV.B [W14+3], W1
002188  B3C660     MOV.B #0x66, W0
00218A  50CF80     SUB.B W1, W0, [W15]
00218C  3E0007     BRA GTU, 0x219C
00218E  9040BE     MOV.B [W14+3], W1
002190  B3CA90     MOV.B #0xA9, W0
002192  40C000     ADD.B W1, W0, W0
002194  784080     MOV.B W0, W1
002196  90402E     MOV.B [W14+2], W0
002198  70C000     IOR.B W1, W0, W0
00219A  984720     MOV.B W0, [W14+2]
203:                       bb<<=4;
00219C  9040AE     MOV.B [W14+2], W1
00219E  200040     MOV #0x4, W0
0021A0  DD0800     SL W1, W0, W0
0021A2  984720     MOV.B W0, [W14+2]
204:                       s=*h++;
0021A4  90003E     MOV [W14+6], W0
0021A6  784090     MOV.B [W0], W1
0021A8  984731     MOV.B W1, [W14+3]
0021AA  90003E     MOV [W14+6], W0
0021AC  E80000     INC W0, W0
0021AE  980730     MOV W0, [W14+6]
205:                       _chr2hex(bb,s);
0021B0  9040BE     MOV.B [W14+3], W1
0021B2  B3C2F0     MOV.B #0x2F, W0
0021B4  50CF80     SUB.B W1, W0, [W15]
0021B6  36000C     BRA LEU, 0x21D0
0021B8  9040BE     MOV.B [W14+3], W1
0021BA  B3C390     MOV.B #0x39, W0
0021BC  50CF80     SUB.B W1, W0, [W15]
0021BE  3E0008     BRA GTU, 0x21D0
0021C0  9040BE     MOV.B [W14+3], W1
0021C2  B3CD00     MOV.B #0xD0, W0
0021C4  40C000     ADD.B W1, W0, W0
0021C6  784080     MOV.B W0, W1
0021C8  90402E     MOV.B [W14+2], W0
0021CA  70C000     IOR.B W1, W0, W0
0021CC  984720     MOV.B W0, [W14+2]
0021CE  37001F     BRA 0x220E
0021D0  9040BE     MOV.B [W14+3], W1
0021D2  B3C400     MOV.B #0x40, W0
0021D4  50CF80     SUB.B W1, W0, [W15]
0021D6  36000C     BRA LEU, 0x21F0
0021D8  9040BE     MOV.B [W14+3], W1
0021DA  B3C460     MOV.B #0x46, W0
0021DC  50CF80     SUB.B W1, W0, [W15]
0021DE  3E0008     BRA GTU, 0x21F0
0021E0  9040BE     MOV.B [W14+3], W1
0021E2  B3CC90     MOV.B #0xC9, W0
0021E4  40C000     ADD.B W1, W0, W0
0021E6  784080     MOV.B W0, W1
0021E8  90402E     MOV.B [W14+2], W0
0021EA  70C000     IOR.B W1, W0, W0
0021EC  984720     MOV.B W0, [W14+2]
0021EE  37000F     BRA 0x220E
0021F0  9040BE     MOV.B [W14+3], W1
0021F2  B3C600     MOV.B #0x60, W0
0021F4  50CF80     SUB.B W1, W0, [W15]
0021F6  36000B     BRA LEU, 0x220E
0021F8  9040BE     MOV.B [W14+3], W1
0021FA  B3C660     MOV.B #0x66, W0
0021FC  50CF80     SUB.B W1, W0, [W15]
0021FE  3E0007     BRA GTU, 0x220E
002200  9040BE     MOV.B [W14+3], W1
002202  B3CA90     MOV.B #0xA9, W0
002204  40C000     ADD.B W1, W0, W0
002206  784080     MOV.B W0, W1
002208  90402E     MOV.B [W14+2], W0
00220A  70C000     IOR.B W1, W0, W0
00220C  984720     MOV.B W0, [W14+2]
206:                       *b++=bb;
00220E  90002E     MOV [W14+4], W0
002210  9040AE     MOV.B [W14+2], W1
002212  784801     MOV.B W1, [W0]
002214  90002E     MOV [W14+4], W0
002216  E80000     INC W0, W0
002218  980720     MOV W0, [W14+4]
207:               		i-=2;
00221A  E98F1E     DEC2 [W14], [W14]
208:               	}
209:               	return (len>>1);
002222  90004E     MOV [W14+8], W0
002224  D10000     LSR W0, W0
210:                }
002226  FA8000     ULNK
002228  060000     RETURN
211:               
212:               /*
213:               uint32_t swap_uint32(uint32_t x)
214:               {
215:                   uint32_t ret;
216:                   uint8_t *d,*s;
217:                   s=(uint8_t*)&x;
218:                   d=(uint8_t*)&ret;
219:                   d[0]=s[3];
220:                   d[1]=s[2];
221:                   d[2]=s[1];
222:                   d[3]=s[0];
223:                   return ret;
224:               }
225:               
226:               uint16_t swap_uint16(uint16_t x)
227:               {
228:                   uint16_t ret;
229:                   uint8_t *d,*s;
230:                   s=(uint8_t*)&x;
231:                   d=(uint8_t*)&ret;
232:                   d[0]=s[1];
233:                   d[1]=s[0];
234:                   return ret;    
235:               }
236:               
237:               void int32_array_shift_right(int32_t *p32,uint16_t eoc)
238:               {
239:               	while(eoc>=1){
240:               		p32[eoc]=p32[eoc-1];
241:               		eoc--;
242:               	}
243:               }
244:               */
245:               void m_int8_2_hex(uint8_t* str,uint8_t b)
246:               {
00222A  FA0006     LNK #0x6
00222C  980710     MOV W0, [W14+2]
00222E  984741     MOV.B W1, [W14+4]
247:                   uint8_t t8;
248:                   t8=b;
002230  9040CE     MOV.B [W14+4], W1
002232  784F01     MOV.B W1, [W14]
249:                   t8>>=4;
002234  FB801E     ZE [W14], W0
002236  DE0044     LSR W0, #4, W0
002238  784F00     MOV.B W0, [W14]
250:                   t8 &= 0x0f;
00223A  78409E     MOV.B [W14], W1
00223C  60CF6F     AND.B W1, #0xF, [W14]
251:                   str[0]=HexTable[t8];
00223E  FB801E     ZE [W14], W0
002240  284EA1     MOV #0x84EA, W1
002242  7840E1     MOV.B [W1+W0], W1
002244  90001E     MOV [W14+2], W0
002246  784801     MOV.B W1, [W0]
252:               
253:                   t8=b;
002248  9040CE     MOV.B [W14+4], W1
00224A  784F01     MOV.B W1, [W14]
254:                   //t8>>=4;
255:                   t8 &= 0x0f;
00224C  78409E     MOV.B [W14], W1
00224E  60CF6F     AND.B W1, #0xF, [W14]
256:                   str[1]=HexTable[t8];
002250  90001E     MOV [W14+2], W0
002252  E80000     INC W0, W0
002254  FB809E     ZE [W14], W1
002256  284EA2     MOV #0x84EA, W2
002258  78C0E2     MOV.B [W2+W1], W1
00225A  784801     MOV.B W1, [W0]
257:                   
258:                   //*str++=HexTable[(b&0xf0)>>4];
259:                   //*str=HexTable[b&0x0f];    
260:               }
00225C  FA8000     ULNK
00225E  060000     RETURN
261:               //20170910
262:               void m_int16_2_str_4(uint8_t* buf,int16_t x)
263:               {
002260  FA0006     LNK #0x6
002262  780F00     MOV W0, [W14]
002264  980711     MOV W1, [W14+2]
264:                   if(x>9999)x=9999;
002266  90009E     MOV [W14+2], W1
002268  2270F0     MOV #0x270F, W0
00226A  508F80     SUB W1, W0, [W15]
00226C  340002     BRA LE, 0x2272
00226E  2270F0     MOV #0x270F, W0
002270  980710     MOV W0, [W14+2]
265:               	buf[3]=HexTable[x%10];
002272  78001E     MOV [W14], W0
002274  400063     ADD W0, #0x3, W0
002276  980720     MOV W0, [W14+4]
002278  90011E     MOV [W14+2], W2
00227A  2000A1     MOV #0xA, W1
00227C  780181     MOV W1, W3
00227E  090011     REPEAT #0x11
002280  D80103     DIV.SW W2, W3
002282  284EA2     MOV #0x84EA, W2
002284  78C0E2     MOV.B [W2+W1], W1
002286  90002E     MOV [W14+4], W0
002288  784801     MOV.B W1, [W0]
266:               	x/=10;
00228A  90009E     MOV [W14+2], W1
00228C  2000A0     MOV #0xA, W0
00228E  780100     MOV W0, W2
002290  090011     REPEAT #0x11
002292  D80082     DIV.SW W1, W2
002294  980710     MOV W0, [W14+2]
267:               	buf[2]=HexTable[x%10];
002296  E8819E     INC2 [W14], W3
002298  980723     MOV W3, [W14+4]
00229A  90011E     MOV [W14+2], W2
00229C  2000A1     MOV #0xA, W1
00229E  780181     MOV W1, W3
0022A0  090011     REPEAT #0x11
0022A2  D80103     DIV.SW W2, W3
0022A4  284EA2     MOV #0x84EA, W2
0022A6  78C0E2     MOV.B [W2+W1], W1
0022A8  90002E     MOV [W14+4], W0
0022AA  784801     MOV.B W1, [W0]
268:               	x/=10;
0022AC  90009E     MOV [W14+2], W1
0022AE  2000A0     MOV #0xA, W0
0022B0  780100     MOV W0, W2
0022B2  090011     REPEAT #0x11
0022B4  D80082     DIV.SW W1, W2
0022B6  980710     MOV W0, [W14+2]
269:               	buf[1]=HexTable[x%10];
0022B8  E8019E     INC [W14], W3
0022BA  980723     MOV W3, [W14+4]
0022BC  90011E     MOV [W14+2], W2
0022BE  2000A1     MOV #0xA, W1
0022C0  780181     MOV W1, W3
0022C2  090011     REPEAT #0x11
0022C4  D80103     DIV.SW W2, W3
0022C6  284EA2     MOV #0x84EA, W2
0022C8  78C0E2     MOV.B [W2+W1], W1
0022CA  90002E     MOV [W14+4], W0
0022CC  784801     MOV.B W1, [W0]
270:               	x/=10;	
0022CE  90009E     MOV [W14+2], W1
0022D0  2000A0     MOV #0xA, W0
0022D2  780100     MOV W0, W2
0022D4  090011     REPEAT #0x11
0022D6  D80082     DIV.SW W1, W2
0022D8  980710     MOV W0, [W14+2]
271:               	buf[0]=HexTable[x%10];
0022DA  90009E     MOV [W14+2], W1
0022DC  2000A0     MOV #0xA, W0
0022DE  780180     MOV W0, W3
0022E0  090011     REPEAT #0x11
0022E2  D80083     DIV.SW W1, W3
0022E4  FD0080     EXCH W0, W1
0022E6  284EA1     MOV #0x84EA, W1
0022E8  7840E1     MOV.B [W1+W0], W1
0022EA  78001E     MOV [W14], W0
0022EC  784801     MOV.B W1, [W0]
272:               }
0022EE  FA8000     ULNK
0022F0  060000     RETURN
273:               //file end
---  F:/2017/cs66-b/cs66b.X/src/depend/crc16.c  ---------------------------------------------------------
1:                 //
2:                 //#include <stdint.h>
3:                 #include "crc16.h"
4:                 #include "m_string.h"
5:                 const uint8_t auchCRCHi[]=
6:                 {
7:                 	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
8:                 	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
9:                 	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
10:                	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
11:                	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
12:                	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
13:                	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
14:                	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
15:                	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
16:                	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
17:                	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
18:                	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
19:                	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
20:                	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
21:                	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
22:                	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
23:                	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
24:                	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
25:                	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
26:                	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
27:                	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
28:                	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
29:                	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
30:                	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
31:                	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
32:                	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40 
33:                };
34:                const uint8_t auchCRCLo[]=
35:                {
36:                	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 
37:                	0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 
38:                	0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
39:                	0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 
40:                	0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 
41:                	0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
42:                	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 
43:                	0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 
44:                	0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
45:                	0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 
46:                	0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 
47:                	0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
48:                	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 
49:                	0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 
50:                	0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
51:                	0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 
52:                	0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 
53:                	0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
54:                	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 
55:                	0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 
56:                	0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
57:                	0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 
58:                	0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 
59:                	0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
60:                	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 
61:                	0x43, 0x83, 0x41, 0x81, 0x80, 0x40 
62:                };
63:                uint16_t crc_sum(uint8_t *puchMsg, uint16_t usDataLen)
64:                {
000000  040200     GOTO __resetPRI, __reset
000002  000000     NOP
000004  000360     NOP
65:                    uint16_t len;
66:                    len=usDataLen;
000006  000360     NOP
000008  000360     NOP
00000A  000360     NOP
00000C  000360     NOP
67:                	uint8_t uchCRCHi = 0xFF ; /* high byte of CRC initialized */
00000A  000360     NOP
00000C  000360     NOP
68:                	uint8_t uchCRCLo = 0xFF ; /* low byte of CRC initialized */
00000E  000360     NOP
000010  000360     NOP
69:                	uint16_t uIndex ; /* will index into CRC lookup table */
70:                	while (len--) /* pass through message buffer */
000012  000360     NOP
000014  000360     NOP
000016  000360     NOP
00003E  000360     NOP
000040  000360     NOP
000042  000360     NOP
000044  000360     NOP
000046  000360     NOP
000048  000360     NOP
00004A  000360     NOP
00004C  000360     NOP
00004E  000360     NOP
71:                	{
72:                	uIndex = (uchCRCLo ^ *puchMsg++) ; /* calculate the CRC */
000014  000360     NOP
000016  000360     NOP
000018  000360     NOP
00001A  0030B2     NOP
00001C  000360     NOP
00001E  000360     NOP
000020  000360     NOP
000022  002FE6     NOP
000024  000360     NOP
73:                	uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex] ;
000026  000360     NOP
000028  000360     NOP
00002A  000360     NOP
00002C  000360     NOP
00002E  000360     NOP
000030  000360     NOP
000032  000360     NOP
74:                	uchCRCHi = auchCRCLo[uIndex] ;
000034  000360     NOP
000036  000360     NOP
000038  000360     NOP
00003A  000360     NOP
00003C  000360     NOP
75:                	}
76:                	return (uchCRCHi << 8 | uchCRCLo) ;
000050  000360     NOP
000052  000360     NOP
000054  000360     NOP
000056  000360     NOP
000058  000360     NOP
00005A  000360     NOP
00005C  000360     NOP
00005E  000360     NOP
77:                }
00005C  000360     NOP
00005E  000360     NOP
78:                uint8_t crc_verify( uint8_t* message, uint16_t n)
79:                {
000060  000360     NOP
000062  000360     NOP
000064  000360     NOP
80:                    uint16_t expected,crccal;
81:                    //uint8_t *p;
82:                	//m_mem_cpy_len((uint8_t*)(&expected),message+n-2,2);
83:                    m_mem_cpy_len((uint8_t*)(&expected),(message+n-2),2);
000066  000360     NOP
000068  000360     NOP
00006A  000360     NOP
00006C  000360     NOP
00006E  000360     NOP
000070  000360     NOP
000072  000360     NOP
84:                    crccal=crc_sum(message,n - 2);
000074  000360     NOP
000076  000360     NOP
000078  000360     NOP
00007A  000360     NOP
00007C  000360     NOP
00007E  000360     NOP
85:                	if(expected!=crccal)return 0;
000080  000360     NOP
000082  000360     NOP
000084  000360     NOP
000086  000360     NOP
000088  000360     NOP
86:                	return 1;	
00008A  000360     NOP
87:                }
00008C  000360     NOP
00008E  000360     NOP
88:                void crc_append(uint8_t* message, uint16_t n)
89:                {
000090  002FC4     NOP
000092  000360     NOP
000094  000360     NOP
000096  000360     NOP
000098  000360     NOP
90:                    uint16_t crc;
91:                    crc = crc_sum(message, n);
000096  000360     NOP
000098  000360     NOP
00009A  000360     NOP
00009C  000360     NOP
92:                    message[n] = (uint8_t)(crc & 0xff);
00009E  000360     NOP
0000A0  000360     NOP
0000A2  000360     NOP
0000A4  000360     NOP
0000A6  000360     NOP
0000A8  000360     NOP
93:                    message[n+1] = (uint8_t)((crc >> 8) & 0xff);
0000AA  000360     NOP
0000AC  000360     NOP
0000AE  000360     NOP
0000B0  000360     NOP
0000B2  000360     NOP
0000B4  000360     NOP
0000B6  000360     NOP
0000B8  000360     NOP
94:                }
0000BA  000360     NOP
0000BC  000360     NOP
95:                //file end
96:                //
---  F:/2017/cs66-b/cs66b.X/src/app/sample.c  -----------------------------------------------------------
1:                 #include "../includes/includes.h"
2:                 volatile uint8_t sampleIndex=0x00;
3:                 int16_t samlpeBuf[32];
4:                 
5:                 volatile int16_t rtAdcValueDPrBridge;
6:                 volatile int16_t rtAdcValueDPrSignal;
7:                 volatile int16_t rtAdcValuePrBridge;
8:                 volatile int16_t rtAdcValuePrSignal;
9:                 
10:                volatile int16_t rtAdcValueTemperatureIn;
11:                volatile int16_t rtAdcValueChip0Ref0;
12:                volatile int16_t rtAdcValueChip0Ref1;
13:                
14:                volatile int16_t rtAdcValuePrEx0Bridge;
15:                volatile int16_t rtAdcValuePrEx0Signal;
16:                volatile int16_t rtAdcValuePrEx1Bridge;
17:                volatile int16_t rtAdcValuePrEx1Signal;
18:                
19:                volatile int16_t rtAdcValueTemperatureEx;
20:                volatile int16_t rtAdcValueChip1Ref0;
21:                volatile int16_t rtAdcValueChip1Ref1;
22:                
23:                int16_t samlpe_get_adc_average_value(int16_t* buf,uint8_t len)
24:                {
0022F2  FA0010     LNK #0x10
0022F4  980760     MOV W0, [W14+12]
0022F6  984F61     MOV.B W1, [W14+14]
25:                    uint8_t maxIndex,minIndex;
26:                    uint8_t i,j;
27:                    int32_t ret=0;
0022F8  B80060     MUL.UU W0, #0, W0
0022FA  980720     MOV W0, [W14+4]
0022FC  980731     MOV W1, [W14+6]
28:                    int16_t max=0,min;
0022FE  EB0000     CLR W0
002300  980740     MOV W0, [W14+8]
29:                    for(j=0;j<8;j++){
002302  EB4000     CLR.B W0
002304  984730     MOV.B W0, [W14+3]
002306  370070     BRA 0x23E8
0023E2  90403E     MOV.B [W14+3], W0
0023E4  E84000     INC.B W0, W0
0023E6  984730     MOV.B W0, [W14+3]
0023E8  90403E     MOV.B [W14+3], W0
0023EA  504FE7     SUB.B W0, #0x7, [W15]
0023EC  36FF8D     BRA LEU, 0x2308
30:                        ret=0;
002308  B80060     MUL.UU W0, #0, W0
00230A  980720     MOV W0, [W14+4]
00230C  980731     MOV W1, [W14+6]
31:                        max=INT16_MIN;
00230E  280000     MOV #0x8000, W0
002310  980740     MOV W0, [W14+8]
32:                        min=INT16_MAX;
002312  27FFF0     MOV #0x7FFF, W0
002314  980750     MOV W0, [W14+10]
33:                        maxIndex=0;
002316  EB4000     CLR.B W0
002318  784F00     MOV.B W0, [W14]
34:                        minIndex=0;
00231A  EB4000     CLR.B W0
00231C  984710     MOV.B W0, [W14+1]
35:                        for(i=0;i<len;i++){
00231E  EB4000     CLR.B W0
002320  984720     MOV.B W0, [W14+2]
002322  370034     BRA 0x238C
002386  90402E     MOV.B [W14+2], W0
002388  E84000     INC.B W0, W0
00238A  984720     MOV.B W0, [W14+2]
00238C  9040AE     MOV.B [W14+2], W1
00238E  90486E     MOV.B [W14+14], W0
002390  50CF80     SUB.B W1, W0, [W15]
002392  39FFC8     BRA NC, 0x2324
36:                            if(max<buf[i]){
002324  90402E     MOV.B [W14+2], W0
002326  FB8000     ZE W0, W0
002328  400000     ADD W0, W0, W0
00232A  9000EE     MOV [W14+12], W1
00232C  408000     ADD W1, W0, W0
00232E  780090     MOV [W0], W1
002330  90004E     MOV [W14+8], W0
002332  508F80     SUB W1, W0, [W15]
002334  340009     BRA LE, 0x2348
37:                                max=buf[i];
002336  90402E     MOV.B [W14+2], W0
002338  FB8000     ZE W0, W0
00233A  400000     ADD W0, W0, W0
00233C  9000EE     MOV [W14+12], W1
00233E  408000     ADD W1, W0, W0
002340  780090     MOV [W0], W1
002342  980741     MOV W1, [W14+8]
38:                                maxIndex=i;
002344  9040AE     MOV.B [W14+2], W1
002346  784F01     MOV.B W1, [W14]
39:                            }
40:                            if(min>buf[i]){
002348  90402E     MOV.B [W14+2], W0
00234A  FB8000     ZE W0, W0
00234C  400000     ADD W0, W0, W0
00234E  9000EE     MOV [W14+12], W1
002350  408000     ADD W1, W0, W0
002352  780090     MOV [W0], W1
002354  90005E     MOV [W14+10], W0
002356  508F80     SUB W1, W0, [W15]
002358  3D0009     BRA GE, 0x236C
41:                                min=buf[i];
00235A  90402E     MOV.B [W14+2], W0
00235C  FB8000     ZE W0, W0
00235E  400000     ADD W0, W0, W0
002360  9000EE     MOV [W14+12], W1
002362  408000     ADD W1, W0, W0
002364  780090     MOV [W0], W1
002366  980751     MOV W1, [W14+10]
42:                                minIndex=i;
002368  9040AE     MOV.B [W14+2], W1
00236A  984711     MOV.B W1, [W14+1]
43:                            }
44:                            ret+=buf[i];
00236C  90402E     MOV.B [W14+2], W0
00236E  FB8000     ZE W0, W0
002370  400000     ADD W0, W0, W0
002372  9000EE     MOV [W14+12], W1
002374  408000     ADD W1, W0, W0
002376  780010     MOV [W0], W0
002378  DE80CF     ASR W0, #15, W1
00237A  90012E     MOV [W14+4], W2
00237C  9001BE     MOV [W14+6], W3
00237E  400002     ADD W0, W2, W0
002380  488083     ADDC W1, W3, W1
002382  980720     MOV W0, [W14+4]
002384  980731     MOV W1, [W14+6]
45:                        }
46:                        ret=ret-max;
002394  90004E     MOV [W14+8], W0
002396  DE80CF     ASR W0, #15, W1
002398  90012E     MOV [W14+4], W2
00239A  9001BE     MOV [W14+6], W3
00239C  510000     SUB W2, W0, W0
00239E  598081     SUBB W3, W1, W1
0023A0  980720     MOV W0, [W14+4]
0023A2  980731     MOV W1, [W14+6]
47:                        ret=ret-min;
0023A4  90005E     MOV [W14+10], W0
0023A6  DE80CF     ASR W0, #15, W1
0023A8  90012E     MOV [W14+4], W2
0023AA  9001BE     MOV [W14+6], W3
0023AC  510000     SUB W2, W0, W0
0023AE  598081     SUBB W3, W1, W1
0023B0  980720     MOV W0, [W14+4]
0023B2  980731     MOV W1, [W14+6]
48:                        ret=ret/(len-2);
0023B4  90486E     MOV.B [W14+14], W0
0023B6  FB8000     ZE W0, W0
0023B8  E98000     DEC2 W0, W0
0023BA  DE80CF     ASR W0, #15, W1
0023BC  BE0100     MOV.D W0, W2
0023BE  90002E     MOV [W14+4], W0
0023C0  9000BE     MOV [W14+6], W1
0023C2  07EFD1     RCALL ___divsi3
0023C4  980720     MOV W0, [W14+4]
0023C6  980731     MOV W1, [W14+6]
49:                        buf[maxIndex]=(int16_t)ret;
0023C8  FB801E     ZE [W14], W0
0023CA  400000     ADD W0, W0, W0
0023CC  9000EE     MOV [W14+12], W1
0023CE  408000     ADD W1, W0, W0
0023D0  9000AE     MOV [W14+4], W1
0023D2  780801     MOV W1, [W0]
50:                        buf[minIndex]=(int16_t)ret;
0023D4  90401E     MOV.B [W14+1], W0
0023D6  FB8000     ZE W0, W0
0023D8  400000     ADD W0, W0, W0
0023DA  9000EE     MOV [W14+12], W1
0023DC  408000     ADD W1, W0, W0
0023DE  9000AE     MOV [W14+4], W1
0023E0  780801     MOV W1, [W0]
51:                    }
52:                    return (int16_t)ret;    
0023EE  90002E     MOV [W14+4], W0
53:                }
0023F0  FA8000     ULNK
0023F2  060000     RETURN
54:                int16_t samlpe_read_adc(ads1148Obj_t* obj,int16_t* buf,uint8_t len)
55:                {
0023F4  FA000E     LNK #0xE
0023F6  980740     MOV W0, [W14+8]
0023F8  980751     MOV W1, [W14+10]
0023FA  984F42     MOV.B W2, [W14+12]
56:                	
57:                	uint8_t i=0;
0023FC  EB4000     CLR.B W0
0023FE  784F00     MOV.B W0, [W14]
58:                	int16_t t16;
59:                	int32_t	t32=0;
002400  B80060     MUL.UU W0, #0, W0
002402  980710     MOV W0, [W14+2]
002404  980721     MOV W1, [W14+4]
60:                    ads1148_start_convert(obj);
002406  90004E     MOV [W14+8], W0
002408  07FCE6     RCALL ads1148_start_convert
61:                	for(i=0;i<2;i++){
00240A  EB4000     CLR.B W0
00240C  784F00     MOV.B W0, [W14]
00240E  370004     BRA 0x2418
002416  E84F1E     INC.B [W14], [W14]
002418  78401E     MOV.B [W14], W0
00241A  504FE1     SUB.B W0, #0x1, [W15]
00241C  36FFF9     BRA LEU, 0x2410
62:                		ads1148_waite_convert(obj);
002410  90004E     MOV [W14+8], W0
002412  07FCEF     RCALL ads1148_waite_convert
63:                		__nop();
002414  000000     NOP
64:                	}
65:                	for(i=0;i<len;i++){
00241E  EB4000     CLR.B W0
002420  784F00     MOV.B W0, [W14]
002422  370014     BRA 0x244C
00244A  E84F1E     INC.B [W14], [W14]
00244C  90484E     MOV.B [W14+12], W0
00244E  78409E     MOV.B [W14], W1
002450  50CF80     SUB.B W1, W0, [W15]
002452  39FFE8     BRA NC, 0x2424
66:                		ads1148_waite_convert(obj);
002424  90004E     MOV [W14+8], W0
002426  07FCE5     RCALL ads1148_waite_convert
67:                		t16=ads1148_read_data(obj);
002428  90004E     MOV [W14+8], W0
00242A  07FA35     RCALL ads1148_read_data
00242C  980730     MOV W0, [W14+6]
68:                		samlpeBuf[i]=t16;
00242E  FB801E     ZE [W14], W0
002430  400080     ADD W0, W0, W1
002432  208E00     MOV #0x8E0, W0
002434  408000     ADD W1, W0, W0
002436  9000BE     MOV [W14+6], W1
002438  780801     MOV W1, [W0]
69:                		t32+=(int32_t)t16;
00243A  90003E     MOV [W14+6], W0
00243C  DE80CF     ASR W0, #15, W1
00243E  90011E     MOV [W14+2], W2
002440  9001AE     MOV [W14+4], W3
002442  400002     ADD W0, W2, W0
002444  488083     ADDC W1, W3, W1
002446  980710     MOV W0, [W14+2]
002448  980721     MOV W1, [W14+4]
70:                	}
71:                	t32/=i;
002454  FB801E     ZE [W14], W0
002456  EB0080     CLR W1
002458  BE0100     MOV.D W0, W2
00245A  90001E     MOV [W14+2], W0
00245C  9000AE     MOV [W14+4], W1
00245E  07EF83     RCALL ___divsi3
002460  980710     MOV W0, [W14+2]
002462  980721     MOV W1, [W14+4]
72:                	if(buf){
002464  90005E     MOV [W14+10], W0
002466  E00000     CP0 W0
002468  320007     BRA Z, 0x2478
73:                		m_mem_cpy_len((uint8_t*)buf,(uint8_t*)samlpeBuf,len*sizeof(int16_t));
00246A  90484E     MOV.B [W14+12], W0
00246C  FB8000     ZE W0, W0
00246E  400000     ADD W0, W0, W0
002470  780100     MOV W0, W2
002472  208E01     MOV #0x8E0, W1
002474  90005E     MOV [W14+10], W0
002476  07FD10     RCALL m_mem_cpy_len
74:                	}
75:                	return (int16_t)t32;
002478  90001E     MOV [W14+2], W0
76:                }
00247A  FA8000     ULNK
00247C  060000     RETURN
77:                //ads1148Chip0
78:                void samlpe_chip0_ch_diff_pr_bridge(void)
79:                {
00247E  FA0000     LNK #0x0
80:                	
81:                	ads1148_set_idac12_pins(&ads1148Chip0,IDAC_OUT_IEXC1,IDAC_OUT_NC);
002480  B3C0F2     MOV.B #0xF, W2
002482  B3C081     MOV.B #0x8, W1
002484  2087C0     MOV #0x87C, W0
002486  07FBE3     RCALL ads1148_set_idac12_pins
82:                	ads1148_set_imag_idac(&ads1148Chip0,ADS1148_IMAG_250uA);
002488  B3C031     MOV.B #0x3, W1
00248A  2087C0     MOV #0x87C, W0
00248C  07FB83     RCALL ads1148_set_imag_idac
83:                    
84:                    ads1148_set_data_rate(&ads1148Chip0,ADS1148_SYS0_DR_2000SPS);
00248E  B3C091     MOV.B #0x9, W1
002490  2087C0     MOV #0x87C, W0
002492  07FB50     RCALL ads1148_set_data_rate
85:                    
86:                    ads1148_set_muxcal(&ads1148Chip0,ADS1148_MUXCAL_NORMAL);
002494  EB4080     CLR.B W1
002496  2087C0     MOV #0x87C, W0
002498  07FB31     RCALL ads1148_set_muxcal
87:                    ads1148_set_channle_normal(&ads1148Chip0,AIN1P,AIN0N);
00249A  EB4100     CLR.B W2
00249C  B3C011     MOV.B #0x1, W1
00249E  2087C0     MOV #0x87C, W0
0024A0  07FAB7     RCALL ads1148_set_channle_normal
88:                    ads1148_set_ani_pga(&ads1148Chip0,ADS1148_PGA_1);
0024A2  EB4080     CLR.B W1
0024A4  2087C0     MOV #0x87C, W0
0024A6  07FB5D     RCALL ads1148_set_ani_pga
89:                    ads1148_get_all_register(&ads1148Chip0);
0024A8  2087C0     MOV #0x87C, W0
0024AA  07FBF1     RCALL ads1148_get_all_register
90:                	rtAdcValueDPrBridge=samlpe_read_adc(&ads1148Chip0,NULL,8);
0024AC  B3C082     MOV.B #0x8, W2
0024AE  EB0080     CLR W1
0024B0  2087C0     MOV #0x87C, W0
0024B2  07FFA0     RCALL samlpe_read_adc
0024B4  884290     MOV W0, rtAdcValueDPrBridge
91:                	__nop();
0024B6  000000     NOP
92:                	__nop();
0024B8  000000     NOP
93:                }
0024BA  FA8000     ULNK
0024BC  060000     RETURN
94:                
95:                void samlpe_chip0_ch_diff_pr_signal(void)
96:                {
0024BE  FA0000     LNK #0x0
97:                	ads1148_set_channle_normal(&ads1148Chip0,AIN5P,AIN4N);
0024C0  B3C042     MOV.B #0x4, W2
0024C2  B3C051     MOV.B #0x5, W1
0024C4  2087C0     MOV #0x87C, W0
0024C6  07FAA4     RCALL ads1148_set_channle_normal
98:                	ads1148_set_imag_idac(&ads1148Chip0,ADS1148_IMAG_500uA);
0024C8  B3C041     MOV.B #0x4, W1
0024CA  2087C0     MOV #0x87C, W0
0024CC  07FB63     RCALL ads1148_set_imag_idac
99:                	ads1148_set_ani_pga(&ads1148Chip0,ADS1148_PGA_64);
0024CE  B3C061     MOV.B #0x6, W1
0024D0  2087C0     MOV #0x87C, W0
0024D2  07FB47     RCALL ads1148_set_ani_pga
100:                   ads1148_get_all_register(&ads1148Chip0);
0024D4  2087C0     MOV #0x87C, W0
0024D6  07FBDB     RCALL ads1148_get_all_register
101:               	samlpe_read_adc(&ads1148Chip0,samlpeBuf,24);
0024D8  B3C182     MOV.B #0x18, W2
0024DA  208E01     MOV #0x8E0, W1
0024DC  2087C0     MOV #0x87C, W0
0024DE  07FF8A     RCALL samlpe_read_adc
102:                   rtAdcValueDPrSignal=samlpe_get_adc_average_value(samlpeBuf,24);
0024E0  B3C181     MOV.B #0x18, W1
0024E2  208E00     MOV #0x8E0, W0
0024E4  07FF06     RCALL samlpe_get_adc_average_value
0024E6  8842A0     MOV W0, rtAdcValueDPrSignal
103:               	__nop();
0024E8  000000     NOP
104:               	__nop();
0024EA  000000     NOP
105:               }
0024EC  FA8000     ULNK
0024EE  060000     RETURN
106:               
107:               void samlpe_chip0_ch_diff_pr_ref0(void)
108:               {
0024F0  FA0000     LNK #0x0
109:                   ads1148_set_channle_normal(&ads1148Chip0,AIN0P,AIN6N);
0024F2  B3C062     MOV.B #0x6, W2
0024F4  EB4080     CLR.B W1
0024F6  2087C0     MOV #0x87C, W0
0024F8  07FA8B     RCALL ads1148_set_channle_normal
110:               	ads1148_set_bcs(&ads1148Chip0,ADS1148_BCS_2uA0);
0024FA  B3C021     MOV.B #0x2, W1
0024FC  2087C0     MOV #0x87C, W0
0024FE  07FAAD     RCALL ads1148_set_bcs
111:               	ads1148_set_ani_pga(&ads1148Chip0,ADS1148_PGA_1);
002500  EB4080     CLR.B W1
002502  2087C0     MOV #0x87C, W0
002504  07FB2E     RCALL ads1148_set_ani_pga
112:                   ads1148_get_all_register(&ads1148Chip0);
002506  2087C0     MOV #0x87C, W0
002508  07FBC2     RCALL ads1148_get_all_register
113:                   rtAdcValueChip0Ref0=samlpe_read_adc(&ads1148Chip0,samlpeBuf,8);
00250A  B3C082     MOV.B #0x8, W2
00250C  208E01     MOV #0x8E0, W1
00250E  2087C0     MOV #0x87C, W0
002510  07FF71     RCALL samlpe_read_adc
002512  8842E0     MOV W0, rtAdcValueChip0Ref0
114:               	__nop();
002514  000000     NOP
115:               	__nop();
002516  000000     NOP
116:                   __nop();
002518  000000     NOP
117:                   ads1148_set_bcs(&ads1148Chip0,ADS1148_BCS_OFF);
00251A  EB4080     CLR.B W1
00251C  2087C0     MOV #0x87C, W0
00251E  07FA9D     RCALL ads1148_set_bcs
118:               }
002520  FA8000     ULNK
002522  060000     RETURN
119:               
120:               /*
121:               void samlpe_chip0_ch_diff_pr_ref0(void)
122:               {
123:                   ads1148_set_muxcal(&ads1148Chip0,ADS1148_MUXCAL_REF0_MONITOR);
124:               	ads1148_set_bcs(&ads1148Chip0,ADS1148_BCS_2uA0);
125:               	ads1148_set_ani_pga(&ads1148Chip0,ADS1148_PGA_1);
126:                   //ads1148_get_all_register(&ads1148Chip0);
127:                   rtAdcValueChip0Ref0=samlpe_read_adc(&ads1148Chip0,samlpeBuf,8);
128:               	__nop();
129:               	__nop();
130:                   __nop();
131:               	ads1148_set_muxcal(&ads1148Chip0,ADS1148_MUXCAL_NORMAL);
132:                   ads1148_set_bcs(&ads1148Chip0,ADS1148_BCS_OFF);
133:               }
134:               */
135:               
136:               void samlpe_chip0_ch_pr_bridge(void)
137:               {
002524  FA0000     LNK #0x0
138:               	ads1148_set_idac12_pins(&ads1148Chip0,IDAC_OUT_NC,IDAC_OUT_IEXC2);
002526  B3C092     MOV.B #0x9, W2
002528  B3C0F1     MOV.B #0xF, W1
00252A  2087C0     MOV #0x87C, W0
00252C  07FB90     RCALL ads1148_set_idac12_pins
139:               	ads1148_set_imag_idac(&ads1148Chip0,ADS1148_IMAG_250uA);
00252E  B3C031     MOV.B #0x3, W1
002530  2087C0     MOV #0x87C, W0
002532  07FB30     RCALL ads1148_set_imag_idac
140:                   ads1148_set_data_rate(&ads1148Chip0,ADS1148_SYS0_DR_2000SPS);
002534  B3C091     MOV.B #0x9, W1
002536  2087C0     MOV #0x87C, W0
002538  07FAFD     RCALL ads1148_set_data_rate
141:                   ads1148_set_muxcal(&ads1148Chip0,ADS1148_MUXCAL_NORMAL);
00253A  EB4080     CLR.B W1
00253C  2087C0     MOV #0x87C, W0
00253E  07FADE     RCALL ads1148_set_muxcal
142:                   ads1148_set_channle_normal(&ads1148Chip0,AIN7P,AIN6N);
002540  B3C062     MOV.B #0x6, W2
002542  B3C071     MOV.B #0x7, W1
002544  2087C0     MOV #0x87C, W0
002546  07FA64     RCALL ads1148_set_channle_normal
143:                   ads1148_set_ani_pga(&ads1148Chip0,ADS1148_PGA_1);
002548  EB4080     CLR.B W1
00254A  2087C0     MOV #0x87C, W0
00254C  07FB0A     RCALL ads1148_set_ani_pga
144:                   ads1148_get_all_register(&ads1148Chip0);
00254E  2087C0     MOV #0x87C, W0
002550  07FB9E     RCALL ads1148_get_all_register
145:               	rtAdcValuePrBridge=samlpe_read_adc(&ads1148Chip0,NULL,8);
002552  B3C082     MOV.B #0x8, W2
002554  EB0080     CLR W1
002556  2087C0     MOV #0x87C, W0
002558  07FF4D     RCALL samlpe_read_adc
00255A  8842B0     MOV W0, rtAdcValuePrBridge
146:               	__nop();
00255C  000000     NOP
147:               	__nop();
00255E  000000     NOP
148:               }
002560  FA8000     ULNK
002562  060000     RETURN
149:               
150:               void samlpe_chip0_ch_pr_signal(void)
151:               {
002564  FA0000     LNK #0x0
152:               	ads1148_set_channle_normal(&ads1148Chip0,AIN3P,AIN2N);
002566  B3C022     MOV.B #0x2, W2
002568  B3C031     MOV.B #0x3, W1
00256A  2087C0     MOV #0x87C, W0
00256C  07FA51     RCALL ads1148_set_channle_normal
153:               	ads1148_set_imag_idac(&ads1148Chip0,ADS1148_IMAG_500uA);
00256E  B3C041     MOV.B #0x4, W1
002570  2087C0     MOV #0x87C, W0
002572  07FB10     RCALL ads1148_set_imag_idac
154:               	ads1148_set_ani_pga(&ads1148Chip0,ADS1148_PGA_64);
002574  B3C061     MOV.B #0x6, W1
002576  2087C0     MOV #0x87C, W0
002578  07FAF4     RCALL ads1148_set_ani_pga
155:                   ads1148_get_all_register(&ads1148Chip0);
00257A  2087C0     MOV #0x87C, W0
00257C  07FB88     RCALL ads1148_get_all_register
156:               	samlpe_read_adc(&ads1148Chip0,samlpeBuf,24);
00257E  B3C182     MOV.B #0x18, W2
002580  208E01     MOV #0x8E0, W1
002582  2087C0     MOV #0x87C, W0
002584  07FF37     RCALL samlpe_read_adc
157:                   rtAdcValuePrSignal=samlpe_get_adc_average_value(samlpeBuf,24);
002586  B3C181     MOV.B #0x18, W1
002588  208E00     MOV #0x8E0, W0
00258A  07FEB3     RCALL samlpe_get_adc_average_value
00258C  8842C0     MOV W0, rtAdcValuePrSignal
158:               	__nop();
00258E  000000     NOP
159:               	__nop();
002590  000000     NOP
160:               }
002592  FA8000     ULNK
002594  060000     RETURN
161:               
162:               void samlpe_chip0_ch_pr_ref1(void)
163:               {
002596  FA0000     LNK #0x0
164:                   ads1148_set_muxcal(&ads1148Chip0,ADS1148_MUXCAL_REF1_MONITOR);
002598  B3C041     MOV.B #0x4, W1
00259A  2087C0     MOV #0x87C, W0
00259C  07FAAF     RCALL ads1148_set_muxcal
165:               	//ads1148_set_bcs(&ads1148Chip0,ADS1148_BCS_2uA0);
166:               	ads1148_set_ani_pga(&ads1148Chip0,ADS1148_PGA_1);
00259E  EB4080     CLR.B W1
0025A0  2087C0     MOV #0x87C, W0
0025A2  07FADF     RCALL ads1148_set_ani_pga
167:                   //ads1148_get_all_register(&ads1148Chip0);
168:                   rtAdcValueChip0Ref1=samlpe_read_adc(&ads1148Chip0,samlpeBuf,8);
0025A4  B3C082     MOV.B #0x8, W2
0025A6  208E01     MOV #0x8E0, W1
0025A8  2087C0     MOV #0x87C, W0
0025AA  07FF24     RCALL samlpe_read_adc
0025AC  8842F0     MOV W0, rtAdcValueChip0Ref1
169:               	__nop();
0025AE  000000     NOP
170:               	__nop();
0025B0  000000     NOP
171:                   __nop();
0025B2  000000     NOP
172:               	ads1148_set_muxcal(&ads1148Chip0,ADS1148_MUXCAL_NORMAL);
0025B4  EB4080     CLR.B W1
0025B6  2087C0     MOV #0x87C, W0
0025B8  07FAA1     RCALL ads1148_set_muxcal
173:                   //ads1148_set_bcs(&ads1148Chip0,ADS1148_BCS_OFF);
174:               }
0025BA  FA8000     ULNK
0025BC  060000     RETURN
175:               
176:               void samlpe_chip0_ch_temperature_in(void)
177:               {
0025BE  FA0000     LNK #0x0
178:                   ads1148_set_channle_normal(&ads1148Chip0,AIN6P,AIN0N);
0025C0  EB4100     CLR.B W2
0025C2  B3C061     MOV.B #0x6, W1
0025C4  2087C0     MOV #0x87C, W0
0025C6  07FA24     RCALL ads1148_set_channle_normal
179:               	ads1148_set_bcs(&ads1148Chip0,ADS1148_BCS_2uA0);
0025C8  B3C021     MOV.B #0x2, W1
0025CA  2087C0     MOV #0x87C, W0
0025CC  07FA46     RCALL ads1148_set_bcs
180:               	ads1148_set_ani_pga(&ads1148Chip0,ADS1148_PGA_1);
0025CE  EB4080     CLR.B W1
0025D0  2087C0     MOV #0x87C, W0
0025D2  07FAC7     RCALL ads1148_set_ani_pga
181:                   ads1148_get_all_register(&ads1148Chip0);
0025D4  2087C0     MOV #0x87C, W0
0025D6  07FB5B     RCALL ads1148_get_all_register
182:                   rtAdcValueTemperatureIn=samlpe_read_adc(&ads1148Chip0,samlpeBuf,8);
0025D8  B3C082     MOV.B #0x8, W2
0025DA  208E01     MOV #0x8E0, W1
0025DC  2087C0     MOV #0x87C, W0
0025DE  07FF0A     RCALL samlpe_read_adc
0025E0  8842D0     MOV W0, rtAdcValueTemperatureIn
183:               	__nop();
0025E2  000000     NOP
184:               	__nop();
0025E4  000000     NOP
185:                   __nop();
0025E6  000000     NOP
186:                   ads1148_set_bcs(&ads1148Chip0,ADS1148_BCS_OFF);	
0025E8  EB4080     CLR.B W1
0025EA  2087C0     MOV #0x87C, W0
0025EC  07FA36     RCALL ads1148_set_bcs
187:               }
0025EE  FA8000     ULNK
0025F0  060000     RETURN
188:               
189:               
190:               void samlpe_chip1_ch_expr0_bridge(void)
191:               {
0025F2  FA0000     LNK #0x0
192:               	
193:               }
0025F4  FA8000     ULNK
0025F6  060000     RETURN
194:               
195:               void samlpe_chip1_ch_expr0_signal(void)
196:               {
0025F8  FA0000     LNK #0x0
197:               	
198:               }
0025FA  FA8000     ULNK
0025FC  060000     RETURN
199:               
200:               void samlpe_chip1_ch_ex0_temperature(void)
201:               {
0025FE  FA0000     LNK #0x0
202:               	
203:               }
002600  FA8000     ULNK
002602  060000     RETURN
204:               
205:               void samlpe_chip1_ch_expr0_ref0(void)
206:               {
002604  FA0000     LNK #0x0
207:               	
208:               }
002606  FA8000     ULNK
002608  060000     RETURN
209:               
210:               void samlpe_chip1_ch_expr1_bridge(void)
211:               {
00260A  FA0000     LNK #0x0
212:               	
213:               }
00260C  FA8000     ULNK
00260E  060000     RETURN
214:               
215:               void samlpe_chip1_ch_expr1_signal(void)
216:               {
002610  FA0000     LNK #0x0
217:               	
218:               }
002612  FA8000     ULNK
002614  060000     RETURN
219:               
220:               void samlpe_chip1_ch_ex1_temperature(void)
221:               {
002616  FA0000     LNK #0x0
222:               	
223:               }
002618  FA8000     ULNK
00261A  060000     RETURN
224:               
225:               void samlpe_chip1_ch_expr1_ref1(void)
226:               {
00261C  FA0000     LNK #0x0
227:               	
228:               }
00261E  FA8000     ULNK
002620  060000     RETURN
229:               
230:               void sample_in_soc_solar(void)
231:               {
002622  FA0000     LNK #0x0
232:               
233:               }
002624  FA8000     ULNK
002626  060000     RETURN
234:               
235:               void samlpe_in_soc_battery(void)
236:               {
002628  FA0000     LNK #0x0
237:               	
238:               }
00262A  FA8000     ULNK
00262C  060000     RETURN
239:               
240:               void samlpe_in_soc_ref(void)
241:               {
00262E  FA0000     LNK #0x0
242:               	
243:               }
002630  FA8000     ULNK
002632  060000     RETURN
244:               
245:               void sample_post_calc(void)
246:               {
002634  FA0000     LNK #0x0
247:               	
248:               }
002636  FA8000     ULNK
002638  060000     RETURN
249:               
250:               void sample_process(void)
251:               {
00263A  FA0000     LNK #0x0
252:               	switch(sampleIndex){
00263C  BFC850     MOV.B sampleIndex, WREG
00263E  FB8000     ZE W0, W0
002640  DE80CF     ASR W0, #15, W1
002642  200162     MOV #0x16, W2
002644  200003     MOV #0x0, W3
002646  500F82     SUB W0, W2, [W15]
002648  588F83     SUBB W1, W3, [W15]
00264A  3E003C     BRA GTU, 0x26C4
00264C  016000     BRA W0
00264E  370016     BRA 0x267C
002650  370017     BRA 0x2680
002652  370018     BRA 0x2684
002654  370039     BRA 0x26C8
002656  370018     BRA 0x2688
002658  370019     BRA 0x268C
00265A  37001A     BRA 0x2690
00265C  37001B     BRA 0x2694
00265E  370034     BRA 0x26C8
002660  37001B     BRA 0x2698
002662  37001C     BRA 0x269C
002664  37001D     BRA 0x26A0
002666  37001E     BRA 0x26A4
002668  37002F     BRA 0x26C8
00266A  37001E     BRA 0x26A8
00266C  37001F     BRA 0x26AC
00266E  370020     BRA 0x26B0
002670  370021     BRA 0x26B4
002672  37002A     BRA 0x26C8
002674  370021     BRA 0x26B8
002676  370022     BRA 0x26BC
002678  370023     BRA 0x26C0
00267A  370026     BRA 0x26C8
253:               		case 0x00:samlpe_chip0_ch_diff_pr_bridge();		break;
00267C  07FF00     RCALL samlpe_chip0_ch_diff_pr_bridge
00267E  370025     BRA 0x26CA
254:               		case 0x01:samlpe_chip0_ch_diff_pr_signal();		break;
002680  07FF1E     RCALL samlpe_chip0_ch_diff_pr_signal
002682  370023     BRA 0x26CA
255:               		case 0x02:samlpe_chip0_ch_diff_pr_ref0();		break;
002684  07FF35     RCALL samlpe_chip0_ch_diff_pr_ref0
002686  370021     BRA 0x26CA
256:               		case 0x03:break;
257:               		case 0x04:samlpe_chip0_ch_pr_bridge();			break;
002688  07FF4D     RCALL samlpe_chip0_ch_pr_bridge
00268A  37001F     BRA 0x26CA
258:               		case 0x05:samlpe_chip0_ch_pr_signal();			break;
00268C  07FF6B     RCALL samlpe_chip0_ch_pr_signal
00268E  37001D     BRA 0x26CA
259:               		case 0x06:samlpe_chip0_ch_pr_ref1();			break;
002690  07FF82     RCALL samlpe_chip0_ch_pr_ref1
002692  37001B     BRA 0x26CA
260:               		case 0x07:samlpe_chip0_ch_temperature_in();	break;
002694  07FF94     RCALL samlpe_chip0_ch_temperature_in
002696  370019     BRA 0x26CA
261:               		case 0x08:break;
262:               		case 0x09:samlpe_chip1_ch_expr0_bridge();		break;
002698  07FFAC     RCALL samlpe_chip1_ch_expr0_bridge
00269A  370017     BRA 0x26CA
263:               		case 0x0a:samlpe_chip1_ch_expr0_signal();		break;
00269C  07FFAD     RCALL samlpe_chip1_ch_expr0_signal
00269E  370015     BRA 0x26CA
264:               		case 0x0b:samlpe_chip1_ch_ex0_temperature();	break;
0026A0  07FFAE     RCALL samlpe_chip1_ch_ex0_temperature
0026A2  370013     BRA 0x26CA
265:               		case 0x0c:samlpe_chip1_ch_expr0_ref0();			break;	
0026A4  07FFAF     RCALL samlpe_chip1_ch_expr0_ref0
0026A6  370011     BRA 0x26CA
266:               		case 0x0d:break;
267:               		case 0x0e:samlpe_chip1_ch_expr1_bridge();		break;
0026A8  07FFB0     RCALL samlpe_chip1_ch_expr1_bridge
0026AA  37000F     BRA 0x26CA
268:               		case 0x0f:samlpe_chip1_ch_expr1_signal();		break;
0026AC  07FFB1     RCALL samlpe_chip1_ch_expr1_signal
0026AE  37000D     BRA 0x26CA
269:               		case 0x10:samlpe_chip1_ch_ex1_temperature();	break;
0026B0  07FFB2     RCALL samlpe_chip1_ch_ex1_temperature
0026B2  37000B     BRA 0x26CA
270:               		case 0x11:samlpe_chip1_ch_expr1_ref1();			break;
0026B4  07FFB3     RCALL samlpe_chip1_ch_expr1_ref1
0026B6  370009     BRA 0x26CA
271:               		case 0x12:break;
272:               		case 0x13:samlpe_in_soc_battery();				break;
0026B8  07FFB7     RCALL samlpe_in_soc_battery
0026BA  370007     BRA 0x26CA
273:               		case 0x14:sample_in_soc_solar();				break;
0026BC  07FFB2     RCALL sample_in_soc_solar
0026BE  370005     BRA 0x26CA
274:               		case 0x15:samlpe_in_soc_ref();					break;
0026C0  07FFB6     RCALL samlpe_in_soc_ref
0026C2  370003     BRA 0x26CA
275:               		case 0x16:break;
0026C8  000000     NOP
276:               		default:	break;
0026C4  000000     NOP
0026C6  370001     BRA 0x26CA
277:               	}
278:               	sampleIndex++;
0026CA  BFC850     MOV.B sampleIndex, WREG
0026CC  E84000     INC.B W0, W0
0026CE  B7E850     MOV.B WREG, sampleIndex
279:                   if(sampleIndex>0x16)sampleIndex=0;
0026D0  BFC850     MOV.B sampleIndex, WREG
0026D2  504FF6     SUB.B W0, #0x16, [W15]
0026D4  360001     BRA LEU, 0x26D8
0026D6  EF6850     CLR.B sampleIndex
280:               }
0026D8  FA8000     ULNK
0026DA  060000     RETURN
281:               /*
282:               void samlpe_chip0_channle_gain_calib(void)
283:               {
284:               	uint32_t tm;
285:                   volatile int32_t t32=0;
286:                   volatile int16_t t16;
287:               	uint8_t i;
288:               	tm=xTaskGetTickCount();
289:               	ads1148_start_convert(&ads1148Chip1);
290:               	delay_us(5);
291:               	for(i=0;i<8;i++){
292:               		ads1148_waite_convert(&ads1148Chip1);
293:                       //delay_us(5);
294:                       vPortEnterCritical();
295:               		t16=ads1148_read_data(&ads1148Chip1);
296:                       vPortExitCritical();
297:                       t32=t32+(int32_t)t16;
298:                       __nop();
299:                       __nop();        
300:               	}
301:               	t32/=i;
302:               	ads1148_stop_convert(&ads1148Chip1);
303:               	tm=xTaskGetTickCount()-tm;
304:               	__nop();
305:               	__nop();
306:               }
307:               void sample_fast_mode(void)
308:               {
309:               	uint8_t t8;
310:               	t8=sampleIndex;
311:               	switch(t8){
312:               		case 0x00:samlpe_chip0_channle_diff_press();break;
313:               		case 0x01:samlpe_chip0_channle_press();break;
314:               		case 0x03:samlpe_chip0_channle_temperature();break;
315:               		default:break;
316:               	}
317:               }
318:               
319:               void thread_sample( void * pvParameters )
320:               {
321:               	ads1148_init_all_obj();
322:               	ads1148_init_chip_regs(&ads1148Chip0);
323:               	ads1148_init_chip_regs(&ads1148Chip1);
324:               	while(1){
325:               		osDelay(10);
326:               		samlpe_chip0_channle_gain_calib();
327:               		__nop();
328:               		__nop();
329:               	}
330:               }
331:               void thread_sample_void(void)
332:               {
333:                   BaseType_t xReturned;
334:                   TaskHandle_t xHandle = NULL;
335:               
336:               
337:                   xReturned = xTaskCreate(
338:               		thread_sample, 
339:               		"samlpe", 
340:               		configMINIMAL_STACK_SIZE, 
341:               		NULL, 
342:               		1, 
343:               		&xHandle );	
344:               }
345:               */
346:               
---  F:/2017/cs66-b/cs66b.X/src/app/main.c  -------------------------------------------------------------
1:                 #include "../includes/includes.h"
2:                 
3:                 
4:                 void m_system_init(void)
5:                 {
0032CC  FA0000     LNK #0x0
6:                     PIN_MANAGER_Initialize();
0032CE  07FF97     RCALL PIN_MANAGER_Initialize
7:                     INTERRUPT_Initialize();
0032D0  070082     RCALL INTERRUPT_Initialize
8:                     OSCILLATOR_Initialize();
0032D2  070073     RCALL OSCILLATOR_Initialize
9:                     //TMR2_Initialize();
10:                    RTCC_Initialize();
0032D4  07FD15     RCALL RTCC_Initialize
11:                    //TMR1_Initialize();    
12:                }
0032D6  FA8000     ULNK
0032D8  060000     RETURN
13:                /*
14:                void thread_main( void * pvParameters )
15:                {
16:                    //configASSERT( ( ( uint32_t ) pvParameters ) == 1 );
17:                    kz_vadd_on();
18:                	thread_sample_void();
19:                    for( ;; )
20:                    {
21:                
22:                        //task_delay_ms(500);
23:                        osDelay(500);
24:                        back_night_off();
25:                        //task_delay_ms(500);
26:                        osDelay(500);
27:                        back_night_on();
28:                    }
29:                }
30:                void thread_main_create(void)
31:                {
32:                    BaseType_t xReturned;
33:                    TaskHandle_t xHandle = NULL;
34:                
35:                
36:                    xReturned = xTaskCreate(
37:                		thread_main, 
38:                		"NAME", 
39:                		configMINIMAL_STACK_SIZE, 
40:                		NULL, 
41:                		tskIDLE_PRIORITY, 
42:                		&xHandle );
43:                }
44:                */
45:                void event_proess(void)
46:                {
0032DA  FA0000     LNK #0x0
47:                	if(event | flg_TICKER_10MS_PER){
0032DC  8043D0     MOV event, W0
48:                		event &= ~flg_TICKER_10MS_PER;
0032DE  8043D0     MOV event, W0
0032E0  A11000     BCLR W0, #1
0032E2  8843D0     MOV W0, event
49:                		sample_process();
0032E4  07F9AA     RCALL sample_process
50:                	}
51:                }
0032E6  FA8000     ULNK
0032E8  060000     RETURN
52:                
53:                int main(void)
54:                {
0032EA  FA0006     LNK #0x6
55:                    uint8_t str[4]={0x11,0x22,0x33,0x44};
0032EC  4700E2     ADD W14, #0x2, W1
0032EE  284E52     MOV #0x84E5, W2
0032F0  090003     REPEAT #0x3
0032F2  7858B2     MOV.B [W2++], [W1++]
56:                    uint8_t i=0,j=0;
0032F4  EB4000     CLR.B W0
0032F6  784F00     MOV.B W0, [W14]
0032F8  EB4000     CLR.B W0
0032FA  984710     MOV.B W0, [W14+1]
57:                    // initialize the device
58:                    SYSTEM_Initialize();
0032FC  070055     RCALL SYSTEM_Initialize
59:                    //m_system_init();
60:                    lcd_init();
0032FE  07F2AC     RCALL lcd_init
61:                    lcd_disp_clear_buffer();
003300  EB0000     CLR W0
003302  07F249     RCALL lcd_disp_all
62:                    lcd_show_string((uint8_t*)"77777777");
003304  284D80     MOV #0x84D8, W0
003306  07F1ED     RCALL lcd_show_string
63:                    lcd_show_string_sm((uint8_t*)"123");
003308  284E10     MOV #0x84E1, W0
00330A  07F177     RCALL lcd_show_string_sm
64:                    lcd_show_string_ex((uint8_t*)"123");
00330C  284E10     MOV #0x84E1, W0
00330E  07F18C     RCALL lcd_show_string_ex
65:                    lcd_disp_refresh();
003310  07F1FF     RCALL lcd_disp_refresh
66:                    // thread_main_create();
67:                     // vTaskStartScheduler();
68:                    //m_flash_erase(user_FLASH_ADDR_START,4);
69:                    //m_flash_write(user_FLASH_ADDR_START,str,4);
70:                    //m_flash_read(user_FLASH_ADDR_START,str,4);
71:                	__nop();
003312  000000     NOP
72:                    __nop();
003314  000000     NOP
73:                    ads1148_init_all_obj();
003316  07F553     RCALL ads1148_init_all_obj
74:                	ads1148_init_device();
003318  07F557     RCALL ads1148_init_device
75:                
76:                    while (1){
77:                		if(event | flg_TICKER_10MS_PER){
00331A  8043D0     MOV event, W0
78:                			event &= ~flg_TICKER_10MS_PER;
00331C  8043D0     MOV event, W0
00331E  A11000     BCLR W0, #1
003320  8843D0     MOV W0, event
79:                			sample_process();
003322  07F98B     RCALL sample_process
80:                		}
81:                        
82:                    }
003324  37FFFA     BRA 0x331A
83:                    return -1;
84:                }
85:                /*
86:                void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName )
87:                {
88:                    
89:                }   
90:                void vApplicationIdleHook( void )
91:                {
92:                    
93:                }
94:                */
95:                /**
96:                 End of File
97:                */
---  F:/2017/cs66-b/cs66b.X/mcc_generated_files/tmr2.c  -------------------------------------------------
1:                 
2:                 /**
3:                   TMR2 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr2.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR2 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR2. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.45
18:                        Device            :  PIC24FJ128GA310
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 1.32
21:                        MPLAB 	          :  MPLAB X 3.61
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include <xc.h>
51:                #include "tmr2.h"
52:                
53:                /**
54:                  Section: Data Type Definitions
55:                */
56:                
57:                /** TMR Driver Hardware Instance Object
58:                
59:                  @Summary
60:                    Defines the object required for the maintainence of the hardware instance.
61:                
62:                  @Description
63:                    This defines the object required for the maintainence of the hardware
64:                    instance. This object exists once per hardware instance of the peripheral.
65:                
66:                  Remarks:
67:                    None.
68:                */
69:                
70:                typedef struct _TMR_OBJ_STRUCT
71:                {
72:                    /* Timer Elapsed */
73:                    bool                                                    timerElapsed;
74:                    /*Software Counter value*/
75:                    uint8_t                                                 count;
76:                
77:                } TMR_OBJ;
78:                
79:                static TMR_OBJ tmr2_obj;
80:                
81:                /**
82:                  Section: Driver Interface
83:                */
84:                
85:                
86:                void TMR2_Initialize (void)
87:                {
002FCC  FA0000     LNK #0x0
88:                    //TMR2 0; 
89:                    TMR2 = 0x0000;
002FCE  EF2106     CLR TMR2
90:                    //Period = 0.01 s; Frequency = 5529600 Hz; PR2 864; 
91:                    PR2 = 0x0360*2;
002FD0  206C00     MOV #0x6C0, W0
002FD2  880860     MOV W0, PR2
92:                    //TCKPS 1:64; T32 16 Bit; TON enabled; TSIDL disabled; TCS FOSC/2; TGATE disabled; 
93:                    T2CON = 0x8020;
002FD4  280200     MOV #0x8020, W0
002FD6  880880     MOV W0, T2CON
94:                
95:                    
96:                    IFS0bits.T2IF = false;
002FD8  A9E084     BCLR IFS0, #7
97:                    IEC0bits.T2IE = true;
002FDA  A8E094     BSET IEC0, #7
98:                	
99:                    tmr2_obj.timerElapsed = false;
002FDC  209600     MOV #0x960, W0
002FDE  EB4080     CLR.B W1
002FE0  784801     MOV.B W1, [W0]
100:               
101:               }
002FE2  FA8000     ULNK
002FE4  060000     RETURN
102:               
103:               
104:               
105:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T2Interrupt (  )
106:               {
002FE6  F80036     PUSH RCOUNT
002FE8  BE9F80     MOV.D W0, [W15++]
002FEA  BE9F82     MOV.D W2, [W15++]
002FEC  BE9F84     MOV.D W4, [W15++]
002FEE  BE9F86     MOV.D W6, [W15++]
002FF0  FA0000     LNK #0x0
107:                   /* Check if the Timer Interrupt/Status is set */
108:               
109:                   //***User Area Begin
110:               
111:                   // ticker function call;
112:                   // ticker is 1 -> Callback function gets called everytime this ISR executes
113:                   TMR2_CallBack();
002FF2  0700ED     RCALL TMR2_CallBack
114:               
115:                   //***User Area End
116:               
117:                   tmr2_obj.count++;
002FF4  209610     MOV #0x961, W0
002FF6  784010     MOV.B [W0], W0
002FF8  E84080     INC.B W0, W1
002FFA  209610     MOV #0x961, W0
002FFC  784801     MOV.B W1, [W0]
118:                   tmr2_obj.timerElapsed = true;
002FFE  209600     MOV #0x960, W0
003000  B3C011     MOV.B #0x1, W1
003002  784801     MOV.B W1, [W0]
119:                   IFS0bits.T2IF = false;
003004  A9E084     BCLR IFS0, #7
120:               }
003006  FA8000     ULNK
003008  BE034F     MOV.D [--W15], W6
00300A  BE024F     MOV.D [--W15], W4
00300C  BE014F     MOV.D [--W15], W2
00300E  BE004F     MOV.D [--W15], W0
003010  F90036     POP RCOUNT
003012  064000     RETFIE
121:               
122:               
123:               void TMR2_Period16BitSet( uint16_t value )
124:               {
003014  FA0002     LNK #0x2
003016  780F00     MOV W0, [W14]
125:                   /* Update the counter values */
126:                   PR2 = value;
003018  78009E     MOV [W14], W1
00301A  880861     MOV W1, PR2
127:                   /* Reset the status information */
128:                   tmr2_obj.timerElapsed = false;
00301C  209600     MOV #0x960, W0
00301E  EB4080     CLR.B W1
003020  784801     MOV.B W1, [W0]
129:               }
003022  FA8000     ULNK
003024  060000     RETURN
130:               
131:               uint16_t TMR2_Period16BitGet( void )
132:               {
003026  FA0000     LNK #0x0
133:                   return( PR2 );
003028  800860     MOV PR2, W0
134:               }
00302A  FA8000     ULNK
00302C  060000     RETURN
135:               
136:               void TMR2_Counter16BitSet ( uint16_t value )
137:               {
00302E  FA0002     LNK #0x2
003030  780F00     MOV W0, [W14]
138:                   /* Update the counter values */
139:                   TMR2 = value;
003032  78009E     MOV [W14], W1
003034  880831     MOV W1, TMR2
140:                   /* Reset the status information */
141:                   tmr2_obj.timerElapsed = false;
003036  209600     MOV #0x960, W0
003038  EB4080     CLR.B W1
00303A  784801     MOV.B W1, [W0]
142:               }
00303C  FA8000     ULNK
00303E  060000     RETURN
143:               
144:               uint16_t TMR2_Counter16BitGet( void )
145:               {
003040  FA0000     LNK #0x0
146:                   return( TMR2 );
003042  800830     MOV TMR2, W0
147:               }
003044  FA8000     ULNK
003046  060000     RETURN
148:               
149:               
150:               void __attribute__ ((weak)) TMR2_CallBack(void)
151:               {
003048  FA0000     LNK #0x0
152:                   // Add your custom callback code here
153:               }
00304A  FA8000     ULNK
00304C  060000     RETURN
154:               
155:               void TMR2_Start( void )
156:               {
00304E  FA0000     LNK #0x0
157:                   /* Reset the status information */
158:                   tmr2_obj.timerElapsed = false;
003050  209600     MOV #0x960, W0
003052  EB4080     CLR.B W1
003054  784801     MOV.B W1, [W0]
159:               
160:                   /*Enable the interrupt*/
161:                   IEC0bits.T2IE = true;
003056  A8E094     BSET IEC0, #7
162:               
163:                   /* Start the Timer */
164:                   T2CONbits.TON = 1;
003058  A8E111     BSET 0x111, #7
165:               }
00305A  FA8000     ULNK
00305C  060000     RETURN
166:               
167:               void TMR2_Stop( void )
168:               {
00305E  FA0000     LNK #0x0
169:                   /* Stop the Timer */
170:                   T2CONbits.TON = false;
003060  A9E111     BCLR 0x111, #7
171:               
172:                   /*Disable the interrupt*/
173:                   IEC0bits.T2IE = false;
003062  A9E094     BCLR IEC0, #7
174:               }
003064  FA8000     ULNK
003066  060000     RETURN
175:               
176:               bool TMR2_GetElapsedThenClear(void)
177:               {
003068  FA0002     LNK #0x2
178:                   bool status;
179:                   
180:                   status = tmr2_obj.timerElapsed;
00306A  209600     MOV #0x960, W0
00306C  784F10     MOV.B [W0], [W14]
181:               
182:                   if(status == true)
00306E  78401E     MOV.B [W14], W0
003070  E00400     CP0.B W0
003072  320003     BRA Z, 0x307A
183:                   {
184:                       tmr2_obj.timerElapsed = false;
003074  209600     MOV #0x960, W0
003076  EB4080     CLR.B W1
003078  784801     MOV.B W1, [W0]
185:                   }
186:                   return status;
00307A  78401E     MOV.B [W14], W0
187:               }
00307C  FA8000     ULNK
00307E  060000     RETURN
188:               
189:               int TMR2_SoftwareCounterGet(void)
190:               {
003080  FA0000     LNK #0x0
191:                   return tmr2_obj.count;
003082  209610     MOV #0x961, W0
003084  784010     MOV.B [W0], W0
003086  FB8000     ZE W0, W0
192:               }
003088  FA8000     ULNK
00308A  060000     RETURN
193:               
194:               void TMR2_SoftwareCounterClear(void)
195:               {
00308C  FA0000     LNK #0x0
196:                   tmr2_obj.count = 0; 
00308E  209610     MOV #0x961, W0
003090  EB4080     CLR.B W1
003092  784801     MOV.B W1, [W0]
197:               }
003094  FA8000     ULNK
003096  060000     RETURN
198:               
199:               /**
200:                End of File
201:               */
---  F:/2017/cs66-b/cs66b.X/mcc_generated_files/tmr1.c  -------------------------------------------------
1:                 
2:                 /**
3:                   TMR1 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr1.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR1. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.45
18:                        Device            :  PIC24FJ128GA310
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 1.32
21:                        MPLAB 	          :  MPLAB X 3.61
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include <xc.h>
51:                #include "tmr1.h"
52:                
53:                /**
54:                  Section: Data Type Definitions
55:                */
56:                
57:                /** TMR Driver Hardware Instance Object
58:                
59:                  @Summary
60:                    Defines the object required for the maintainence of the hardware instance.
61:                
62:                  @Description
63:                    This defines the object required for the maintainence of the hardware
64:                    instance. This object exists once per hardware instance of the peripheral.
65:                
66:                  Remarks:
67:                    None.
68:                */
69:                
70:                typedef struct _TMR_OBJ_STRUCT
71:                {
72:                    /* Timer Elapsed */
73:                    bool                                                    timerElapsed;
74:                    /*Software Counter value*/
75:                    uint8_t                                                 count;
76:                
77:                } TMR_OBJ;
78:                
79:                static TMR_OBJ tmr1_obj;
80:                
81:                /**
82:                  Section: Driver Interface
83:                */
84:                
85:                
86:                void TMR1_Initialize (void)
87:                {
003098  FA0000     LNK #0x0
88:                    //TMR1 0; 
89:                    TMR1 = 0x0000;
00309A  EF2100     CLR TMR1
90:                    //Period = 0.0009997106 s; Frequency = 5529600 Hz; PR1 692; 
91:                    PR1 = 0x02B4;
00309C  202B40     MOV #0x2B4, W0
00309E  880810     MOV W0, PR1
92:                    //TCKPS 1:8; TON enabled; TSIDL disabled; TCS FOSC/2; TECS SOSC; TSYNC disabled; TGATE disabled; 
93:                    T1CON = 0x8010;
0030A0  280100     MOV #0x8010, W0
0030A2  880820     MOV W0, T1CON
94:                
95:                    
96:                    IFS0bits.T1IF = false;
0030A4  A96084     BCLR IFS0, #3
97:                    IEC0bits.T1IE = true;
0030A6  A86094     BSET IEC0, #3
98:                	
99:                    tmr1_obj.timerElapsed = false;
0030A8  209620     MOV #0x962, W0
0030AA  EB4080     CLR.B W1
0030AC  784801     MOV.B W1, [W0]
100:               
101:               }
0030AE  FA8000     ULNK
0030B0  060000     RETURN
102:               
103:               
104:               #if 1
105:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T1Interrupt (  )
106:               {
0030B2  F80036     PUSH RCOUNT
0030B4  BE9F80     MOV.D W0, [W15++]
0030B6  BE9F82     MOV.D W2, [W15++]
0030B8  BE9F84     MOV.D W4, [W15++]
0030BA  BE9F86     MOV.D W6, [W15++]
0030BC  FA0000     LNK #0x0
107:                   /* Check if the Timer Interrupt/Status is set */
108:               
109:                   //***User Area Begin
110:               
111:                   // ticker function call;
112:                   // ticker is 1 -> Callback function gets called everytime this ISR executes
113:                   TMR1_CallBack();
0030BE  070052     RCALL TMR1_CallBack
114:               
115:                   //***User Area End
116:               
117:                   tmr1_obj.count++;
0030C0  209630     MOV #0x963, W0
0030C2  784010     MOV.B [W0], W0
0030C4  E84080     INC.B W0, W1
0030C6  209630     MOV #0x963, W0
0030C8  784801     MOV.B W1, [W0]
118:                   tmr1_obj.timerElapsed = true;
0030CA  209620     MOV #0x962, W0
0030CC  B3C011     MOV.B #0x1, W1
0030CE  784801     MOV.B W1, [W0]
119:                   IFS0bits.T1IF = false;
0030D0  A96084     BCLR IFS0, #3
120:               }
0030D2  FA8000     ULNK
0030D4  BE034F     MOV.D [--W15], W6
0030D6  BE024F     MOV.D [--W15], W4
0030D8  BE014F     MOV.D [--W15], W2
0030DA  BE004F     MOV.D [--W15], W0
0030DC  F90036     POP RCOUNT
0030DE  064000     RETFIE
121:               #endif
122:               
123:               void TMR1_Period16BitSet( uint16_t value )
124:               {
0030E0  FA0002     LNK #0x2
0030E2  780F00     MOV W0, [W14]
125:                   /* Update the counter values */
126:                   PR1 = value;
0030E4  78009E     MOV [W14], W1
0030E6  880811     MOV W1, PR1
127:                   /* Reset the status information */
128:                   tmr1_obj.timerElapsed = false;
0030E8  209620     MOV #0x962, W0
0030EA  EB4080     CLR.B W1
0030EC  784801     MOV.B W1, [W0]
129:               }
0030EE  FA8000     ULNK
0030F0  060000     RETURN
130:               
131:               uint16_t TMR1_Period16BitGet( void )
132:               {
0030F2  FA0000     LNK #0x0
133:                   return( PR1 );
0030F4  800810     MOV PR1, W0
134:               }
0030F6  FA8000     ULNK
0030F8  060000     RETURN
135:               
136:               void TMR1_Counter16BitSet ( uint16_t value )
137:               {
0030FA  FA0002     LNK #0x2
0030FC  780F00     MOV W0, [W14]
138:                   /* Update the counter values */
139:                   TMR1 = value;
0030FE  78009E     MOV [W14], W1
003100  880801     MOV W1, TMR1
140:                   /* Reset the status information */
141:                   tmr1_obj.timerElapsed = false;
003102  209620     MOV #0x962, W0
003104  EB4080     CLR.B W1
003106  784801     MOV.B W1, [W0]
142:               }
003108  FA8000     ULNK
00310A  060000     RETURN
143:               
144:               uint16_t TMR1_Counter16BitGet( void )
145:               {
00310C  FA0000     LNK #0x0
146:                   return( TMR1 );
00310E  800800     MOV TMR1, W0
147:               }
003110  FA8000     ULNK
003112  060000     RETURN
148:               
149:               
150:               void __attribute__ ((weak)) TMR1_CallBack(void)
151:               {
003114  FA0000     LNK #0x0
152:                   // Add your custom callback code here
153:               }
003116  FA8000     ULNK
003118  060000     RETURN
154:               
155:               void TMR1_Start( void )
156:               {
00311A  FA0000     LNK #0x0
157:                   /* Reset the status information */
158:                   tmr1_obj.timerElapsed = false;
00311C  209620     MOV #0x962, W0
00311E  EB4080     CLR.B W1
003120  784801     MOV.B W1, [W0]
159:               
160:                   /*Enable the interrupt*/
161:                   IEC0bits.T1IE = true;
003122  A86094     BSET IEC0, #3
162:               
163:                   /* Start the Timer */
164:                   T1CONbits.TON = 1;
003124  A8E105     BSET 0x105, #7
165:               }
003126  FA8000     ULNK
003128  060000     RETURN
166:               
167:               void TMR1_Stop( void )
168:               {
00312A  FA0000     LNK #0x0
169:                   /* Stop the Timer */
170:                   T1CONbits.TON = false;
00312C  A9E105     BCLR 0x105, #7
171:               
172:                   /*Disable the interrupt*/
173:                   IEC0bits.T1IE = false;
00312E  A96094     BCLR IEC0, #3
174:               }
003130  FA8000     ULNK
003132  060000     RETURN
175:               
176:               bool TMR1_GetElapsedThenClear(void)
177:               {
003134  FA0002     LNK #0x2
178:                   bool status;
179:                   
180:                   status = tmr1_obj.timerElapsed;
003136  209620     MOV #0x962, W0
003138  784F10     MOV.B [W0], [W14]
181:               
182:                   if(status == true)
00313A  78401E     MOV.B [W14], W0
00313C  E00400     CP0.B W0
00313E  320003     BRA Z, 0x3146
183:                   {
184:                       tmr1_obj.timerElapsed = false;
003140  209620     MOV #0x962, W0
003142  EB4080     CLR.B W1
003144  784801     MOV.B W1, [W0]
185:                   }
186:                   return status;
003146  78401E     MOV.B [W14], W0
187:               }
003148  FA8000     ULNK
00314A  060000     RETURN
188:               
189:               int TMR1_SoftwareCounterGet(void)
190:               {
00314C  FA0000     LNK #0x0
191:                   return tmr1_obj.count;
00314E  209630     MOV #0x963, W0
003150  784010     MOV.B [W0], W0
003152  FB8000     ZE W0, W0
192:               }
003154  FA8000     ULNK
003156  060000     RETURN
193:               
194:               void TMR1_SoftwareCounterClear(void)
195:               {
003158  FA0000     LNK #0x0
196:                   tmr1_obj.count = 0; 
00315A  209630     MOV #0x963, W0
00315C  EB4080     CLR.B W1
00315E  784801     MOV.B W1, [W0]
197:               }
003160  FA8000     ULNK
003162  060000     RETURN
198:               
199:               /**
200:                End of File
201:               */
---  F:/2017/cs66-b/cs66b.X/mcc_generated_files/rtcc.c  -------------------------------------------------
1:                 
2:                 /**
3:                   RTCC Generated Driver API Header File
4:                 
5:                   @Company:
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name:
9:                     rtcc.c
10:                
11:                  @Summary:
12:                    This is the generated header file for the RTCC driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This header file provides APIs for driver for RTCC.
16:                    Generation Information :
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.45
18:                        Device            :  PIC24FJ128GA310
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 1.32
21:                        MPLAB 	          :  MPLAB X 3.61
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                
47:                /**
48:                 Section: Included Files
49:                */
50:                
51:                #include <xc.h>
52:                #include "rtcc.h"
53:                
54:                /**
55:                * Section: Function Prototype
56:                */
57:                static bool rtccTimeInitialized;
58:                static bool RTCCTimeInitialized(void);
59:                static uint8_t ConvertHexToBCD(uint8_t hexvalue);
60:                static uint8_t ConvertBCDToHex(uint8_t bcdvalue);
61:                
62:                /**
63:                * Section: Driver Interface Function Definitions
64:                */
65:                
66:                void RTCC_Initialize(void)
67:                {
002D00  FA0000     LNK #0x0
68:                
69:                   // Set the RTCWREN bit
70:                   __builtin_write_RTCWEN();
002D02  200550     MOV #0x55, W0
002D04  883B30     MOV W0, NVMKEY
002D06  200AA0     MOV #0xAA, W0
002D08  883B30     MOV W0, NVMKEY
002D0A  A8A627     BSET 0x627, #5
71:                
72:                   RCFGCALbits.RTCEN = 0;
002D0C  A9E627     BCLR 0x627, #7
73:                   
74:                   if(!RTCCTimeInitialized())
002D0E  07001C     RCALL _RTCCTimeInitialized
002D10  A20400     BTG.B W0, #0
002D12  E00400     CP0.B W0
002D14  32000C     BRA Z, 0x2D2E
75:                   {
76:                       // set RTCC time 2017-11-05 14-00-52
77:                       RCFGCALbits.RTCPTR = 3;        // start the sequence
002D16  803131     MOV RCFGCAL, W1
002D18  203000     MOV #0x300, W0
002D1A  700001     IOR W0, W1, W0
002D1C  883130     MOV W0, RCFGCAL
78:                       RTCVAL = 0x17;    // YEAR
002D1E  200170     MOV #0x17, W0
002D20  883120     MOV W0, RTCVAL
79:                       RTCVAL = 0x1105;    // MONTH-1/DAY-1
002D22  211050     MOV #0x1105, W0
002D24  883120     MOV W0, RTCVAL
80:                       RTCVAL = 0x14;    // WEEKDAY/HOURS
002D26  200140     MOV #0x14, W0
002D28  883120     MOV W0, RTCVAL
81:                       RTCVAL = 0x52;    // MINUTES/SECONDS
002D2A  200520     MOV #0x52, W0
002D2C  883120     MOV W0, RTCVAL
82:                   }
83:                
84:                   // RTCOUT Alarm Pulse; PWSPRE disabled; RTCLK SOSC; PWCPRE disabled; PWCEN disabled; PWCPOL disabled; 
85:                   RTCPWC = 0x0000;
002D2E  EF2628     CLR RTCPWC
86:                
87:                           
88:                   // Enable RTCC, clear RTCWREN
89:                   RCFGCALbits.RTCEN = 1;
002D30  A8E627     BSET 0x627, #7
90:                   RCFGCALbits.RTCWREN = 0;
002D32  A9A627     BCLR 0x627, #5
91:                
92:                   //Enable RTCC interrupt
93:                   IEC3bits.RTCIE = 1;
002D34  A8C09B     BSET 0x9B, #6
94:                }
002D36  FA8000     ULNK
002D38  060000     RETURN
95:                
96:                
97:                /**
98:                 This function implements RTCC_TimeReset.This function is used to
99:                 used by application to reset the RTCC value and reinitialize RTCC value.
100:               */
101:               void RTCC_TimeReset(bool reset)
102:               {
002D3A  FA0002     LNK #0x2
002D3C  784F00     MOV.B W0, [W14]
103:                   rtccTimeInitialized = reset;
002D3E  78411E     MOV.B [W14], W2
002D40  208281     MOV #0x828, W1
002D42  784882     MOV.B W2, [W1]
104:               }
002D44  FA8000     ULNK
002D46  060000     RETURN
105:               
106:               static bool RTCCTimeInitialized(void)
107:               {
002D48  FA0000     LNK #0x0
108:                   return(rtccTimeInitialized);
002D4A  BFC828     MOV.B rtccTimeInitialized, WREG
109:               }
002D4C  FA8000     ULNK
002D4E  060000     RETURN
110:               
111:               /**
112:                This function implements RTCC_TimeGet. It access the 
113:                registers of  RTCC and writes to them the values provided 
114:                in the function argument currentTime
115:               */
116:               
117:               bool RTCC_TimeGet(struct tm *currentTime)
118:               {
002D50  FA0004     LNK #0x4
002D52  980710     MOV W0, [W14+2]
119:                   uint16_t register_value;
120:                   if(RCFGCALbits.RTCSYNC){
002D54  803132     MOV RCFGCAL, W2
002D56  210000     MOV #0x1000, W0
002D58  610000     AND W2, W0, W0
002D5A  E00000     CP0 W0
002D5C  320002     BRA Z, 0x2D62
121:                       return false;
002D5E  EB4000     CLR.B W0
002D60  37004E     BRA 0x2DFE
122:                   }
123:               
124:                  // Set the RTCWREN bit
125:                  __builtin_write_RTCWEN();
002D62  200551     MOV #0x55, W1
002D64  883B31     MOV W1, NVMKEY
002D66  200AA1     MOV #0xAA, W1
002D68  883B31     MOV W1, NVMKEY
002D6A  A8A627     BSET 0x627, #5
126:               
127:                   RCFGCALbits.RTCPTR = 3;
002D6C  803131     MOV RCFGCAL, W1
002D6E  203000     MOV #0x300, W0
002D70  700001     IOR W0, W1, W0
002D72  883130     MOV W0, RCFGCAL
128:                   register_value = RTCVAL;
002D74  803121     MOV RTCVAL, W1
002D76  780F01     MOV W1, [W14]
129:                   currentTime->tm_year = ConvertBCDToHex(register_value & 0x00FF);
002D78  78001E     MOV [W14], W0
002D7A  784000     MOV.B W0, W0
002D7C  070114     RCALL _ConvertBCDToHex
002D7E  FB8080     ZE W0, W1
002D80  90001E     MOV [W14+2], W0
002D82  980051     MOV W1, [W0+10]
130:                   RCFGCALbits.RTCPTR = 2;
002D84  803131     MOV RCFGCAL, W1
002D86  2FCFF0     MOV #0xFCFF, W0
002D88  608000     AND W1, W0, W0
002D8A  A09000     BSET W0, #9
002D8C  883130     MOV W0, RCFGCAL
131:                   register_value = RTCVAL;
002D8E  803121     MOV RTCVAL, W1
002D90  780F01     MOV W1, [W14]
132:                   currentTime->tm_mon = ConvertBCDToHex((register_value & 0xFF00) >> 8);
002D92  78001E     MOV [W14], W0
002D94  DE0048     LSR W0, #8, W0
002D96  784000     MOV.B W0, W0
002D98  070106     RCALL _ConvertBCDToHex
002D9A  FB8080     ZE W0, W1
002D9C  90001E     MOV [W14+2], W0
002D9E  980041     MOV W1, [W0+8]
133:                   currentTime->tm_mday = ConvertBCDToHex(register_value & 0x00FF);
002DA0  78001E     MOV [W14], W0
002DA2  784000     MOV.B W0, W0
002DA4  070100     RCALL _ConvertBCDToHex
002DA6  FB8080     ZE W0, W1
002DA8  90001E     MOV [W14+2], W0
002DAA  980031     MOV W1, [W0+6]
134:                   RCFGCALbits.RTCPTR = 1;
002DAC  803131     MOV RCFGCAL, W1
002DAE  2FCFF0     MOV #0xFCFF, W0
002DB0  608000     AND W1, W0, W0
002DB2  A08000     BSET W0, #8
002DB4  883130     MOV W0, RCFGCAL
135:                   register_value = RTCVAL;
002DB6  803121     MOV RTCVAL, W1
002DB8  780F01     MOV W1, [W14]
136:                   currentTime->tm_wday = ConvertBCDToHex((register_value & 0xFF00) >> 8);
002DBA  78001E     MOV [W14], W0
002DBC  DE0048     LSR W0, #8, W0
002DBE  784000     MOV.B W0, W0
002DC0  0700F2     RCALL _ConvertBCDToHex
002DC2  FB8080     ZE W0, W1
002DC4  90001E     MOV [W14+2], W0
002DC6  980061     MOV W1, [W0+12]
137:                   currentTime->tm_hour = ConvertBCDToHex(register_value & 0x00FF);
002DC8  78001E     MOV [W14], W0
002DCA  784000     MOV.B W0, W0
002DCC  0700EC     RCALL _ConvertBCDToHex
002DCE  FB8080     ZE W0, W1
002DD0  90001E     MOV [W14+2], W0
002DD2  980021     MOV W1, [W0+4]
138:                   RCFGCALbits.RTCPTR = 0;
002DD4  803131     MOV RCFGCAL, W1
002DD6  2FCFF0     MOV #0xFCFF, W0
002DD8  608000     AND W1, W0, W0
002DDA  883130     MOV W0, RCFGCAL
139:                   register_value = RTCVAL;
002DDC  803121     MOV RTCVAL, W1
002DDE  780F01     MOV W1, [W14]
140:                   currentTime->tm_min = ConvertBCDToHex((register_value & 0xFF00) >> 8);
002DE0  78001E     MOV [W14], W0
002DE2  DE0048     LSR W0, #8, W0
002DE4  784000     MOV.B W0, W0
002DE6  0700DF     RCALL _ConvertBCDToHex
002DE8  FB8080     ZE W0, W1
002DEA  90001E     MOV [W14+2], W0
002DEC  980011     MOV W1, [W0+2]
141:                   currentTime->tm_sec = ConvertBCDToHex(register_value & 0x00FF);
002DEE  78001E     MOV [W14], W0
002DF0  784000     MOV.B W0, W0
002DF2  0700D9     RCALL _ConvertBCDToHex
002DF4  FB8080     ZE W0, W1
002DF6  90001E     MOV [W14+2], W0
002DF8  780801     MOV W1, [W0]
142:               
143:                   RCFGCALbits.RTCWREN = 0;
002DFA  A9A627     BCLR 0x627, #5
144:               
145:                   return true;
002DFC  B3C010     MOV.B #0x1, W0
146:               }
002DFE  FA8000     ULNK
002E00  060000     RETURN
147:               
148:               /**
149:                * This function sets the RTCC value and takes the input time in decimal format
150:               */
151:               
152:               void RTCC_TimeSet(struct tm *initialTime)
153:               {
002E02  FA0002     LNK #0x2
002E04  781F88     MOV W8, [W15++]
002E06  780F00     MOV W0, [W14]
154:                  // Set the RTCWREN bit
155:                  __builtin_write_RTCWEN();
002E08  200551     MOV #0x55, W1
002E0A  883B31     MOV W1, NVMKEY
002E0C  200AA1     MOV #0xAA, W1
002E0E  883B31     MOV W1, NVMKEY
002E10  A8A627     BSET 0x627, #5
156:               
157:                  RCFGCALbits.RTCEN = 0;
002E12  A9E627     BCLR 0x627, #7
158:                  
159:                  IFS3bits.RTCIF = false;
002E14  A9C08B     BCLR 0x8B, #6
160:                  IEC3bits.RTCIE = 0;
002E16  A9C09B     BCLR 0x9B, #6
161:               
162:                  // set RTCC initial time
163:                  RCFGCALbits.RTCPTR = 3;                               // start the sequence
002E18  803131     MOV RCFGCAL, W1
002E1A  203000     MOV #0x300, W0
002E1C  700001     IOR W0, W1, W0
002E1E  883130     MOV W0, RCFGCAL
164:                  RTCVAL =  ConvertHexToBCD(initialTime->tm_year);                        // YEAR
002E20  78001E     MOV [W14], W0
002E22  900050     MOV [W0+10], W0
002E24  784000     MOV.B W0, W0
002E26  0700A7     RCALL _ConvertHexToBCD
002E28  FB8000     ZE W0, W0
002E2A  883120     MOV W0, RTCVAL
165:                  RTCVAL = (ConvertHexToBCD(initialTime->tm_mon) << 8) | ConvertHexToBCD(initialTime->tm_mday);  // MONTH-1/DAY-1
002E2C  78001E     MOV [W14], W0
002E2E  900040     MOV [W0+8], W0
002E30  784000     MOV.B W0, W0
002E32  0700A1     RCALL _ConvertHexToBCD
002E34  FB8000     ZE W0, W0
002E36  DD0448     SL W0, #8, W8
002E38  78001E     MOV [W14], W0
002E3A  900030     MOV [W0+6], W0
002E3C  784000     MOV.B W0, W0
002E3E  07009B     RCALL _ConvertHexToBCD
002E40  FB8000     ZE W0, W0
002E42  700008     IOR W0, W8, W0
002E44  883120     MOV W0, RTCVAL
166:                  RTCVAL = (ConvertHexToBCD(initialTime->tm_wday) << 8) | ConvertHexToBCD(initialTime->tm_hour); // WEEKDAY/HOURS
002E46  78001E     MOV [W14], W0
002E48  900060     MOV [W0+12], W0
002E4A  784000     MOV.B W0, W0
002E4C  070094     RCALL _ConvertHexToBCD
002E4E  FB8000     ZE W0, W0
002E50  DD0448     SL W0, #8, W8
002E52  78001E     MOV [W14], W0
002E54  900020     MOV [W0+4], W0
002E56  784000     MOV.B W0, W0
002E58  07008E     RCALL _ConvertHexToBCD
002E5A  FB8000     ZE W0, W0
002E5C  700008     IOR W0, W8, W0
002E5E  883120     MOV W0, RTCVAL
167:                  RTCVAL = (ConvertHexToBCD(initialTime->tm_min) << 8) | ConvertHexToBCD(initialTime->tm_sec);   // MINUTES/SECONDS
002E60  78001E     MOV [W14], W0
002E62  900010     MOV [W0+2], W0
002E64  784000     MOV.B W0, W0
002E66  070087     RCALL _ConvertHexToBCD
002E68  FB8000     ZE W0, W0
002E6A  DD0448     SL W0, #8, W8
002E6C  78001E     MOV [W14], W0
002E6E  780010     MOV [W0], W0
002E70  784000     MOV.B W0, W0
002E72  070081     RCALL _ConvertHexToBCD
002E74  FB8000     ZE W0, W0
002E76  700008     IOR W0, W8, W0
002E78  883120     MOV W0, RTCVAL
168:                            
169:                  // Enable RTCC, clear RTCWREN         
170:                  RCFGCALbits.RTCEN = 1;  
002E7A  A8E627     BSET 0x627, #7
171:                  RCFGCALbits.RTCWREN = 0;
002E7C  A9A627     BCLR 0x627, #5
172:                  
173:                  IEC3bits.RTCIE = 1;
002E7E  A8C09B     BSET 0x9B, #6
174:               
175:               }
002E80  78044F     MOV [--W15], W8
002E82  FA8000     ULNK
002E84  060000     RETURN
176:               
177:               /**
178:                This function reads the RTCC time and returns the date and time in BCD format
179:                 */
180:               bool RTCC_BCDTimeGet(bcdTime_t *currentTime)
181:               {
002E86  FA0004     LNK #0x4
002E88  980710     MOV W0, [W14+2]
182:                   uint16_t register_value;
183:                   if(RCFGCALbits.RTCSYNC){
002E8A  803132     MOV RCFGCAL, W2
002E8C  210000     MOV #0x1000, W0
002E8E  610000     AND W2, W0, W0
002E90  E00000     CP0 W0
002E92  320002     BRA Z, 0x2E98
184:                       return false;
002E94  EB4000     CLR.B W0
002E96  370042     BRA 0x2F1C
185:                   }
186:               
187:                  // Set the RTCWREN bit
188:                  __builtin_write_RTCWEN();
002E98  200551     MOV #0x55, W1
002E9A  883B31     MOV W1, NVMKEY
002E9C  200AA1     MOV #0xAA, W1
002E9E  883B31     MOV W1, NVMKEY
002EA0  A8A627     BSET 0x627, #5
189:               
190:                   RCFGCALbits.RTCPTR = 3;
002EA2  803131     MOV RCFGCAL, W1
002EA4  203000     MOV #0x300, W0
002EA6  700001     IOR W0, W1, W0
002EA8  883130     MOV W0, RCFGCAL
191:                   register_value = RTCVAL;
002EAA  803121     MOV RTCVAL, W1
002EAC  780F01     MOV W1, [W14]
192:                   currentTime->tm_year = register_value;
002EAE  78009E     MOV [W14], W1
002EB0  90001E     MOV [W14+2], W0
002EB2  980051     MOV W1, [W0+10]
193:                   RCFGCALbits.RTCPTR = 2;
002EB4  803131     MOV RCFGCAL, W1
002EB6  2FCFF0     MOV #0xFCFF, W0
002EB8  608000     AND W1, W0, W0
002EBA  A09000     BSET W0, #9
002EBC  883130     MOV W0, RCFGCAL
194:                   register_value = RTCVAL;
002EBE  803121     MOV RTCVAL, W1
002EC0  780F01     MOV W1, [W14]
195:                   currentTime->tm_mon = (register_value & 0xFF00) >> 8;
002EC2  78001E     MOV [W14], W0
002EC4  DE0048     LSR W0, #8, W0
002EC6  780080     MOV W0, W1
002EC8  90001E     MOV [W14+2], W0
002ECA  980041     MOV W1, [W0+8]
196:                   currentTime->tm_mday = register_value & 0x00FF;
002ECC  78009E     MOV [W14], W1
002ECE  200FF0     MOV #0xFF, W0
002ED0  608080     AND W1, W0, W1
002ED2  90001E     MOV [W14+2], W0
002ED4  980031     MOV W1, [W0+6]
197:                   RCFGCALbits.RTCPTR = 1;
002ED6  803131     MOV RCFGCAL, W1
002ED8  2FCFF0     MOV #0xFCFF, W0
002EDA  608000     AND W1, W0, W0
002EDC  A08000     BSET W0, #8
002EDE  883130     MOV W0, RCFGCAL
198:                   register_value = RTCVAL;
002EE0  803121     MOV RTCVAL, W1
002EE2  780F01     MOV W1, [W14]
199:                   currentTime->tm_wday = (register_value & 0xFF00) >> 8;
002EE4  78001E     MOV [W14], W0
002EE6  DE0048     LSR W0, #8, W0
002EE8  780080     MOV W0, W1
002EEA  90001E     MOV [W14+2], W0
002EEC  980061     MOV W1, [W0+12]
200:                   currentTime->tm_hour = register_value & 0x00FF;
002EEE  78009E     MOV [W14], W1
002EF0  200FF0     MOV #0xFF, W0
002EF2  608080     AND W1, W0, W1
002EF4  90001E     MOV [W14+2], W0
002EF6  980021     MOV W1, [W0+4]
201:                   RCFGCALbits.RTCPTR = 0;
002EF8  803131     MOV RCFGCAL, W1
002EFA  2FCFF0     MOV #0xFCFF, W0
002EFC  608000     AND W1, W0, W0
002EFE  883130     MOV W0, RCFGCAL
202:                   register_value = RTCVAL;
002F00  803121     MOV RTCVAL, W1
002F02  780F01     MOV W1, [W14]
203:                   currentTime->tm_min = (register_value & 0xFF00) >> 8;
002F04  78001E     MOV [W14], W0
002F06  DE0048     LSR W0, #8, W0
002F08  780080     MOV W0, W1
002F0A  90001E     MOV [W14+2], W0
002F0C  980011     MOV W1, [W0+2]
204:                   currentTime->tm_sec = register_value & 0x00FF;
002F0E  78009E     MOV [W14], W1
002F10  200FF0     MOV #0xFF, W0
002F12  608080     AND W1, W0, W1
002F14  90001E     MOV [W14+2], W0
002F16  780801     MOV W1, [W0]
205:                   RCFGCALbits.RTCWREN = 0;
002F18  A9A627     BCLR 0x627, #5
206:               
207:                   return true;
002F1A  B3C010     MOV.B #0x1, W0
208:               }
002F1C  FA8000     ULNK
002F1E  060000     RETURN
209:               /**
210:                This function takes the input date and time in BCD format and sets the RTCC
211:                */
212:               void RTCC_BCDTimeSet(bcdTime_t *initialTime)
213:               {
002F20  FA0002     LNK #0x2
002F22  780F00     MOV W0, [W14]
214:                  // Set the RTCWREN bit
215:                  __builtin_write_RTCWEN();
002F24  200551     MOV #0x55, W1
002F26  883B31     MOV W1, NVMKEY
002F28  200AA1     MOV #0xAA, W1
002F2A  883B31     MOV W1, NVMKEY
002F2C  A8A627     BSET 0x627, #5
216:               
217:                  RCFGCALbits.RTCEN = 0;
002F2E  A9E627     BCLR 0x627, #7
218:               
219:                  IFS3bits.RTCIF = false;
002F30  A9C08B     BCLR 0x8B, #6
220:                  IEC3bits.RTCIE = 0;
002F32  A9C09B     BCLR 0x9B, #6
221:               
222:                  // set RTCC initial time
223:                  RCFGCALbits.RTCPTR = 3;                               // start the sequence
002F34  803131     MOV RCFGCAL, W1
002F36  203000     MOV #0x300, W0
002F38  700001     IOR W0, W1, W0
002F3A  883130     MOV W0, RCFGCAL
224:                  RTCVAL = initialTime->tm_year;                        // YEAR
002F3C  78001E     MOV [W14], W0
002F3E  900050     MOV [W0+10], W0
002F40  883120     MOV W0, RTCVAL
225:                  RTCVAL = (initialTime->tm_mon << 8) | initialTime->tm_mday;  // MONTH-1/DAY-1
002F42  78001E     MOV [W14], W0
002F44  900040     MOV [W0+8], W0
002F46  DD00C8     SL W0, #8, W1
002F48  78001E     MOV [W14], W0
002F4A  900030     MOV [W0+6], W0
002F4C  700001     IOR W0, W1, W0
002F4E  883120     MOV W0, RTCVAL
226:                  RTCVAL = (initialTime->tm_wday << 8) | initialTime->tm_hour; // WEEKDAY/HOURS
002F50  78001E     MOV [W14], W0
002F52  900060     MOV [W0+12], W0
002F54  DD00C8     SL W0, #8, W1
002F56  78001E     MOV [W14], W0
002F58  900020     MOV [W0+4], W0
002F5A  700001     IOR W0, W1, W0
002F5C  883120     MOV W0, RTCVAL
227:                  RTCVAL = (initialTime->tm_min << 8) | initialTime->tm_sec;   // MINUTES/SECONDS
002F5E  78001E     MOV [W14], W0
002F60  900010     MOV [W0+2], W0
002F62  DD00C8     SL W0, #8, W1
002F64  78001E     MOV [W14], W0
002F66  780010     MOV [W0], W0
002F68  700001     IOR W0, W1, W0
002F6A  883120     MOV W0, RTCVAL
228:               
229:                  // Enable RTCC, clear RTCWREN
230:                  RCFGCALbits.RTCEN = 1;
002F6C  A8E627     BSET 0x627, #7
231:                  RCFGCALbits.RTCWREN = 0;
002F6E  A9A627     BCLR 0x627, #5
232:               
233:                  IEC3bits.RTCIE = 1;
002F70  A8C09B     BSET 0x9B, #6
234:               
235:               }
002F72  FA8000     ULNK
002F74  060000     RETURN
236:               
237:               static uint8_t ConvertHexToBCD(uint8_t hexvalue)
238:               {
002F76  FA0004     LNK #0x4
002F78  984720     MOV.B W0, [W14+2]
239:                   uint8_t bcdvalue;
240:                   bcdvalue = (hexvalue / 10) << 4;
002F7A  90402E     MOV.B [W14+2], W0
002F7C  FB8080     ZE W0, W1
002F7E  2000A0     MOV #0xA, W0
002F80  780100     MOV W0, W2
002F82  090011     REPEAT #0x11
002F84  D88082     DIV.UW W1, W2
002F86  784080     MOV.B W0, W1
002F88  200040     MOV #0x4, W0
002F8A  DD0800     SL W1, W0, W0
002F8C  784F00     MOV.B W0, [W14]
241:                   bcdvalue = bcdvalue | (hexvalue % 10);
002F8E  90402E     MOV.B [W14+2], W0
002F90  FB8080     ZE W0, W1
002F92  2000A0     MOV #0xA, W0
002F94  780100     MOV W0, W2
002F96  090011     REPEAT #0x11
002F98  D88082     DIV.UW W1, W2
002F9A  FD0080     EXCH W0, W1
002F9C  784000     MOV.B W0, W0
002F9E  704F1E     IOR.B W0, [W14], [W14]
242:                   return (bcdvalue);
002FA0  78401E     MOV.B [W14], W0
243:               }
002FA2  FA8000     ULNK
002FA4  060000     RETURN
244:               
245:               static uint8_t ConvertBCDToHex(uint8_t bcdvalue)
246:               {
002FA6  FA0004     LNK #0x4
002FA8  984720     MOV.B W0, [W14+2]
247:                   uint8_t hexvalue;
248:                   hexvalue = (((bcdvalue & 0xF0) >> 4)* 10) + (bcdvalue & 0x0F);
002FAA  90402E     MOV.B [W14+2], W0
002FAC  FB8000     ZE W0, W0
002FAE  DE0044     LSR W0, #4, W0
002FB0  784000     MOV.B W0, W0
002FB2  B9006A     MUL.SU W0, #10, W0
002FB4  780000     MOV W0, W0
002FB6  784080     MOV.B W0, W1
002FB8  90402E     MOV.B [W14+2], W0
002FBA  60406F     AND.B W0, #0xF, W0
002FBC  40CF00     ADD.B W1, W0, [W14]
249:                   return hexvalue;
002FBE  78401E     MOV.B [W14], W0
250:               }
002FC0  FA8000     ULNK
002FC2  060000     RETURN
251:               
252:               
253:               /* Function:
254:                 void __attribute__ ( ( interrupt, no_auto_psv ) ) _ISR _RTCCInterrupt( void )
255:               
256:                 Summary:
257:                   Interrupt Service Routine for the RTCC Peripheral
258:               
259:                 Description:
260:                   This is the interrupt service routine for the RTCC peripheral. Add in code if 
261:                   required in the ISR. 
262:               */
263:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _ISR _RTCCInterrupt( void )
264:               {
002FC4  FA0000     LNK #0x0
265:                   /* TODO : Add interrupt handling code */
266:                   IFS3bits.RTCIF = false;
002FC6  A9C08B     BCLR 0x8B, #6
267:               }
002FC8  FA8000     ULNK
002FCA  064000     RETFIE
268:               
269:               
270:               /**
271:                End of File
272:               */
---  F:/2017/cs66-b/cs66b.X/mcc_generated_files/pin_manager.c  ------------------------------------------
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     pin_manager.c
9:                 
10:                  @Summary:
11:                    This is the generated manager file for the MPLAB(c) Code Configurator device.  This manager
12:                    configures the pins direction, initial state, analog setting.
13:                    The peripheral pin select, PPS, configuration is also handled by this manager.
14:                
15:                  @Description:
16:                    This source file provides implementations for MPLAB(c) Code Configurator interrupts.
17:                    Generation Information : 
18:                        Product Revision  :  MPLAB(c) Code Configurator - 4.26
19:                        Device            :  PIC24FJ128GA310
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 1.32
22:                        MPLAB             :  MPLAB X 3.61
23:                
24:                    Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
25:                
26:                    Microchip licenses to you the right to use, modify, copy and distribute
27:                    Software only when embedded on a Microchip microcontroller or digital signal
28:                    controller that is integrated into your product or third party product
29:                    (pursuant to the sublicense terms in the accompanying license agreement).
30:                
31:                    You should refer to the license agreement accompanying this Software for
32:                    additional information regarding your rights and obligations.
33:                
34:                    SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                    EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                    MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                    IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                    CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                    OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                    INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                    CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                    SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                    (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                
45:                */
46:                
47:                
48:                /**
49:                    Section: Includes
50:                */
51:                #include <xc.h>
52:                #include "pin_manager.h"
53:                
54:                /**
55:                    void PIN_MANAGER_Initialize(void)
56:                */
57:                void PIN_MANAGER_Initialize(void)
58:                {
0031FE  FA0000     LNK #0x0
59:                    /****************************************************************************
60:                     * Setting the Output Latch SFR(s)
61:                     ***************************************************************************/
62:                    LATA = 0x0000;
003200  EF22C4     CLR LATA
63:                    LATB = 0x0000;
003202  EF22CC     CLR LATB
64:                    LATC = 0x0000;
003204  EF22D4     CLR LATC
65:                    LATD = 0x0000;
003206  EF22DC     CLR LATD
66:                    LATE = 0x0000;
003208  EF22E4     CLR LATE
67:                    LATF = 0x0000;
00320A  EF22EC     CLR LATF
68:                    LATG = 0x0000;
00320C  EF22F4     CLR LATG
69:                
70:                    /****************************************************************************
71:                     * Setting the GPIO Direction SFR(s)
72:                     ***************************************************************************/
73:                    TRISA = 0xC6FF;
00320E  2C6FF0     MOV #0xC6FF, W0
003210  881600     MOV W0, TRISA
74:                    TRISB = 0xFFFF;
003212  EB8000     SETM W0
003214  881640     MOV W0, TRISB
75:                    TRISC = 0x901E;
003216  2901E0     MOV #0x901E, W0
003218  881680     MOV W0, TRISC
76:                    TRISD = 0xFFFF;
00321A  EB8000     SETM W0
00321C  8816C0     MOV W0, TRISD
77:                    TRISE = 0x03FF;
00321E  203FF0     MOV #0x3FF, W0
003220  881700     MOV W0, TRISE
78:                    TRISF = 0x31FF;
003222  231FF0     MOV #0x31FF, W0
003224  881740     MOV W0, TRISF
79:                    TRISG = 0xF3CF;
003226  2F3CF0     MOV #0xF3CF, W0
003228  881780     MOV W0, TRISG
80:                
81:                    /****************************************************************************
82:                     * Setting the Weak Pull Up and Weak Pull Down SFR(s)
83:                     ***************************************************************************/
84:                    CNPD1 = 0x0000;
00322A  EF2056     CLR CNPD1
85:                    CNPD2 = 0x0000;
00322C  EF2058     CLR CNPD2
86:                    CNPD3 = 0x0000;
00322E  EF205A     CLR CNPD3
87:                    CNPD4 = 0x0000;
003230  EF205C     CLR CNPD4
88:                    CNPD5 = 0x0000;
003232  EF205E     CLR CNPD5
89:                    CNPD6 = 0x0000;
003234  EF2060     CLR CNPD6
90:                    CNPU1 = 0x0000;
003236  EF206E     CLR CNPU1
91:                    CNPU2 = 0x0000;
003238  EF2070     CLR CNPU2
92:                    CNPU3 = 0x0000;
00323A  EF2072     CLR CNPU3
93:                    CNPU4 = 0x0000;
00323C  EF2074     CLR CNPU4
94:                    CNPU5 = 0x0000;
00323E  EF2076     CLR CNPU5
95:                    CNPU6 = 0x0000;
003240  EF2078     CLR CNPU6
96:                
97:                    /****************************************************************************
98:                     * Setting the Open Drain SFR(s)
99:                     ***************************************************************************/
100:                   ODCA = 0x0000;
003242  EF22C6     CLR ODCA
101:                   ODCB = 0x0000;
003244  EF22CE     CLR ODCB
102:                   ODCC = 0x0000;
003246  EF22D6     CLR ODCC
103:                   ODCD = 0x0000;
003248  EF22DE     CLR ODCD
104:                   ODCE = 0x0000;
00324A  EF22E6     CLR ODCE
105:                   ODCF = 0x0000;
00324C  EF22EE     CLR ODCF
106:                   ODCG = 0x0000;
00324E  EF22F6     CLR ODCG
107:               
108:                   /****************************************************************************
109:                    * Setting the Analog/Digital Configuration SFR(s)
110:                    ***************************************************************************/
111:                   ANSA = 0x02C0;
003250  202C00     MOV #0x2C0, W0
003252  882700     MOV W0, ANSA
112:                   ANSB = 0xFFCF;
003254  2FFCF0     MOV #0xFFCF, W0
003256  882710     MOV W0, ANSB
113:                   ANSC = 0x0010;
003258  200100     MOV #0x10, W0
00325A  882720     MOV W0, ANSC
114:                   ANSD = 0x0CC0;
00325C  20CC00     MOV #0xCC0, W0
00325E  882730     MOV W0, ANSD
115:                   ANSE = 0x02F0;
003260  202F00     MOV #0x2F0, W0
003262  882740     MOV W0, ANSE
116:                   ANSG = 0x03C0;
003264  203C00     MOV #0x3C0, W0
003266  882760     MOV W0, ANSG
117:               
118:               }
003268  FA8000     ULNK
00326A  060000     RETURN
119:               
---  F:/2017/cs66-b/cs66b.X/mcc_generated_files/mcc.c  --------------------------------------------------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     mcc.c
9:                 
10:                  @Summary:
11:                    This is the mcc.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.45
17:                        Device            :  PIC24FJ128GA310
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 1.32
20:                        MPLAB             :  MPLAB X 3.61
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                // Configuration bits: selected in the GUI
46:                
47:                // CONFIG4
48:                #pragma config DSWDTPS = DSWDTPS1F    // Deep Sleep Watchdog Timer Postscale Select bits->1:68719476736 (25.7 Days)
49:                #pragma config DSWDTOSC = LPRC    // DSWDT Reference Clock Select->DSWDT uses LPRC as reference clock
50:                #pragma config DSBOREN = ON    // Deep Sleep BOR Enable bit->DSBOR Enabled
51:                #pragma config DSWDTEN = ON    // Deep Sleep Watchdog Timer Enable->DSWDT Enabled
52:                #pragma config DSSWEN = ON    // DSEN Bit Enable->Deep Sleep is controlled by the register bit DSEN
53:                
54:                // CONFIG3
55:                #pragma config WPFP = WPFP127    // Write Protection Flash Page Segment Boundary->Page 127 (0x1FC00)
56:                #pragma config VBTBOR = ON    // VBAT BOR enable bit->VBAT BOR enabled
57:                #pragma config SOSCSEL = ON    // SOSC Selection bits->SOSC circuit selected
58:                #pragma config WDTWIN = PS25_0    // Watch Dog Timer Window Width->Watch Dog Timer Window Width is 25 percent
59:                #pragma config BOREN = ON    // Brown-out Reset Enable->Brown-out Reset Enable
60:                #pragma config WPDIS = WPDIS    // Segment Write Protection Disable->Disabled
61:                #pragma config WPCFG = WPCFGDIS    // Write Protect Configuration Page Select->Disabled
62:                #pragma config WPEND = WPENDMEM    // Segment Write Protection End Page Select->Write Protect from WPFP to the last page of memory
63:                
64:                // CONFIG2
65:                #pragma config POSCMD = HS    // Primary Oscillator Select->HS Oscillator Enabled
66:                #pragma config BOREN1 = EN    // BOR Override bit->BOR Enabled [When BOREN=1]
67:                #pragma config IOL1WAY = ON    // IOLOCK One-Way Set Enable bit->Once set, the IOLOCK bit cannot be cleared
68:                #pragma config OSCIOFCN = OFF    // OSCO Pin Configuration->OSCO/CLKO/RC15 functions as CLKO (FOSC/2)
69:                #pragma config FCKSM = CSECME    // Clock Switching and Fail-Safe Clock Monitor Configuration bits->Clock switching is enabled, Fail-Safe Clock Monitor is enabled
70:                #pragma config FNOSC = PRI    // Initial Oscillator Select->Primary Oscillator (XT, HS, EC)
71:                #pragma config ALTVREF = DLT_AV_DLT_CV    // Alternate VREF/CVREF Pins Selection bit->Voltage reference input, ADC =RA9/RA10 Comparator =RA9,RA10
72:                #pragma config IESO = ON    // Internal External Switchover->Enabled
73:                
74:                // CONFIG1
75:                #pragma config WDTPS = PS8    // Watchdog Timer Postscaler Select->1:8
76:                #pragma config FWPSA = PR32    // WDT Prescaler Ratio Select->1:32
77:                #pragma config FWDTEN = WDT_DIS    // Watchdog Timer Enable->WDT disabled in hardware; SWDTEN bit disabled
78:                #pragma config WINDIS = ON    // Windowed WDT Disable->Windowed Watchdog Timer
79:                #pragma config ICS = PGx3    // Emulator Pin Placement Select bits->Emulator functions are shared with PGEC3/PGED3
80:                #pragma config LPCFG = OFF    // Low power regulator control->Disabled
81:                #pragma config GWRP = OFF    // General Segment Write Protect->Disabled
82:                #pragma config GCP = OFF    // General Segment Code Protect->Code protection is disabled
83:                #pragma config JTAGEN = OFF    // JTAG Port Enable->Disabled
84:                
85:                #include "mcc.h"
86:                
87:                void SYSTEM_Initialize(void)
88:                {
0033A8  FA0000     LNK #0x0
89:                    PIN_MANAGER_Initialize();
0033AA  07FF29     RCALL PIN_MANAGER_Initialize
90:                    INTERRUPT_Initialize();
0033AC  070014     RCALL INTERRUPT_Initialize
91:                    OSCILLATOR_Initialize();
0033AE  070005     RCALL OSCILLATOR_Initialize
92:                    TMR2_Initialize();
0033B0  07FE0D     RCALL TMR2_Initialize
93:                    RTCC_Initialize();
0033B2  07FCA6     RCALL RTCC_Initialize
94:                    TMR1_Initialize();
0033B4  07FE71     RCALL TMR1_Initialize
95:                }
0033B6  FA8000     ULNK
0033B8  060000     RETURN
96:                
97:                void OSCILLATOR_Initialize(void)
98:                {
0033BA  FA0000     LNK #0x0
99:                    // CF no clock failure; NOSC PRI; SOSCEN enabled; POSCEN disabled; CLKLOCK unlocked; OSWEN Switch is Complete; IOLOCK not-active; 
100:                   __builtin_write_OSCCONL((uint8_t) (0x0202 & 0x00FF));
0033BC  200022     MOV #0x2, W2
0033BE  200460     MOV #0x46, W0
0033C0  200571     MOV #0x57, W1
0033C2  207423     MOV #0x742, W3
0033C4  784980     MOV.B W0, [W3]
0033C6  784981     MOV.B W1, [W3]
0033C8  784982     MOV.B W2, [W3]
101:                   // RCDIV FRC/2; DOZE 1:8; DOZEN disabled; ROI disabled; 
102:                   CLKDIV = 0x3100;
0033CA  231000     MOV #0x3100, W0
0033CC  883A20     MOV W0, CLKDIV
103:                   // TUN Center frequency; 
104:                   OSCTUN = 0x0000;
0033CE  EF2748     CLR OSCTUN
105:                   // ROEN disabled; ROSEL disabled; RODIV Base clock value; ROSSLP disabled; 
106:                   REFOCON = 0x0000;
0033D0  EF274E     CLR REFOCON
107:               }
0033D2  FA8000     ULNK
0033D4  060000     RETURN
108:               
109:               /**
110:                End of File
111:               */
---  F:/2017/cs66-b/cs66b.X/mcc_generated_files/interrupt_manager.c  ------------------------------------
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.45
18:                        Device            :  PIC24FJ128GA310
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 1.32
21:                        MPLAB             :  MPLAB X 3.61
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                
50:                /**
51:                    void INTERRUPT_Initialize (void)
52:                */
53:                void INTERRUPT_Initialize (void)
54:                {
0033D6  FA0000     LNK #0x0
55:                    //    RTCI: RTCC - Real-Time Clock and Calendar
56:                    //    Priority: 1
57:                        IPC15bits.RTCIP = 1;
0033D8  800611     MOV IPC15, W1
0033DA  2F8FF0     MOV #0xF8FF, W0
0033DC  608000     AND W1, W0, W0
0033DE  A08000     BSET W0, #8
0033E0  880610     MOV W0, IPC15
58:                    //    TI: T2 - Timer2
59:                    //    Priority: 1
60:                        IPC1bits.T2IP = 1;
0033E2  800531     MOV IPC1, W1
0033E4  28FFF0     MOV #0x8FFF, W0
0033E6  608000     AND W1, W0, W0
0033E8  A0C000     BSET W0, #12
0033EA  880530     MOV W0, IPC1
61:                    //    TI: T1 - Timer1
62:                    //    Priority: 1
63:                        IPC0bits.T1IP = 1;
0033EC  800521     MOV IPC0, W1
0033EE  28FFF0     MOV #0x8FFF, W0
0033F0  608000     AND W1, W0, W0
0033F2  A0C000     BSET W0, #12
0033F4  880520     MOV W0, IPC0
64:                
65:                }
0033F6  FA8000     ULNK
0033F8  060000     RETURN
